<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>直线斜率-表示</title>
    <link href="/2024/09/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E7%9B%B4%E7%BA%BF%E6%96%9C%E7%8E%87-%E8%A1%A8%E7%A4%BA/"/>
    <url>/2024/09/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E7%9B%B4%E7%BA%BF%E6%96%9C%E7%8E%87-%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<ul><li>[[必要的分类讨论]]<ul><li>使用gcd，将斜率表示为最简分式字符串</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>必要的分类讨论</title>
    <link href="/2024/09/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%BF%85%E8%A6%81%E7%9A%84%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"/>
    <url>/2024/09/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%BF%85%E8%A6%81%E7%9A%84%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="交叉路口过车可行方案"><a href="#交叉路口过车可行方案" class="headerlink" title="交叉路口过车可行方案"></a>交叉路口过车可行方案</h2><ul><li><a href="https://leetcode.cn/problems/Y1VbOX/solutions/1/ha-xi-biao-dong-tai-gui-hua-by-megurine-mn3p">LCP 43. 十字路口的交通</a></li></ul><h2 id="数学-拿石子"><a href="#数学-拿石子" class="headerlink" title="数学 - 拿石子"></a>数学 - 拿石子</h2><ul><li>[[比较难的博弈问题]]</li></ul><h2 id="直线上最多的点数"><a href="#直线上最多的点数" class="headerlink" title="直线上最多的点数"></a>直线上最多的点数</h2><ul><li><a href="https://leetcode.cn/problems/max-points-on-a-line/">149. 直线上最多的点数</a></li><li>真暴力的话，我都想不出来怎么遍历所有情况<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust">func <span class="hljs-title function_ invoke__">maxPoints</span>(points [][]int) int<br>&#123;<br>ans := <span class="hljs-number">0</span><br>n := <span class="hljs-title function_ invoke__">len</span>(points) <br><span class="hljs-keyword">for</span> <span class="hljs-title class_">i</span> := <span class="hljs-number">0</span>; i &lt; n; i++ <br>&#123; <br><span class="hljs-comment">// 遍历每一个点作为直线上的一个点 </span><br><span class="hljs-comment">// 用统计其他点与当前点i的斜率出现次数 </span><br>cnt := <span class="hljs-title function_ invoke__">make</span>(map[string]int) <span class="hljs-comment">// key为其他点与当前点i的斜率，value为该斜率的个数 </span><br><span class="hljs-comment">// 遍历其他点，计算与当前点i的斜率</span><br><span class="hljs-keyword">for</span> <span class="hljs-title class_">j</span> := i + <span class="hljs-number">1</span>; j &lt; n; j++ <br>&#123; <br>diffX := points[j][<span class="hljs-number">0</span>] - points[i][<span class="hljs-number">0</span>]<br>diffY := points[j][<span class="hljs-number">1</span>] - points[i][<span class="hljs-number">1</span>]<br>z := <span class="hljs-title function_ invoke__">gcd</span>(diffX, diffY)<br><span class="hljs-comment">// 这里直接用最简分式作为key，代表斜率</span><br>key := strconv.<span class="hljs-title function_ invoke__">Itoa</span>(diffY / z) + <span class="hljs-string">&quot;/&quot;</span> + strconv.<span class="hljs-title function_ invoke__">Itoa</span>(diffX / z)<br>cnt[key]++<br>ans = <span class="hljs-title function_ invoke__">max</span>(ans, cnt[key])<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span><br>&#125;<br>func <span class="hljs-title function_ invoke__">gcd</span>(a, b int) int &#123; <span class="hljs-keyword">for</span> <span class="hljs-title class_">b</span> != <span class="hljs-number">0</span> &#123; a, b = b, a % b &#125; <span class="hljs-keyword">return</span> a &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>比较难的博弈问题</title>
    <link href="/2024/09/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="拿石子问题"><a href="#拿石子问题" class="headerlink" title="拿石子问题"></a>拿石子问题</h2><p>一般考虑两种方法：</p><ol><li>思考问题的规律，直接根据某些特性进行判断</li><li>递归</li></ol><h3 id="0917（Li）"><a href="#0917（Li）" class="headerlink" title="0917（Li）"></a>0917（Li）</h3><ul><li>两堆石子，你先拿。每次只能从数目多的堆中拿石子，且拿的石子数为另一个堆的整数倍。能拿到某个堆最后一个石子的人获胜。问：你是否能获胜？<ul><li>思考了很久：方法一 - 直接找出特性 -&gt; 没有想出来</li><li>转递归方法：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &lt; y) <span class="hljs-built_in">swap</span>(x, y);<br><span class="hljs-keyword">if</span> (x % y == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 这一步比较难🤔：</span><br><span class="hljs-comment">* == 1时，必须拿</span><br><span class="hljs-comment">* x / y &gt; 1时，拿的数量可以控制</span><br><span class="hljs-comment">* --&gt; 考虑剩下一个整数倍：如果后续为true，则OK</span><br><span class="hljs-comment">* --&gt; 考虑剩下一个整数倍：如果后续为false，则改变策略</span><br><span class="hljs-comment">* 拿走(x / y -1)个整数倍：则获胜</span><br><span class="hljs-comment">* --&gt; 因此，这种情况下，必胜</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (x / y &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> !<span class="hljs-built_in">dfs</span>(y, x % y);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制集合操作</title>
    <link href="/2024/09/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/09/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>oi wiki</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>一个整数的二进制可以看作是一个集合（0表示在，1表示不在），但是该集合中元素的数目有限</p><h4 id="n-1"><a href="#n-1" class="headerlink" title="n-1"></a>n-1</h4><p>一个数n，n-1表示：将最低位1删除，且后续的所有0变为1</p><h4 id="快速判断一个数是否为2的非负整数幂"><a href="#快速判断一个数是否为2的非负整数幂" class="headerlink" title="快速判断一个数是否为2的非负整数幂"></a>快速判断一个数是否为2的非负整数幂</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; ((n<span class="hljs-number">-1</span>)&amp;n) == <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><h4 id="子集遍历"><a href="#子集遍历" class="headerlink" title="子集遍历"></a>子集遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 降序遍历 n 的子集</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = n;; m = (m - <span class="hljs-number">1</span>) &amp; n)<br>&#123; <br><span class="hljs-comment">// m 是 n 的一个子集 </span><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>在掩码中减去1，等价于删除掩码m中的最后一位1，并将之后的所有0变为1。为了使m-1变为新的掩码，需要删除掩码中的额外的1，可以使用位运算<code>(m-1)&amp;n</code>进行<br>特殊情况是<code>m==0</code>，在执行m-1后变为-1，其所有位均为1，因此会无限循环</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见BUG</title>
    <link href="/2024/09/17/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%B8%B8%E8%A7%81BUG/"/>
    <url>/2024/09/17/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%B8%B8%E8%A7%81BUG/</url>
    
    <content type="html"><![CDATA[<h4 id="32位整形溢出"><a href="#32位整形溢出" class="headerlink" title="32位整形溢出"></a>32位整形溢出</h4><ul><li>比较经典的是时间比较，需要考虑溢出情况<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (lower - greater &gt; <span class="hljs-number">0x7FFFFFFF</span>) &#123;ok, smaller is <span class="hljs-literal">true</span>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速判断两个字符串是否相等</title>
    <link href="/2024/09/10/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
    <url>/2024/09/10/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h2 id="方法一：-hash"><a href="#方法一：-hash" class="headerlink" title="方法一： hash"></a>方法一： hash</h2><h2 id="方法二：二维DP"><a href="#方法二：二维DP" class="headerlink" title="方法二：二维DP"></a>方法二：二维DP</h2>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux - 进程-线程-内核线程概念区分</title>
    <link href="/2024/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/"/>
    <url>/2024/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="父进程与子进程"><a href="#父进程与子进程" class="headerlink" title="父进程与子进程"></a>父进程与子进程</h2><ul><li><p>父子进程虚拟内存空间</p><ul><li>通过<code>vfork/clone</code>系统调用创建出的子进程（线程）共享父进程的虚拟内存空间：即直接将父进程的虚拟内存空间结构体「<code>struct mm_struct</code>」的地址赋值给子进程中的虚拟内存空间结构体指针，并增加父进程虚拟内存空间结构体的引用计数；即子进程不含有「<code>struct mm_struct</code>」的内存</li><li>通过<code>fork</code>系统调用创建出的子进程，则将父进程的虚拟内存空间以及相关页表拷贝到拷贝到子进程的「<code>struct mm_struct</code>」中，即子进程含有自己的「<code>struct mm_struct</code>」结构内存 -&gt; 此时子进程虚拟内存对应的物理内存应该是与父进程相同的！！！❌ -&gt; 共享代码段，但是数据段不共享，可以采取写时复制技术</li></ul></li><li><p>子进程共享了父进程的虚拟内存空间，这样子进程就变成了我们熟悉的线程，<strong>是否共享地址空间几乎是进程和线程之间的本质区别。Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已</strong></p></li><li><p>「内核线程」和「用户态线程」的区别就是内核线程没有相关的内存描述符 mm_struct ，<em><strong>内核线程对应的 task_struct 结构中的 mm 域指向 NULL</strong></em>，所以内核线程之间调度是不涉及地址空间切换的。</p></li><li><p>当一个内核线程被调度时，它会发现自己的虚拟地址空间为 Null，虽然它不会访问用户态的内存，但是它会访问内核内存，聪明的内核会<em>将调度之前的上一个用户态进程的虚拟内存空间 mm_struct 直接赋值给内核线程</em>，因为内核线程不会访问用户空间的内存，它仅仅只会访问内核空间的内存，所以直接复用上一个用户态进程的虚拟地址空间就可以避免为内核线程分配 mm_struct 和相关页表的开销，以及避免内核线程之间调度时地址空间的切换开销。</p></li></ul><h2 id="内核线程-🆚-用户进程-线程的内核态"><a href="#内核线程-🆚-用户进程-线程的内核态" class="headerlink" title="内核线程 🆚 用户进程&#x2F;线程的内核态"></a>内核线程 🆚 用户进程&#x2F;线程的内核态</h2><p>用户进程处于用户态时看到用户空间；陷入内核时要能看到内核空间、同时也能看到内核空间。<br>因此进程的页表中应该含有内核空间映射信息？或者直接使用一个固定的映射信息。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title> Linux - 物理内存管理</title>
    <link href="/2024/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://xiaolincoding.com/os/3_memory/linux_mem2.html#_4-7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-linux-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">xiaolin</a></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux - 虚拟内存管理 - 内核空间</title>
    <link href="/2024/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20-%20%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/"/>
    <url>/2024/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20-%20%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://xiaolincoding.com/os/3_memory/linux_mem.html#_7-1-7-32%E4%BD%8D%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8B-linux-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%95%B4%E4%BD%93%E5%B8%83%E5%B1%80">xiaolin</a></li><li><a href="https://www.cnblogs.com/binlovetech/p/16824522.html">bin的技术小屋</a><ul><li>详细描述了内核虚拟空间每个虚拟内存区域的作用</li></ul></li></ul><h2 id="内核虚拟内存空间"><a href="#内核虚拟内存空间" class="headerlink" title="内核虚拟内存空间"></a>内核虚拟内存空间</h2><ul><li>64 位体系下的内核虚拟内存空间与物理内存的映射就变得非常简单，由于虚拟内存空间足够的大，即便是内核要访问全部的物理内存，直接映射就可以了，不在需要用到《ZONE_HIGHMEM 高端内存》中介绍的高端内存那种「动态映射方式」</li></ul><table><thead><tr><th>32位系统</th><th>64位系统</th></tr></thead><tbody><tr><td>![[2907560-20221025125918837-1995458208.png]]</td><td>![[2907560-20221025130038940-1943626901.png]]</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解cpp全局变量初始化</title>
    <link href="/2024/09/08/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cpp%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2024/09/08/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cpp%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3Mjg2NjU4NA==&mid=2247484664&idx=1&sn=db677b4cfdc597acafd9b7023188975b">深入分析C++全局变量初始化</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux - 虚拟内存管理</title>
    <link href="/2024/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20-%20%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/"/>
    <url>/2024/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20-%20%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.cnblogs.com/binlovetech/p/16824522.html">bin的技术小屋</a></li></ul><h2 id="阅读总结"><a href="#阅读总结" class="headerlink" title="阅读总结"></a>阅读总结</h2><h4 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h4><p>应用程序在用户空间时，只能看到用户空间的虚拟地址：无需关注具体对应的物理内存；其虚拟地址内存空间到物理内存空间的映射由内核管理<br>陷入内核后，程序只能看到内核空间的虚拟地址；由于内核态管理整个物理内存空间，因此处于内核态时一定要能看到整个物理内存空间。内核虚拟空间大小有可能小于实际的物理内存空间大小「32位系统内核空间只有1G，而物理内存空间最大可以到4G」，因此必须要采用动态映射技术使内核态可以访问到所有的物理内存空间。</p><h4 id="区分虚拟内存空间-🆚-物理内存空间"><a href="#区分虚拟内存空间-🆚-物理内存空间" class="headerlink" title="区分虚拟内存空间 🆚 物理内存空间"></a>区分虚拟内存空间 🆚 物理内存空间</h4><ul><li>虚拟空间多大都没事：只要开启了虚拟机制、swap机制</li><li>建立好虚拟内存 -&gt; 物理内存的映射后：只是建立好了页表，并没有分配物理内存空间</li><li>父子进程虚拟内存空间<ul><li>通过<code>vfork/clone</code>系统调用创建出的子进程（线程）共享父进程的虚拟内存空间：即直接将父进程的虚拟内存空间结构体「<code>struct mm_struct</code>」的地址赋值给子进程中的虚拟内存空间结构体指针，并增加父进程虚拟内存空间结构体的引用计数；即子进程不含有「<code>struct mm_struct</code>」的内存</li><li>通过<code>fork</code>系统调用创建出的子进程，则将父进程的虚拟内存空间以及相关页表拷贝到拷贝到子进程的「<code>struct mm_struct</code>」中，即子进程含有自己的「<code>struct mm_struct</code>」结构内存 -&gt; 此时子进程虚拟内存对应的物理内存应该是与父进程相同的！！！❌ -&gt; 共享代码段，但是数据段不共享，可以采取写时复制技术</li></ul></li><li>子进程共享了父进程的虚拟内存空间，这样子进程就变成了我们熟悉的线程，<strong>是否共享地址空间几乎是进程和线程之间的本质区别。Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已</strong></li><li>「内核线程」和「用户态线程」的区别就是内核线程没有相关的内存描述符 mm_struct ，<em><strong>内核线程对应的 task_struct 结构中的 mm 域指向 NULL</strong></em>，所以内核线程之间调度是不涉及地址空间切换的。</li><li>当一个内核线程被调度时，它会发现自己的虚拟地址空间为 Null，虽然它不会访问用户态的内存，但是它会访问内核内存，聪明的内核会<em>将调度之前的上一个用户态进程的虚拟内存空间 mm_struct 直接赋值给内核线程</em>，因为内核线程不会访问用户空间的内存，它仅仅只会访问内核空间的内存，所以直接复用上一个用户态进程的虚拟地址空间就可以避免为内核线程分配 mm_struct 和相关页表的开销，以及避免内核线程之间调度时地址空间的切换开销。</li></ul><blockquote><p>父进程与子进程的区别，进程与线程的区别，以及内核线程与用户态线程的区别其实都是围绕着这个 mm_struct 展开的。</p></blockquote><h2 id="Linux虚拟内存空间布局"><a href="#Linux虚拟内存空间布局" class="headerlink" title="Linux虚拟内存空间布局"></a>Linux虚拟内存空间布局</h2><h3 id="用户空间布局"><a href="#用户空间布局" class="headerlink" title="用户空间布局"></a>用户空间布局</h3><p>用户空间最上方：栈 -&gt; 「待分配区域」| 文件映射区 | 「待分配区域」&lt;- 堆 &lt;-&gt;「 BSS」、「数据段」-&gt; 「不可访问区域（仅限64位系统）」 &lt;-「代码段」、「保留区」。</p><ul><li>malloc : 从堆区分配内存</li><li>mmap : 从文件映射区分配内存</li><li>文件映射区：还会存放动态库中的代码段、数据段、BSS段</li></ul><h3 id="mm-struct与虚拟内存管理"><a href="#mm-struct与虚拟内存管理" class="headerlink" title="mm_struct与虚拟内存管理"></a><code>mm_struct</code>与虚拟内存管理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> task_size;    <span class="hljs-comment">/* size of task vm space */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code, end_code, start_data, end_data;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_brk, brk, start_stack;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg_start, arg_end, env_start, env_end;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_base;  <span class="hljs-comment">/* base of mmap area */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> total_vm;    <span class="hljs-comment">/* Total pages mapped */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> locked_vm;  <span class="hljs-comment">/* Pages that have PG_mlocked set */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pinned_vm;  <span class="hljs-comment">/* Refcount permanently increased */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data_vm;    <span class="hljs-comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> exec_vm;    <span class="hljs-comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_vm;    <span class="hljs-comment">/* VM_STACK */</span><br><br>       ...... 省略 ........<br>&#125;<br></code></pre></td></tr></table></figure><p><code>task_size </code>表示进程用户空间的大小，用来划分用户态虚拟内存空间和内核态虚拟内存空间</p><p>mm_struct 结构体中的 total_vm 表示在进程虚拟内存空间中总共与物理内存映射的页的总数。</p><blockquote><p>注意映射这个概念，它表示只是将<em>虚拟内存与物理内存建立关联关系</em>，「<em><strong>并不代表真正的分配物理内存</strong></em>」</p></blockquote><p>当内存吃紧的时候，有些页可以换出到硬盘上，而有些页因为比较重要，不能换出。<em><strong>locked_vm</strong></em> 就是被「锁定不能换出」的内存页总数，<em><strong>pinned_vm</strong></em> 表示「既不能换出，也不能移动」的内存页总数。</p><p>data_vm 表示数据段中映射的内存页数目，exec_vm 是代码段中存放可执行文件的内存页数目，stack_vm 是栈中所映射的内存页数目，这些变量均是表示进程虚拟内存空间中的「虚拟内存使用情况」。</p><h3 id="vm-area-struct"><a href="#vm-area-struct" class="headerlink" title="vm_area_struct"></a>vm_area_struct</h3><p>一个虚拟内存区域就是一次分配后的结果，其可能包含多个虚拟内存页，例如在上述的堆区进行内存申请。<br>一个虚拟内存区域就对应前述的某个VMA，例如堆、栈、代码区等 ☑️</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_start;<span class="hljs-comment">/* Our start address within vm_mm. */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_end;<span class="hljs-comment">/* The first byte after our end address</span><br><span class="hljs-comment">   within vm_mm. */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Access permissions of this VMA.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pgprot_t</span> vm_page_prot;  <span class="hljs-comment">// 决定页表中内存页访问权限</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_flags;<span class="hljs-comment">// 整个虚拟内存区域的访问权限及行为规范：读/写/执行等</span><br><span class="hljs-comment">// 这块虚拟内存区域映射的物理内存是否可以多进程共享</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anon_vma</span> *<span class="hljs-title">anon_vma</span>;</span><span class="hljs-comment">/* Serialized by page_table_lock */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">vm_file</span>;</span><span class="hljs-comment">/* File we map to (can be NULL). */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_pgoff;<span class="hljs-comment">/* Offset (within vm_file) in PAGE_SIZE</span><br><span class="hljs-comment">   units */</span><br><span class="hljs-type">void</span> * vm_private_data;<span class="hljs-comment">/* was vm_pte (shared mem) */</span><br><span class="hljs-comment">/* Function pointers to deal with this struct. */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_operations_struct</span> *<span class="hljs-title">vm_ops</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个 vm_area_struct 结构对应于虚拟内存空间中的唯一虚拟内存区域 VMA，vm_start 指向了这块虚拟内存区域的起始地址（最低地址），vm_start 本身包含在这块虚拟内存区域内。vm_end 指向了这块虚拟内存区域的结束地址（最高地址），而 vm_end 本身包含在这块虚拟内存区域之外，所以 vm_area_struct 结构描述的是<code> [vm_start，vm_end)</code> 这样一段左闭右开的虚拟内存区域，每个区域是连续的，且可以包含很多虚拟内存页。</p><p>通过这一系列的介绍，我们可以看到<code> vm_flags</code> 就是定义整个虚拟内存区域的访问权限以及行为规范，而内存区域中内存的最小单位为页（4K），虚拟内存区域中包含了很多这样的虚拟页，对于虚拟内存区域 VMA 设置的访问权限也会全部复制到区域中包含的内存页中</p><p>接下来的三个属性 anon_vma，vm_file，vm_pgoff 分别和虚拟内存映射相关，虚拟内存区域可以映射到物理内存上，也可以映射到文件中，映射到物理内存上我们称之为匿名映射，映射到文件中我们称之为文件映射。</p><h4 id="vm-ops"><a href="#vm-ops" class="headerlink" title="vm_ops"></a>vm_ops</h4><p>struct vm_area_struct 结构中还有一个 vm_ops 用来指向针对虚拟内存区域 VMA 的相关操作的函数指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_operations_struct</span> &#123;</span><br><span class="hljs-type">void</span> (*open)(<span class="hljs-keyword">struct</span> vm_area_struct * area);<br><span class="hljs-type">void</span> (*close)(<span class="hljs-keyword">struct</span> vm_area_struct * area);<br>    <span class="hljs-type">vm_fault_t</span> (*fault)(<span class="hljs-keyword">struct</span> vm_fault *vmf);<br>    <span class="hljs-type">vm_fault_t</span> (*page_mkwrite)(<span class="hljs-keyword">struct</span> vm_fault *vmf);<br><br>    ..... 省略 .......<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当指定的虚拟内存区域被加入到进程虚拟内存空间中时，open 函数会被调用</li><li>当虚拟内存区域 VMA 从进程虚拟内存空间中被删除时，close 函数会被调用</li><li>当进程访问虚拟内存时，访问的页面不在物理内存中，可能是未分配物理内存也可能是被置换到磁盘中，这时就会产生缺页异常，fault 函数就会被调用。</li><li>当一个只读的页面将要变为可写时，page_mkwrite 函数会被调用。</li></ul><h3 id="内核如何组织虚拟内存区域"><a href="#内核如何组织虚拟内存区域" class="headerlink" title="内核如何组织虚拟内存区域"></a>内核如何组织虚拟内存区域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> &#123;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vm_next</span>, *<span class="hljs-title">vm_prev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">vm_rb</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">anon_vma_chain</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">vm_mm</span>;</span><span class="hljs-comment">/* The address space we belong to. */</span><br><br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，是通过双向链表来组织管理所有<code>vm_area_struct</code>的。双向链表的头指针存储在内存描述符 struct mm_struct 结构中的 mmap 中，正是这个 mmap 串联起了整个虚拟内存空间中的虚拟内存区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br>...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">mmap</span>;</span><span class="hljs-comment">/* list of VMAs */</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>内核中关于这些虚拟内存区域的操作除了遍历之外还有许多需要根据特定虚拟内存地址在虚拟内存空间中查找特定的虚拟内存区域。</p><p>尤其在进程虚拟内存空间中包含的内存区域 VMA 比较多的情况下，使用红黑树查找特定虚拟内存区域的时间复杂度是 O( logN ) ，可以显著减少查找所需的时间。</p><p>所以在内核中，<em><strong>同样的内存区域 vm_area_struct 会有两种组织形式</strong></em>，一种是「双向链表」用于高效的遍历，另一种就是「红黑树」用于高效的查找。</p><h3 id="load-elf-binary"><a href="#load-elf-binary" class="headerlink" title="load_elf_binary"></a>load_elf_binary</h3><p>内核中完成这个映射过程的函数是 load_elf_binary ，这个函数的作用很大，加载内核的是它，启动第一个用户态进程 init 的是它，fork 完了以后，调用 exec 运行一个二进制程序的也是它。当 exec 运行一个二进制程序的时候，除了解析 ELF 的格式之外，另外一个重要的事情就是建立上述提到的内存映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">load_elf_binary</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> linux_binprm *bprm)</span><br>&#123;<br>      ...... 省略 ........<br>  <span class="hljs-comment">// 设置虚拟内存空间中的内存映射区域起始地址 mmap_base</span><br>  setup_new_exec(bprm);<br><br>     ...... 省略 ........<br>  <span class="hljs-comment">// 创建并初始化栈对应的 vm_area_struct 结构。</span><br>  <span class="hljs-comment">// 设置 mm-&gt;start_stack 就是栈的起始地址也就是栈底，并将 mm-&gt;arg_start 是指向栈底的。</span><br>  retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),<br>         executable_stack);<br><br>     ...... 省略 ........<br>  <span class="hljs-comment">// 将二进制文件中的代码部分映射到虚拟内存空间中</span><br>  error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,<br>        elf_prot, elf_flags, total_size);<br><br>     ...... 省略 ........<br> <span class="hljs-comment">// 创建并初始化堆对应的的 vm_area_struct 结构</span><br> <span class="hljs-comment">// 设置 current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，设置堆的起始地址 start_brk，结束地址 brk。 起初两者相等表示堆是空的</span><br>  retval = set_brk(elf_bss, elf_brk, bss_prot);<br><br>     ...... 省略 ........<br>  <span class="hljs-comment">// 将进程依赖的动态链接库 .so 文件映射到虚拟内存空间中的内存映射区域</span><br>  elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,<br>              interpreter,<br>              &amp;interp_map_addr,<br>              load_bias, interp_elf_phdata);<br><br>     ...... 省略 ........<br>  <span class="hljs-comment">// 初始化内存描述符 mm_struct</span><br>  current-&gt;mm-&gt;end_code = end_code;<br>  current-&gt;mm-&gt;start_code = start_code;<br>  current-&gt;mm-&gt;start_data = start_data;<br>  current-&gt;mm-&gt;end_data = end_data;<br>  current-&gt;mm-&gt;start_stack = bprm-&gt;p;<br><br>     ...... 省略 ........<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存页类型🐟页面回收</title>
    <link href="/2024/09/08/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%86%85%E5%AD%98%E9%A1%B5%E7%B1%BB%E5%9E%8B%F0%9F%90%9F%E9%A1%B5%E9%9D%A2%E5%9B%9E%E6%94%B6/"/>
    <url>/2024/09/08/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%86%85%E5%AD%98%E9%A1%B5%E7%B1%BB%E5%9E%8B%F0%9F%90%9F%E9%A1%B5%E9%9D%A2%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="">xiaolin</a></li></ul><h2 id="不同页类型"><a href="#不同页类型" class="headerlink" title="不同页类型"></a>不同页类型</h2><h3 id="文件页"><a href="#文件页" class="headerlink" title="文件页"></a>文件页</h3><p>内核缓存的磁盘数据、缓存的文件数据都叫做文件页。回收干净页时直接释放即可；回收脏页时要先讲修改内容写回磁盘对应的文件&#x2F;数据块，接着才能释放内存</p><h3 id="匿名页"><a href="#匿名页" class="headerlink" title="匿名页"></a>匿名页</h3><p>这部分内存没有实际载体，比如堆、栈数据。这部分内存后续可能还要再次访问，所以不能直接释放内存，它们的回收是通过Linux的SWAP机制。</p><h2 id="LRU（Least-recently-used）算法"><a href="#LRU（Least-recently-used）算法" class="headerlink" title="LRU（Least recently used）算法"></a>LRU（Least recently used）算法</h2><p>优先回收不常使用访问的内存，其维护了两个双向链表</p><ul><li><code>active list</code>: 存放最近被访问过「活跃」的内存页；在内存页被访问第二次的时候，才将其从非活跃链表加载到活跃链表，以解决「缓存污染」导致的页面缓存命中率🎯下降的问题</li><li><code>inactive list</code>: 存放很少被访问「非活跃」的内存页；读取磁盘数据时，将<em><strong>预读页</strong></em>加到这个链表，以解决「预读失效」造成的页面缓存命中率🎯下降的问题</li></ul><p>传统的LRU算法只有一个链表，最近使用的页链表节点在链表的头部</p><h2 id="内存回收两种方式"><a href="#内存回收两种方式" class="headerlink" title="内存回收两种方式"></a>内存回收两种方式</h2><ul><li>注意这里的内存是<em><strong>指物理内存</strong></em>了</li><li>干净文件页的回收是效率最高的，因此一般设置此种倾向较高</li><li>尽早触发<code>kswapd</code>进行异步的内存回收；避免进程频繁的直接内存回收</li><li>两种方式的触发是根据系统「剩余空闲内存数值」及「预设指标」的大小关系进行的</li></ul><h3 id="后台回收"><a href="#后台回收" class="headerlink" title="后台回收"></a>后台回收</h3><p>唤醒内核线程<code>kswapd</code>进行异步内存回收</p><h3 id="直接回收"><a href="#直接回收" class="headerlink" title="直接回收"></a>直接回收</h3><p>当前进程直接进行内存回收：同步</p><h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><p>如果前两种方式后，剩余内存还是不足，那么系统会根据某种算法，选择占用「占用物理内存」最高的进程，把它杀掉，并释放对应的内存</p><h3 id="如何保护一个进程不被OOM机制杀掉？"><a href="#如何保护一个进程不被OOM机制杀掉？" class="headerlink" title="如何保护一个进程不被OOM机制杀掉？"></a>如何保护一个进程不被OOM机制杀掉？</h3><p>OOM会扫描系统中可杀掉进程，并「进行打分」，得分高的进程被优先杀掉。分数计算取决于</p><ul><li>进程已经使用的物理内存页面数</li><li>每个进程的OOM校准值：<code>oom_score_adj - [-1000, 1000]</code>，每个进程默认值为0</li><li><code>score = already_used + oom_socre_adj * total_pages / 1000</code><br>因此可以通过调整每个进程的OOM校准值，降低其被杀掉的概率。</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存分段 🆚 内存分页</title>
    <link href="/2024/09/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%20%F0%9F%86%9A%20%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5/"/>
    <url>/2024/09/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%20%F0%9F%86%9A%20%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://xiaolincoding.com/os/3_memory/vmem.html#linux-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">小林-内存布局</a></li></ul><h2 id="内存碎片🧩"><a href="#内存碎片🧩" class="headerlink" title="内存碎片🧩"></a>内存碎片🧩</h2><h4 id="内部内存碎片"><a href="#内部内存碎片" class="headerlink" title="内部内存碎片"></a>内部内存碎片</h4><h4 id="外部内存碎片"><a href="#外部内存碎片" class="headerlink" title="外部内存碎片"></a>外部内存碎片</h4><p>解决的办法就是<em><strong>内存交换</strong></em>：即把某个程序占用的内存先写到硬盘中，接着释放其占用的内存空间；之后再把信息读回到内存中。不过再读回时占用的内存和之前占用的内存不一样，而是紧邻之前分配过的内存，以期减少外部内存碎片。<br><em><strong>内存交换空间</strong></em>，从硬盘划分出来，用于内存与硬盘的交换，对应Linux中的Swap分区</p><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><p>按需分配内存，因此不会有内部碎片；但是每个程序需要使用的每个段大小不一样，所以多个段未必能恰好使用所有的内存空间；因此会产生很多不连续的小内存，<em>产生外部碎片</em>问题。</p><p>此外，内存分段使得发生内存交换时，<em>需要交换一块很大的区域</em>，因此导致内存交换的效率很低</p><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p>分段的好处是能产生连续的物理内存空间，但是会出现「外部内存碎片和内存交换时数据太大」的问题。<br>「分页」：<em><strong>把物理内存和虚拟内存切成一块块固定大小的尺寸</strong></em>，页</p><p>内存分页机制分配内存的最小单位是页，因此不会出现外部内存碎片。但是即使程序使用内存不足一页，也要为其分配一个页的内存，因此内部会有部分空间浪费，因此内存<em><strong>分页机制会出现内部碎片</strong></em>。</p><p>如果内存不够，OS会把其它进程中「最近未被使用」的内存页上的信息写到磁盘中，并释放对应的内存空间，这叫做<em><strong>换出</strong></em>；当这部分信息需要的时候，再把它加载到内存中，这被称为<em><strong>换入</strong></em>。所以一次性换入&#x2F;出的也只有少数的几个页，因此内存交换的效率较高。</p><p>进一步的，程序可以使用延迟加载的机制；在需要的时候再把数据加载到物理内存中。</p><p>使用多级页表进一步降低存储页表需要的内存空间。对于二级页表来说，占用4KB的1024个一级页表项就可以覆盖4G的物理内存空间；且一个程序使用到的物理内存远小于4G，因此有很多的二级不需要建立 &#x3D;&gt; 空间局部性原理</p><h2 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h2><h2 id="X86的内存分页机制"><a href="#X86的内存分页机制" class="headerlink" title="X86的内存分页机制"></a>X86的内存分页机制</h2><p>分页运行在分段基础上：先由分段管理机制将程序的「逻辑地址」转换为「线性地址」（虚拟地址），再由页式管理单元将「线性地址」转换为「物理地址」。</p><p>为了屏蔽x86的这一硬件要求，运行在x86上的Linux中的每个段都是从0开始的整个4GB地址空间，因此OS代码、应用程序代码看到的都是<em><strong>线性地址</strong></em></p><h2 id="程序虚拟内存布局"><a href="#程序虚拟内存布局" class="headerlink" title="程序虚拟内存布局"></a>程序虚拟内存布局</h2><p>每个程序都有自己的页表</p><h4 id="用户空间布局"><a href="#用户空间布局" class="headerlink" title="用户空间布局"></a>用户空间布局</h4><p>用户空间最上方：栈 -&gt; 「待分配区域」| 文件映射区 | 「待分配区域」&lt;- 堆 &lt;-&gt;「 BSS」、「数据段」、「代码段」、「保留区」。</p><ul><li>malloc : 从堆区分配内存</li><li>mmap : 从文件映射区分配内存</li><li>文件映射区：还会存放动态库中的代码段、数据段、BSS段</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>aarch64-页目录表基地址寄存器</title>
    <link href="/2024/09/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/aarch64-%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2024/09/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/aarch64-%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>每个异常等级【EL1，EL2，EL3】都有自己的页目录表基地址寄存器：<br><code>EL0/EL1</code>：有两个寄存器TTBR0，TTBR1；其中当虚拟地址的前几位都是0时，TTBR0所指向的映射表被选中（对应Linux系统的用户空间）；当VA的前几位都是1时，TTBR1指向的映射表被选中（对应Linux系统的内核空间）<br><code>EL2</code>：只有一个TTBR0，只能使用范围：0x0 ~ 0x0000ffff_ffffffff<br><code>EL3</code>：只有一个TTBR0，一样</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式-架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title> Linux - 信号</title>
    <link href="/2024/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E4%BF%A1%E5%8F%B7/"/>
    <url>/2024/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E4%BF%A1%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.gnu.org/software/libc/manual/html_node/Standard-Signals.html">24.2 Standard Signals</a></li><li><a href="https://wushifublog.com/2020/05/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94signals/">深入理解Linux内核-信号</a><ul><li>进入用户空间执行用户自定义的信号处理函数时，会创建一个临时的用户空间栈</li></ul></li></ul><h2 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h2><p><code>SIGKILL</code>：不可被捕获、忽略，取值为9<br><code>SIGINT</code>：可以被捕获、忽略、阻塞，取值为2，由<code>ctrl+c</code>产生<br><code>SIGTERM</code>：可以被捕获、忽略、阻塞，<code>kill</code>命令默认发这个信号<br><code>SIGQUIT</code>)：类似SIGINT，由<code>ctrl+\</code>产生<br><code>SIGSTOP</code>：不可被忽略、捕获，停止程序<br><code>SIGSTP</code>：可以被捕获、忽略、阻塞，由<code>ctrl+z</code>产生<br><code>SIGCONT</code>：恢复进程的执行，不能被捕获或忽略</p><h2 id="同步-异步信号"><a href="#同步-异步信号" class="headerlink" title="同步&#x2F;异步信号"></a>同步&#x2F;异步信号</h2><p>同步信号的例子包括非法存储器访问以及除法除以0.如果一个正在运行的程序执行了任一操作，一个信号就会生成。</p><p><em>同步信号传递到执行操作而导致产生信号的同一进程</em>（这就是被认为是同步的原因）</p><p>当一个信号由运行的进程之外的事件产生，那么进程就会异步的接收这个信号。这样的例子包括用特定的击键结束进程（比如ctrl + c）或者是定时器到期。通常，信号被发送到另一个进程</p><h2 id="信号的响应"><a href="#信号的响应" class="headerlink" title="信号的响应"></a>信号的响应</h2><p>在进程由内核态返回用户态时，会在在内核态检查当前是否有信号待处理，如果有的话，就会进入信号响应流程</p><h2 id="多线程环境下信号传递"><a href="#多线程环境下信号传递" class="headerlink" title="多线程环境下信号传递"></a>多线程环境下信号传递</h2><p>单线程程序的信号处理比较直接，信号总是发给进程。<br>不过，对于多线程程序，发送信号比较复杂，因为进程可能有多个线程，应该将信号发给谁呢？？<br>一般来说，存在以下选项:</p><blockquote><ol><li>将信号发送到信号所应用的线程。</li><li>将信号传递到进程中的每个线程。</li><li>将信号传递给进程中的某些线程。</li><li>指定一个特定的线程来接收该进程的所有信号。</li></ol></blockquote><p>传递信号的方法取决于所产生的信号的类型。例如，<em><strong>需要将同步信号传递给引起信号的线程</strong></em>，而不需要传递给进程中的其他线程。然而，对于异步信号，情况就不那么清楚。一些异步信号——例如终止进程的信号(例如ctrl + c)——应该发送到所有线程。</p><p><em>发送信号</em>的标准UNIX函数是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">kill(pid t pid, <span class="hljs-type">int</span> signal)<br></code></pre></td></tr></table></figure><p>该函数指定哪个特定的信号（即signal参数）被发送到指定的进程上（即pid参数）。大多数多线程版本的UNIX允许一个线程指定它将接受哪个信号，它将会阻止哪个信号。<em>因此，在某些情况下，异步信号只能传递给那些没有阻止它的线程</em>。但是，因为<em><strong>信号只需要处理一次，所以信号通常只发送到发现的第一个不阻止它的线程上</strong></em><code>[但是不可捕获、忽略的信号会被发送给每一个线程并执行]</code>。POSIX Pthreads提供了以下功能，它允许将信号传递到指定的线程(tid):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pthread_kill(pthread t tid, <span class="hljs-type">int</span> signal)<br></code></pre></td></tr></table></figure><h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><p>线程的信号屏蔽字是per_thread的，因此通过信号屏蔽关键字，只有一个线程没有屏蔽该信号，其它线程均屏蔽该信号。达到控制某个线程处理某个信号的目的。<br>但是对于那些不能被屏蔽的信号怎么办？</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title> Linux - 线程资源&amp;模型</title>
    <link href="/2024/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90&amp;%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90&amp;%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://originlee.com/2015/04/08/influence-of-main-threads-exiting-to-child-thread/">主线程退出对子线程的影响</a></li></ul><h2 id="线程资源"><a href="#线程资源" class="headerlink" title="线程资源"></a>线程资源</h2><p>同一进程中的多个线程使用同一份进程地址空间，因此它们的大部分资源是共享的，我们只需要记住一些不被共享的资源即可：</p><ul><li>线程ID  </li><li>一组寄存器  </li><li>栈  </li><li>errno(错误码)  </li><li>信号屏蔽字(block)  </li><li>调度优先级</li></ul><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>实际上，posix线程和一般的进程不同，在概念上没有主线程和子线程之分（虽然在实际实现上还是有一些区分），如果仔细观察apue或者unp等书会发现基本看不到「主线程」或者「子线程」等词语，在csapp中甚至都是用「对等线程」一词来描述线程间的关系。</p><p>在Linux 2.6以后的posix线程都是由用户态的pthread库来实现的。在使用pthread库以后，在用户视角看来，每一个tast_struct就对应一个线程（tast_struct原本是内核对应一个进程的结构），而一组线程以及他们所共同引用的一组资源就是进程。从Linux 2.6开始，内核有了线程组的概念，<em><strong>tast_struct结构中增加了一个<code>tgid</code>（thread group id）字段</strong></em>。<code>getpid</code>（获取进程号）通过系统调用「返回的也是tast_struct中的<code>tgid</code>」，所以<code>tgid</code>其实就是进程号。而<em><strong>tast_struct中的线程号pid字段</strong></em>则由系统调用<code>syscall(SYS_gettid)</code>来获取。</p><p>当线程收到一个kill致命信号时，内核会将处理动作施加到整个线程组上。为了应付「发送给进程的信号」和「发送给线程的信号」，tast_struct里面<em>维护了两套signal_pending</em>，一套是线程组共用的，一套是线程独有的。通过<em><strong>kill发送的信号被放在线程组共享的signal_pending中</strong></em>，可以<em>任意由一个线程来处理</em>。而通过<em><strong>pthread_kill发送的信号被放在线程独有的signal_pending中</strong></em>，只能由本线程来处理。</p><p>关于线程与信号，apue有这么几句：</p><blockquote><p>每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的。这意味着尽管单个线程可以阻止某些信号，但当线程修改了与某个信号相关的处理行为以后，所有的线程都必须共享这个处理行为的改变。这样如果一个线程选择忽略某个信号，而其他的线程可以恢复信号的默认处理行为，或者是为信号设置一个新的处理程序，从而可以撤销上述线程的信号选择。</p><p><strong>如果信号的「默认处理动作」是终止该进程，那么<em>把信号传递给某个线程仍然会杀掉整个进程</em>。</strong></p></blockquote><p>例如一个程序a.out创建了一个子线程，假设主线程的线程号为9601，子线程的线程号为9602（它们的tgid都是9601），因为默认没有设置信号处理程序，所以如果运行命令kill 9602的话，是可以把9601和9602这个两个线程一起杀死的。如果不知道Linux线程背后的故事，可能就会觉得遇到灵异事件了。</p><p>因为SIGKILL无法被忽略、捕获且不可改变其默认行为：杀死进程；因此最终无论哪个线程响应了该信号：都会导致进程被杀死。实际上对于这种无法自定义用户处理函数的信号，内核应该直接在内核态直接完成处理了？-&gt; 得再看一下👀</p><p>另外<em>系统调用syscall(SYS_gettid)获取的线程号与pthread_self获取的线程号是不同的</em>，pthread_self获取的线程号仅仅在线程所依赖的进程内部唯一，在<a href="http://linux.die.net/man/3/pthread_self">pthread_self</a>的man page中有这样一段话：</p><blockquote><p>Thread IDs are guaranteed to be unique only within a process. A thread ID may be reused after a terminated thread has been joined, or a detached thread has terminated.</p></blockquote><p>所以在内核中唯一标识线程ID的线程号只能通过系统调用syscall(SYS_gettid)获取。</p><h2 id="主线程退出对其余线程的影响"><a href="#主线程退出对其余线程的影响" class="headerlink" title="主线程退出对其余线程的影响"></a>主线程退出对其余线程的影响</h2><h3 id="主线程先退出"><a href="#主线程先退出" class="headerlink" title="主线程先退出"></a>主线程先退出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">pthread_t</span> main_tid = *<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">pthread_t</span>*&gt;(arg);<br><span class="hljs-built_in">pthread_cancel</span>(main_tid);<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child loops\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">pthread_t</span> main_tid = <span class="hljs-built_in">pthread_self</span>();<br><span class="hljs-type">pthread_t</span> tid = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">NULL</span>, func, &amp;main_tid);<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main loops\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main exit\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把主线程的线程号传给子线程，在子线程中通过<code>pthread_cancel</code>终止主线程使其退出。运行程序，可以发现在打印了一定数量的「main loops」之后程序就挂起了，但却没有退出。</p><p>主线程因为被子线程终止了，所有没有看到「main exit」的打印。子线程终止了主线程后进入了死循环while中，所以程序看起来像挂起了。如果我们让子进程while循环中的打印语句生效再运行就可以发现程序会一直打印「child loops」字样。</p><p>主线程被子线程终止了，<em><strong>但他们所「依赖的进程」并没有退出</strong></em>，所以子线程依然正常运转。</p><p>如果主线程使用<code>pthread_exit</code>主的退出，也不会导致「依赖的进程」退出，因此其余线程仍然处于运行状态</p><h3 id="主线程随进程一起退出"><a href="#主线程随进程一起退出" class="headerlink" title="主线程随进程一起退出"></a>主线程随进程一起退出</h3><p>之前看到一些人说如果主线程先退出了，子线程也会跟着退出，其实他们混淆了线程退出和进程退出的概念。下面这个例子代表了他们的观点: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br><span class="hljs-type">pthread_t</span> main_tid = *static_cast&lt;<span class="hljs-type">pthread_t</span>*&gt;(arg);<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child loops\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br><span class="hljs-type">pthread_t</span> main_tid = pthread_self();<br><span class="hljs-type">pthread_t</span> tid = <span class="hljs-number">0</span>;<br>pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, func, &amp;main_tid);<br><span class="hljs-comment">// while (true)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main loops\n&quot;</span>);<br>&#125;<br>sleep(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main exit\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码，会发现程序在打印一定数量的「child loops」和一句「main exit」之后退出，并且在退出之前的最后一句打印是「main exit」。</p><p>按照他们的逻辑，你看，因为主线程在打印完「main exit」后退出了，然后子线程也跟着退出了，所以随后就没有子线程的打印了。</p><p><em><strong>但其实这里是混淆了「进程退出」和「线程退出」的概念</strong></em>了。实际的情况是<em>主线程中的main函数执行完ruturn后弹栈</em>，<em><strong>然后调用glibc库函数「exit」，exit进行相关清理工作后调用_exit系统调用退出该进程</strong></em>。所以，这种情况<em>实际上是因为进程运行完毕退出导致所有的线程也都跟着退出了</em>，并非是因为主线程的退出导致子线程也退出。</p><h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit()"></a>pthread_exit()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Decrease the number of threads. We use an atomic operation to</span><br><span class="hljs-comment">make sure that only the last thread calls `exit&#x27;. */</span><br><span class="hljs-keyword">if</span> (atomic_fetch_add_relaxed (&amp;__pthread_total, <span class="hljs-number">-1</span>) == <span class="hljs-number">1</span>)<br><span class="hljs-comment">/* We are the last thread. */</span><br><span class="hljs-built_in">exit</span> (<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程分离</title>
    <link href="/2024/09/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB/"/>
    <url>/2024/09/07/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title> Linux - 文件系统</title>
    <link href="/2024/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/09/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://gnu-linux.readthedocs.io/zh/latest/Chapter03/00_link.html#id2">硬链接和软链接</a></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="四个关键概念"><a href="#四个关键概念" class="headerlink" title="四个关键概念"></a>四个关键概念</h3><ol><li><strong>文件描述符（File Descriptor）</strong>:<ul><li>文件描述符是一个非负整数，用于在程序中引用打开的文件、套接字或其他I&#x2F;O资源。</li><li>每当一个进程打开一个文件、创建一个套接字或进行其他类似的操作时，内核都会为该进程分配一个新的文件描述符。</li><li>文件描述符是进程级的，不同的进程可以有各自的文件描述符表，互不影响。</li></ul></li><li><strong>文件描述符表（File Descriptor Table）</strong>:<ul><li>每个进程都有一个文件描述符表，它是一个数组结构，数组的每个元素都指向一个文件表项。</li><li>文件描述符作为数组的索引，使得进程能够快速找到对应的文件表项。</li></ul></li><li><strong>文件表项（File Table Entry）</strong>:<ul><li>文件表项包含了关于打开文件的信息，比如文件状态标志（如只读、只写、追加等）、当前文件偏移量（即下一次读写操作的位置）等。</li><li>文件表项还包含一个指向inode的指针，这个指针用于定位文件在文件系统中的实际位置。</li><li><em><strong>同一个文件可以被多个进程打开，但每个进程都有自己的文件表项，这样可以保证每个进程对文件的操作（如偏移量）互不影响</strong></em>。</li><li>只要有打开某个文件的操作，就会生成一个文件表现</li></ul></li><li><strong>inode（索引节点）</strong>:<ul><li>inode是文件系统的核心概念之一，它包含了关于文件本身的信息，如文件大小、时间戳（创建时间、修改时间、访问时间等）、文件类型（普通文件、目录、符号链接等）等。</li><li>inode还包含了磁盘上文件数据的位置信息，比如数据块的位置。</li><li>对于不同的文件系统，inode的结构可能会有所不同，但基本原理是相似的。</li></ul></li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>一个进程中不同文件描述符可以指向同一个文件表项：通过<code>DUP</code>进行</li><li>不同进程中的不同文件描述符也可以指向同一个文件表现：通过<code>fork+dup</code>进行，fork时子进程会继承父进程的文件描述符表</li><li>不同的打开文件表现可以指向同一个inode节点：对同一个文件打开多次</li></ul><h3 id="软链接-VS-硬链接"><a href="#软链接-VS-硬链接" class="headerlink" title="软链接 VS 硬链接"></a>软链接 VS 硬链接</h3><ul><li>软连接会产生inode节点，删除软链接对源文件没有影响</li><li>硬链接指向同一个inode，每增加一个硬链接会增加节点链接数；只要节点的链接数不为0，文件就一直存在</li></ul><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a><a href="https://gnu-linux.readthedocs.io/zh/latest/Chapter03/00_link.html#id2" title="永久链接至标题">硬链接</a></h4><p>一般情况下，<em>文件名</em>和 inode 号码是”一一对应”的关系，每个 inode 号码对应一个文件名（<em>每个文件默认有一个硬链接</em>）。但是，<em><strong>Unix&#x2F;Linux 系统允许多个文件名指向同一个 inode 号码</strong></em>。</p><p>这意味着，可以用不同的文件名访问同样的内容，对文件内容进行修改后，会影响所有文件名。但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p><p><em><strong>创建一个硬链接，就会为文件创建了一个新的文件名</strong></em>。硬链接有两个重要局限性：</p><ol><li>硬链接不能链接不在同一系统的文件。也就是说硬链接不能链接与文件不在同一磁盘分区上的文件；</li><li>硬链接不能链接目录。</li></ol><p>一个硬链接和文件本身没有什么区别。当你列出一个包含硬链接的文件时，不会有特殊的链接指示说明。当一个硬链接被删除时，文件本身的内容仍然存在（也就是说，它所占的磁盘空间不会被重新分配），直到所有关联这个文件的硬链接都删掉。</p><blockquote><p>&#x3D;&#x3D;目录文件的硬链接&#x3D;&#x3D;:<br>创建目录时，默认会生成两个目录项： <code>.</code> 和 <code>..</code> 。 <code>.</code> 相当于当前目录的硬链接； <code>..</code> 相当于父目录的硬链接。所以，目录的硬链接总数，等于 2 加上它的子目录总数（含隐藏目录）。其实使用 <code>ln -d</code> 命令也允许 root 用户尝试建立目录硬链接。<br>这些都说明系统限制对目录进行硬链接只是一个硬性规定，并不是逻辑上不允许或技术上不可行。<br>&#x3D;&#x3D;为什么操作系统要进行这个限制呢&#x3D;&#x3D;？<br>由于 Linux 操作系统中的目录是以 <code>/</code> 为节点的树状结构，对目录的硬链接有可能破坏这种结构，甚至形成循环如： <code>/usr/bin -&gt; /usr/</code> ，在使用遍历目录的命令时（如： <code>ls -R</code> ）系统就会陷入无限循环中。软链接的 inode 号码不一样，所以不会出现这种问题。</p></blockquote><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>除了硬链接以外，还有一种软链接，创建软链接是为了克服硬链接的局限性。</p><p>软链接是通过创建一个特殊类型的文件（指针）链接到文件或目录。就像是 Windows 的快捷方式，当然，符号链接早于 Windows 的快捷方式很多年。</p><p>文件 A 和文件 B 的 <em>inode 号码虽然不一样</em>，但是<em><strong>文件 A 的内容是文件 B 的路径</strong></em>。读取文件 A 时，系统会自动将访问指向文件 B。因此，无论打开哪一个文件，最终读取的都是文件 B。但是，文件 A 依赖于文件 B 而存在，如果删除了文件 B，打开文件 A 就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：<em><strong>文件 A 指向文件 B的文件名，而不是文件 B 的 inode 号码</strong></em>。</p><blockquote><p>&#x3D;&#x3D;软链接的应用&#x3D;&#x3D;<br>想象这样一个情景，一个程序需要使用 foo_1.1 文件中的共享资源，由于 foo 经常改变版本号。每次升级后都得将使用 foo_1.1 的所有程序更新到 foo_1.2 文件，那么每次更新 foo 版本后，都要重复上边的工作。<br>符号链接能很好的解决这个问题。比如，创建一个 foo 的软链接指向 foo_1.2。这时，当一个程序访问 foo 时，实际上是访问 foo_1.2。当升级到 foo_1.3 时，只需要更新软链接指向。这不仅解决了版本升级问题，而且还允许在系统中保存两个不同的版本，如果 foo_1.3 有错误，再更新回原来的 foo_1.2 链接就可以。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存模型与内存屏障</title>
    <link href="/2024/09/06/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <url>/2024/09/06/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/Qi3XSCCgZplm8yY5uDfvAw">深度Linux</a></li><li></li></ul><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>现代处理器基本上都是支持多发射的，也就是在一个指令周期内可以同时执行多条指令。但是，处理器的资源就那么多，可能不能同时满足处理这些指令的要求。比如，处理器就只有一个加法器，如果同时有两条指令都需要算加法，那么有一条指令必须等待。如果这时候再下一条指令是读取指令，并且和前两条指令无关，那么这条指令将在前面某条加法指令之前完成。还有一种可能，就是前后指令之间具有相关性，比如对同一个地址先读取再写入，后面的写入操作必须等待前面的读取操作完成后才能执行。但是如果这时候第三条指令是写入一个无关的地址，那它可以在前面的写入操作之前被执行，执行顺序再次被打乱了。</p><p>所以，<em><strong>一般情况下指令乱序并不是CPU在执行指令之前刻意去调整顺序</strong></em>。<em>CPU总是顺序的去内存里面取指令，然后将其顺序的放入指令流水线</em>。<em><strong>但是指令执行时的各种条件，指令与指令之间的相互影响，可能导致顺序放入流水线的指令，最终不是按照放入的顺序执行完成</strong></em>，在外边看起来仿佛是“乱序”一样，这就是所谓的“顺序流入，乱序流出”。</p><h3 id="完全存储定序模型"><a href="#完全存储定序模型" class="headerlink" title="完全存储定序模型"></a>完全存储定序模型</h3><p>这种内存一致性模型允许对StoreLoad指令组合进行重排序，如果第一条指令是写入，第二条指令是读取，那么有可能在程序看来，读取指令先于写入指令执行。但是，对于其它另外三种指令组合还是可以保证按照顺序执行。<br>这种模型就相当于前面提到的，在CPU和缓存中间<em><strong>加入了存储缓冲（store buffer）</strong></em>，而且这个缓冲还是一个<em>满足先入先出（FIFO）的队列</em>。先入先出队列就保证了对StoreStore这种指令组合也能保证按照顺序被感知。<em><strong>X86架构就是使用的这种内存一致性模型</strong></em>。</p><h3 id="部分存储定序模型"><a href="#部分存储定序模型" class="headerlink" title="部分存储定序模型"></a>部分存储定序模型</h3><p>这种内存一致性模型除了允许对StoreLoad指令组合进行重排序外，还允许对StoreStore指令组合进行重排序。但是，对于其它另外两种指令组合还是可以保证按照顺序执行。<br>这种模型就相当于也在CPU和缓存中间加入了存储缓冲，但是这个缓冲不是先入先出的。</p><h3 id="宽松存储模型"><a href="#宽松存储模型" class="headerlink" title="宽松存储模型"></a>宽松存储模型</h3><p>这种内存一致性模型允许对上面说的四种指令组合都进行重排序。<br>这种模型就相当于前面说的，既有存储缓冲，又有无效队列的情况。</p><h2 id="内存屏障的使用规则"><a href="#内存屏障的使用规则" class="headerlink" title="内存屏障的使用规则"></a>内存屏障的使用规则</h2><p>前面提到过了，读、写内存屏障应该配对使用，或者换做通用内存屏障也需要成对的使用，否则起不到想要的效果。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式-架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>std - bind</title>
    <link href="/2024/09/05/CPP/bind/"/>
    <url>/2024/09/05/CPP/bind/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>lambda - 函数闭包 🆚 函数对象</title>
    <link href="/2024/09/05/CPP/lambda%20-%20%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%20%F0%9F%86%9A%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/09/05/CPP/lambda%20-%20%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%20%F0%9F%86%9A%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>lambda的一种方式，其就是实现函数对象的&#x3D;&#x3D;语法糖&#x3D;&#x3D;<ul><li>且写lambda时就已经显示创建了一个该函数类的实例化对象，即<code>modi</code>就是一个函数对象</li></ul></li></ul><h2 id="函数类"><a href="#函数类" class="headerlink" title="函数类"></a>函数类</h2><p>重载<code>()</code>运算符的类型就是函数类</p><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>扩展为函数类时，其内部的<code>()</code>重载函数默认是const修饰的</p><ul><li>那他怎么修改捕获的对象？-&gt; 默认const则不能修改引用方式捕获的外部变量<ul><li>因为const不允许修改成员变量</li></ul></li><li>值捕获时需要在lambda后面加上<code>mutable</code>进行修饰，对闭包成员变量进行修改  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">auto modi <span class="hljs-operator">=</span> [<span class="hljs-operator">=</span>all]() mutable -&gt; void &#123; ... &#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>引用捕获时，默认内部的<code>()</code>为非const的，因此可以修改其成员变量</li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>技巧-多内容元素排序</title>
    <link href="/2024/09/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7-%E5%A4%9A%E5%86%85%E5%AE%B9%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/09/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7-%E5%A4%9A%E5%86%85%E5%AE%B9%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>按元素频率高低进行输出，如果频率相同，则按元素的额值大小进行排序</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>参考 [[技巧-自定义类型-插入容器并排序]]</p><ul><li>这种&#x3D;&#x3D;元素含有多个排序内容&#x3D;&#x3D;的情况，都可以使用自定义类型进行</li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>技巧-自定义类型-插入set容器</title>
    <link href="/2024/09/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-%E6%8F%92%E5%85%A5%E5%AE%B9%E5%99%A8%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/09/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-%E6%8F%92%E5%85%A5%E5%AE%B9%E5%99%A8%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="华为0904-第一题"><a href="#华为0904-第一题" class="headerlink" title="华为0904-第一题"></a>华为0904-第一题</h2><p>按元素频率高低进行输出，如果频率相同，则按元素的额值大小进行排序</p><h3 id="自定义item类型"><a href="#自定义item类型" class="headerlink" title="自定义item类型"></a>自定义item类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">item</span> &#123;<br><span class="hljs-type">int</span> num;<br><span class="hljs-type">int</span> count;<br><span class="hljs-built_in">item</span>(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> count) : <span class="hljs-built_in">num</span>(num), <span class="hljs-built_in">count</span>(count) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="方法一-：-set"><a href="#方法一-：-set" class="headerlink" title="方法一 ： set"></a>方法一 ： set</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里</span><br><span class="hljs-keyword">auto</span> dcompare = [](<span class="hljs-type">const</span> item&amp; l, <span class="hljs-type">const</span> item&amp; r) -&gt; <span class="hljs-type">bool</span> &#123;<br><span class="hljs-type">bool</span> ret = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (l.count &gt; r.count) ret = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l.count == r.count) ret = l.num &gt; r.num;<br><span class="hljs-keyword">return</span> ret;<br>&#125;;<br><span class="hljs-comment">// 注意一定要将dcompare函数类的对象显示传递给st的构造函数</span><br>set&lt;item, <span class="hljs-keyword">decltype</span>(dcompare)&gt;<span class="hljs-built_in">st</span>(dcompare);<br><span class="hljs-comment">// 另外要注意compare函数最好为const类型的</span><br></code></pre></td></tr></table></figure><h3 id="方法二-：vector"><a href="#方法二-：vector" class="headerlink" title="方法二 ：vector"></a>方法二 ：vector</h3><p>其实这里直接使用vector容器也可以，所有元素完全插入后，直接来一个sort就可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;item&gt; <span class="hljs-title">st</span><span class="hljs-params">(mp.size(), item(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))</span></span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : mp)<br>&#123;<br>st[i++] = <span class="hljs-built_in">item</span>(it.first, it.second);<br>&#125;<br><span class="hljs-built_in">sort</span>(st.<span class="hljs-built_in">begin</span>(), st.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> item&amp; l, <span class="hljs-type">const</span> item&amp; r) -&gt; <span class="hljs-type">bool</span> &#123;<br><span class="hljs-type">bool</span> ret = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (l.count &gt; r.count) ret = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l.count == r.count) ret = l.num &gt; r.num;<br><span class="hljs-keyword">return</span> ret;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>技巧-分组循环</title>
    <link href="/2024/09/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7-%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/09/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7-%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="题单"><a href="#题单" class="headerlink" title="题单"></a>题单</h2><h3 id="2948-交换得到字典序最小的数组"><a href="#2948-交换得到字典序最小的数组" class="headerlink" title="2948. 交换得到字典序最小的数组"></a><a href="https://leetcode.cn/problems/make-lexicographically-smallest-array-by-swapping-elements/">2948. 交换得到字典序最小的数组</a></h3><ol><li>如何将数组元素与数组下标绑定排序；即：<code>如何得到数组排序后，其下标的变化</code>!!!<ul><li>新建一个数组，里面填充下标：对该数组进行自定义排序 - 按照对应元素的大小</li></ul></li><li>排序后得到顺序排列数组元素对应的&#x3D;&#x3D;下标块群&#x3D;&#x3D;</li><li>遍历排序后的下标数组<ul><li>新建局部数组，存储所有下标：排序后的元素差值 &lt; limit</li><li>对该局部下标数组排序</li><li>遍历排序后的局部下标数组，并对应填充旧数组：<ol><li>将原先下标数组对应位置处下标所对应的元素放到旧数组中对应位置 -&gt; </li><li>对应旧数组的下标为：排序后局部下标数组对应的下标</li></ol></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数学思考-题单</title>
    <link href="/2024/09/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E5%AD%A6%E6%80%9D%E8%80%83-%E9%A2%98%E5%8D%95/"/>
    <url>/2024/09/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E5%AD%A6%E6%80%9D%E8%80%83-%E9%A2%98%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="https://leetcode.cn/problems/happy-students/">2860. 让所有学生保持开心的分组方法数</a><ul><li>要有比较强的前置数学思考与演算</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>五种迭代器</title>
    <link href="/2024/09/04/CPP/%E4%BA%94%E7%A7%8D%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2024/09/04/CPP/%E4%BA%94%E7%A7%8D%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li><p><strong>输入迭代器（Input Iterators）</strong>: 这种迭代器用于从容器中读取数据。它只支持单向遍历，即只能向前移动（通过 <code>++</code> 操作符）。输入迭代器只能进行一次读取，读取后迭代器就会前进到下一个元素。</p></li><li><p><strong>输出迭代器（Output Iterators）</strong>: 与输入迭代器相反，输出迭代器用于向容器中写入数据。它同样只支持单向遍历，且只能进行一次写入操作，写入后迭代器会自动前进到下一个位置。</p></li><li><p><strong>前向迭代器（Forward Iterators）</strong>: 前向迭代器类似于输入和输出迭代器，但它支持多次读写操作。它也只能单向遍历，但可以对同一个元素进行多次访问。</p></li><li><p><strong>双向迭代器（Bidirectional Iterators）</strong>: 如其名，双向迭代器可以在容器中向前和向后移动。它扩展了前向迭代器的功能，使得迭代器可以使用 <code>--</code> 操作符向前移动。双向迭代器在像 <code>list</code> 和 <code>set</code> 这样的容器中非常有用。</p></li><li><p><strong>随机访问迭代器（Random Access Iterators）</strong>: 这是最强大的迭代器类型，它支持所有前面提到的迭代器的功能，并且能够进行随机访问。这意味着除了能够向前和向后移动，随机访问迭代器还能够直接跳跃到任意位置（如通过 <code>+</code> 或 <code>-</code> 操作符）。<code>vector</code> 和 <code>deque</code> 容器提供了随机访问迭代器。</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><code>vector&lt;vector&lt;int&gt;&gt; students_marks</code>，不存在<code>vector&lt;int&gt;</code>类型的迭代器；因此需要自己编写</li><li>规则比较繁杂，实际算法笔试中不要考虑这种方法</li></ol><h2 id="自定义类型实现迭代器"><a href="#自定义类型实现迭代器" class="headerlink" title="自定义类型实现迭代器"></a>自定义类型实现迭代器</h2><ul><li><a href="https://hedzr.com/c++/algorithm/writing-your-own-stl-iterator/">参考</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集-方法论-题解</title>
    <link href="/2024/09/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%96%B9%E6%B3%95%E8%AE%BA-%E9%A2%98%E8%A7%A3/"/>
    <url>/2024/09/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%96%B9%E6%B3%95%E8%AE%BA-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="区间覆盖问题"><a href="#区间覆盖问题" class="headerlink" title="区间覆盖问题"></a>区间覆盖问题</h2><h3 id="染色体染色，问每个的最后颜色是什么"><a href="#染色体染色，问每个的最后颜色是什么" class="headerlink" title="染色体染色，问每个的最后颜色是什么"></a>染色体染色，问每个的最后颜色是什么</h3><ul><li><a href="https://blog.csdn.net/hacker__man/article/details/125954490">参考</a><br>给定 M MM 次染色序列，问最后所有位置的颜色是什么？如果从前向后考虑，后边的染色会覆盖之前的一种染色，可以倒着考虑，如果一段区间已经染色就不再被染色了 (每个位置只会被染色一次) ，然后跳过一些状态，进行优化。<br>重要判据:  <code>fa[i] = i</code> 表示这个节点 &#x2F; 物品，还没有出现过，或者还没有被染色过<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n,m,p,q;<br><span class="hljs-type">int</span> fa[<span class="hljs-number">1000010</span>];<br><span class="hljs-type">int</span> a[<span class="hljs-number">1100000</span>];<br><span class="hljs-type">int</span> ans[<span class="hljs-number">1100000</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">// 找到从x开始的右边的第一个没有被染色的元素</span><br>    <span class="hljs-keyword">return</span> fa[x] == x ? fa[x] : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000010</span>;i++)&#123;<br>        fa[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m)&#123;<br>        <span class="hljs-type">int</span> l = (m*p+q)%n+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> r = (m*q+p)%n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(l&gt;r)<span class="hljs-built_in">swap</span>(l,r);<br>        <span class="hljs-comment">// 【l，r】</span><br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(l);<br>        <span class="hljs-keyword">while</span>(x&lt;=r)&#123;<br>            <span class="hljs-comment">// [l,x]</span><br>            ans [x] = m;<br>            fa[x] = <span class="hljs-built_in">find</span>(x+<span class="hljs-number">1</span>);<br>            x = <span class="hljs-built_in">find</span>(x);<br>        &#125;<br>        m -- ; <span class="hljs-comment">// 容易错</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cout&lt;&lt;ans[i]&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="密码生成"><a href="#密码生成" class="headerlink" title="密码生成"></a>密码生成</h3><ul><li><a href="https://www.nowcoder.com/exam/test/82925973/detail?pid=31332154&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&keyword=%E5%B0%8F%E7%B1%B3&selectStatus=0&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">参考</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cfloat&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;<span class="hljs-type">int</span>&gt;&amp; pa)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 这里find(pa[start], pa)是关键；find(start) 肯定不行；</span><br><span class="hljs-comment">// find(start+1)，可以但是复杂度太高</span><br><span class="hljs-keyword">return</span> pa[start] == start ? start : pa[start] = <span class="hljs-built_in">find</span>(pa[start], pa);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-type">int</span> mod = <span class="hljs-number">100000009</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pa</span><span class="hljs-params">(N+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(N, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-built_in">iota</span>(pa.<span class="hljs-built_in">begin</span>(), pa.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> L, R;<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; rec;<br><br>  <br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> __ = <span class="hljs-number">0</span>; __ &lt; M; __++)<br><br>&#123;<br><br><span class="hljs-type">int</span> l, r;<br><br>cin &gt;&gt; l &gt;&gt; r;<br><br>rec.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);<br><br>&#125;<br><br><span class="hljs-keyword">while</span> (M &gt; <span class="hljs-number">0</span>)<br><br>&#123;<br><br>L = rec[M<span class="hljs-number">-1</span>].first;<br><br>R = rec[M<span class="hljs-number">-1</span>].second;<br><br><span class="hljs-keyword">if</span> (L &gt; R) <span class="hljs-built_in">swap</span>(L, R);<br><br>  <br><br><span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(L, pa);<br><br><span class="hljs-keyword">while</span> (x &lt;= R)<br><br>&#123;<br><br>nums[x] = M;<br><br><span class="hljs-comment">// ans += (1ll * x * M)%mod;</span><br><br>pa[x] = <span class="hljs-built_in">find</span>(x+<span class="hljs-number">1</span>, pa);<br><br>x = <span class="hljs-built_in">find</span>(x, pa);<br><br>&#125;<br><br>M--;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)<br><br>&#123;<br><br>ans += (<span class="hljs-number">1ll</span> * i * nums[i])%mod;<br><br>ans %= mod;<br><br>&#125;<br><br>  <br><br>cout &lt;&lt; ans;<br><br>&#125;<br><br><span class="hljs-comment">// 64 位输出请用 printf(&quot;%lld&quot;)</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title> DDS-开发记录</title>
    <link href="/2024/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/DDS-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/DDS-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="纪要"><a href="#纪要" class="headerlink" title="纪要"></a>纪要</h3><ul><li>基础有问题：还是每个pp对应一个接收监听接口：<ul><li>多一个监听接口到pp的映射：这个就比较好做了</li><li>而且之后的process操作的都是这个pp</li><li>要区分一下公共的部分 - 即发往7400的部分 -&gt; 即发现阶段的处理应该如何进行</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内联汇编</title>
    <link href="/2024/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <url>/2024/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/1184893257/simplelinux/blob/master/inlineasm.md">内联汇编</a></li><li><a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">gcc 内联汇编 HOWTO 文档</a>  </li><li><a href="http://lxr.free-electrons.com/ident">Linux Cross Reference——各版本 linux 内核函数检索</a></li></ul><p>内联汇编是指在 C&#x2F;C++ 代码中嵌入的汇编代码， 与全部是汇编的汇编源文件不同，它们被嵌入到 C&#x2F;C++ 的大环境中。</p><h2 id="一、gcc-内联汇编"><a href="#一、gcc-内联汇编" class="headerlink" title="一、gcc 内联汇编"></a>一、gcc 内联汇编</h2><p>gcc 内联汇编的格式如下：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">asm</span> ( 汇编语句<br>    : 输出操作数<span class="hljs-comment">// 非必需</span><br>    : 输入操作数<span class="hljs-comment">// 非必需</span><br>    : 其他被污染的寄存器<span class="hljs-comment">// 非必需</span><br>    );<br></code></pre></td></tr></table></figure><p>我们通过一个简单的例子来了解一下它的格式（gcc_add.c）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>, c=<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 蛋疼的 add 操作</span><br><span class="hljs-built_in">asm</span>(<br><span class="hljs-string">&quot;addl %2, %0&quot;</span><span class="hljs-comment">// 1</span><br>: <span class="hljs-string">&quot;=g&quot;</span>(c)<span class="hljs-comment">// 2</span><br>: <span class="hljs-string">&quot;0&quot;</span>(a), <span class="hljs-string">&quot;g&quot;</span>(b)<span class="hljs-comment">// 3</span><br>: <span class="hljs-string">&quot;memory&quot;</span>);<span class="hljs-comment">// 4</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;现在c是:%d\n&quot;</span>, c);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>内联汇编中：</p><ol><li><p>第1行是汇编语句，用双引号引起来， <strong>多条语句用 ; 或者 <code>\n\t</code> 来分隔。</strong></p><ul><li>%0 - 2中的数字表示输出，输出操作数，从前往后</li></ul></li><li><p>第2行是输出操作数，都是 “&#x3D;?”(var) 的形式， var 可以是任意内存变量（输出结果会存到这个变量中）， ? 一般是下面这些标识符 （表示内联汇编中用什么来代理这个操作数）：</p><ul><li>a,b,c,d,S,D 分别代表 eax,ebx,ecx,edx,esi,edi 寄存器</li><li>r 上面的寄存器的任意一个（谁闲着就用谁）</li><li>m 内存</li><li>i 立即数（常量，只用于输入操作数）</li><li>g 寄存器、内存、立即数 都行（gcc你看着办）</li></ul><p> <strong>在汇编中用 %序号 来代表这些输入&#x2F;输出操作数， 序号从 0 开始。为了与操作数区分开来， 寄存器用两个%引出，如：%%eax</strong> </p></li><li><p>第3行是输入操作数，都是 “?”(var) 的形式， <strong>? 除了可以是上面的那些标识符，还可以是输出操作数的序号， 表示用 var 来初始化该输出操作数</strong>， 上面的程序中 %0 和 %1 就是一个东西，初始化为 1（a的值）。</p></li><li><p>第4行标出那些在汇编代码中修改了的、 又没有在输入&#x2F;输出列表中列出的寄存器， 这样 gcc 就不会擅自使用这些”危险的”寄存器。 还可以用 “memory” 表示在内联汇编中修改了内存， 之前缓存在寄存器中的内存变量需要重新读取。</p></li></ol><p>上面这一段内联汇编的效果就是， 把a与b的和存入了c。当然这只是一个示例程序， 谁要真这么用就蛋疼了， <strong>内联汇编一般在不得不用的情况下才使用</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初始化列表与列表初始化行为</title>
    <link href="/2024/09/02/CPP/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%8E%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%8C%E4%B8%BA/"/>
    <url>/2024/09/02/CPP/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%8E%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%8C%E4%B8%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>自己定义的类在定义一个实例化的对象时，要使用列表初始化的方式的话，需要添加一个构造函数，且该构造函数的参数为单模版参数类型<code>initializer_list&lt;T&gt;</code></p><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p>普通函数也可以使用<code>initializer_list&lt;T&gt;</code>类型作为其参数，调用时就可以传入<code>&#123;&#125;</code>包裹起来的列表；也可以作为函数的返回值类型，这样函数就可以返回列表类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//打印初始化列表的每个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; vals)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//遍历列表中的每个元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = vals.<span class="hljs-built_in">begin</span>(); p!=vals.<span class="hljs-built_in">end</span>(); ++p)&#123;<br>        std::cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">print</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数学相关</title>
    <link href="/2024/09/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/09/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="gcd-lcm"><a href="#gcd-lcm" class="headerlink" title="gcd &#x2F; lcm"></a>gcd &#x2F; lcm</h2><ul><li><a href="https://majorli.github.io/algo_guide/ch02/sec01/211_gcd_lcm.html">3.1.1. 最大公因数与最小公倍数</a><br>有三条性质</li></ul><ol><li><code>gcd(a, b) = gcd(b, a)</code></li><li><code>gcd(a, 0) = a</code></li><li><code>a &gt; b =&gt; gcd(a, b) = gcd(a mod b, b)</code></li><li><code>gcd(a, b) ✖️ lcm(a, b) = a ✖️ b</code></li></ol><p>算法</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">int</span> gcd(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)<br>&#123;<br><span class="hljs-keyword">while</span> (a &amp;&amp; b &amp;&amp; (a &gt; b ? a %= b : b %= a));<br><br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title> Hash优化</title>
    <link href="/2024/09/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Hash%E4%BC%98%E5%8C%96/"/>
    <url>/2024/09/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Hash%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="题库"><a href="#题库" class="headerlink" title="题库"></a>题库</h2><ul><li>给定相同长度的两个数组，问有几个区间，使得两个数组在这个区间中的异或值相同？<ul><li>目标是al^…^ar &#x3D; bl^…br， 可以得出 al^…ar^bl^…br &#x3D; 0， 于是可以定义 ci &#x3D; ai^bi，有cl^…^cr &#x3D; 0， 然后是比较熟悉的问题了， <em><strong>用map 存c的前缀异或出现的次数</strong></em>；</li></ul></li></ul><h2 id="字符串哈希操作"><a href="#字符串哈希操作" class="headerlink" title="字符串哈希操作"></a>字符串哈希操作</h2><ul><li><a href="https://leetcode.cn/problems/maximum-deletions-on-a-string/">2430. 对字母串可执行的最大删除数</a><ul><li>通过hash快速判断两个字符串是否相等<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40001</span>, P = <span class="hljs-number">31</span>;<br>ull h[N];<br>ull p[N];<br><span class="hljs-function">ull <span class="hljs-title">shash</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> h[r] - (l == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : h[l - <span class="hljs-number">1</span>]*p[r - l + <span class="hljs-number">1</span>]);<br>&#125;<br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>h[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>h[i] = h[i - <span class="hljs-number">1</span>]*P + s[i];<br>p[i] = p[i - <span class="hljs-number">1</span>]*P;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>非贪心算法</title>
    <link href="/2024/09/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E9%9D%9E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E9%9D%9E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="局部推全局时，局部最优不一定得不到全局最优"><a href="#局部推全局时，局部最优不一定得不到全局最优" class="headerlink" title="局部推全局时，局部最优不一定得不到全局最优"></a>局部推全局时，局部最优不一定得不到全局最优</h2><ul><li>给定一个数组，平滑值的定义如下：相邻两个数的差值的绝对值的最大值。有k次操作，可以随意插入任意一个数字，求k次操作后数组的平滑值最小是多少？<ul><li>局部最优：<code>[0, 10]</code>允许两次插入时，先后两次插入则得到<code>[0, 3, 5, 10]</code>，而最优结果应该是</li><li>全局最优：<code>[0, 3, 6, 10]</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前缀和</title>
    <link href="/2024/09/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2024/09/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><ul><li><a href="https://leetcode.cn/problems/maximum-deletions-on-a-string/">2430. 对字母串可执行的最大删除数</a><ul><li>通过记录字符串前缀哈希值，及对应的底数幂次 -&gt; 快速计算任意一个连续子字符串的哈希值</li></ul></li></ul><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><ul><li><p><a href="https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/">1878. 矩阵中最大的三个菱形和</a></p><ul><li><a href="https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/solutions/805356/c-qian-zhui-he-mo-ni-by-answerer-r534">cpp前缀和模拟</a></li><li>计算公式<code>sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j]</code></li></ul></li><li><p><a href="https://leetcode.cn/problems/count-increasing-quadruplets/">2552. 统计上升四元组</a></p></li><li><p>利用动规预处理数据，为后续计算做准</p><ul><li>这题考虑遍历（j, k） -&gt; 这里就么有想到</li><li>创建二维数组mem   -&gt; 使用二维数组记录大小元素个数信息也没有想到<ul><li>有部分前缀和的思想在里面</li></ul></li><li>事先计算<code>[x, y]</code>范围里，比y小的元素数目 -&gt; 记录到<code>mem[x][y]</code></li><li>计算<code>[y, z]</code>范围里，比y大的元素数目 -&gt; 记录到<code>mem[x][z]</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/31/CPP/cpp%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/08/31/CPP/cpp%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>更高效的初始化：</p><ul><li>对于某些类型的成员变量，特别是具有常量、引用类型或没有默认构造函数的类类型成员，使用初始化列表进行初始化比在构造函数体中赋值更高效。这是因为对于这些类型，初始化必须在对象创建时进行，而不能通过赋值来完成。</li><li>例如，对于引用类型成员，必须在初始化列表中进行初始化，因为引用一旦绑定就不能再重新绑定到其他对象。<br>保证初始化顺序：</li><li>成员变量的初始化顺序是按照它们在类定义中的声明顺序进行的，而与初始化列表中的顺序无关。使用初始化列表可以明确地指定成员变量的初始化顺序，避免由于初始化顺序不确定而导致的错误。</li><li>例如，如果一个类有多个成员变量，其中一个成员变量的构造函数依赖于另一个成员变量的初始化，使用初始化列表可以确保正确的初始化顺序</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>常量成员变量：对于常量成员变量，必须在初始化列表中进行初始化，因为常量在创建后不能被修改</li><li>引用成员变量：引用成员变量必须在初始化列表中进行初始化，因为引用一旦绑定就不能再重新绑定到其他对象</li><li><em><strong>没有默认构造函数的类类型成员</strong></em>：如果一个类有一个成员变量是另一个类的对象，而该类没有默认构造函数，那么必须在初始化列表中使用该类的带参数构造函数来初始化这个成员变量</li><li>继承中的基类和成员对象初始化：<em><strong>在派生类的构造函数中，首先会调用基类的构造函数</strong></em>，然后按照声明顺序调用成员对象的构造函数。<em><strong>使用初始化列表可以明确地指定基类和成员对象的初始化方式</strong></em></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c-cpp中的序列点</title>
    <link href="/2024/08/30/CPP/c-cpp%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E7%82%B9/"/>
    <url>/2024/08/30/CPP/c-cpp%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>c&#x2F;cpp中含有序列点，规范规定：编译器指令重排优化时，不能跨过序列点</p><p>常见的序列点有：</p><ul><li>函数调用</li><li>volatile 关键字相关的内存访问</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类中特殊成员变量的初始化</title>
    <link href="/2024/08/30/CPP/%E7%B1%BB%E4%B8%AD%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2024/08/30/CPP/%E7%B1%BB%E4%B8%AD%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="类中特殊成员变量初始化"><a href="#类中特殊成员变量初始化" class="headerlink" title="类中特殊成员变量初始化"></a>类中特殊成员变量初始化</h2><h4 id="const-成员，引用成员"><a href="#const-成员，引用成员" class="headerlink" title="const 成员，引用成员"></a>const 成员，引用成员</h4><p>必须使用初始化列表的方式初始化，即<code>A(int&amp; a, B&amp; b) : m_a(a), m_b(b) &#123;&#125;</code></p><h4 id="普通静态变量"><a href="#普通静态变量" class="headerlink" title="普通静态变量"></a>普通静态变量</h4><p>必须在类外通过<code>::</code>进行显示的初始化</p><h4 id="静态整型常量"><a href="#静态整型常量" class="headerlink" title="静态整型常量"></a>静态整型常量</h4><p>可以直接在类内定义时初始化</p><h4 id="静态非整型常量"><a href="#静态非整型常量" class="headerlink" title="静态非整型常量"></a>静态非整型常量</h4><p>不能直接在类内定义的时候初始化；必须在类外通过<code>::</code>进行显示的初始化</p><h4 id="其它类对象且没有默认构造函数"><a href="#其它类对象且没有默认构造函数" class="headerlink" title="其它类对象且没有默认构造函数"></a>其它类对象且没有默认构造函数</h4><ul><li>必须在初始化列表里面使用该类的带参构造函数来初始化这个成员变量</li><li>或者在类定义时，使用初始化列表的方式赋初值<ul><li>该类必须含有参数为初始化列表的构造函数 -&gt; 优先匹配</li><li>或者含有相同参数个数构造函数</li></ul></li><li>肯定不能使用<code>()</code>的形式进行初始化</li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优先级翻转</title>
    <link href="/2024/08/30/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E4%BC%98%E5%85%88%E7%BA%A7%E7%BF%BB%E8%BD%AC/"/>
    <url>/2024/08/30/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E4%BC%98%E5%85%88%E7%BA%A7%E7%BF%BB%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.cnblogs.com/mickey-double/p/14366803.html" title="发布于 2021-02-03 14:20">RTOS—优先级翻转与优先级继承</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>涉及到三个任务</p><ul><li>A  10  需要获取资源锁 t</li><li>B 20 无需获取资源锁</li><li>C 30 需要获取资源锁 t<br>在某一时刻，线程A获得资源锁，进行执行；</li><li>在A获得锁期间，任务B准备就绪，由于其优先级较高因此可以抢占A进行运行；<ul><li>在B运行期间，C准备就绪开始运行，但是由于C也要获取资源锁t，而且此时t已经被锁住，因此C只得让出CPU<ul><li>之后B重新获得CPU进行执行</li></ul></li></ul></li></ul><p>可以看到，高优先级的C给A让出执行很正常，因为它要等待资源锁释放；但是C竟然把CPU让给了不需要锁的，中优先级的任务B</p><ul><li>这就是优先级翻转</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title> MESI：为什么还需要内存屏障</title>
    <link href="/2024/08/30/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/MESI%20-%3E%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <url>/2024/08/30/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/MESI%20-%3E%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#%E6%80%BB%E7%BB%93">2.4 CPU 缓存一致性</a></li><li><a href="https://egg-pie-driver.github.io/memory-course/16-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9A%E6%9C%89%E4%BA%86MESI%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F.html">16 | 内存模型：有了MESI为什么还需要内存屏障？</a></li></ul><h2 id="使用总结-多核多线程开发"><a href="#使用总结-多核多线程开发" class="headerlink" title="使用总结 - 多核多线程开发"></a>使用总结 - 多核多线程开发</h2><ul><li>屏障前的读写，发生在之后的读写之前<ul><li>这里的<em><strong>发生</strong></em>可以理解为<ul><li>写：已经写到了其它core的缓存中&#x2F;主存中，即该更新值对系统内的其它master是可见的</li><li>读：已经读到了最新值</li></ul></li></ul></li><li>从某个core上观察<ul><li>自己在执行某条指令时</li><li>另外的CPU可能在执行任意一条待执行指令<ul><li>因此在某些关键阶段，需要对多核并发进行精细的控制</li></ul></li></ul></li></ul><h2 id="MESI-简要回顾"><a href="#MESI-简要回顾" class="headerlink" title="MESI 简要回顾"></a>MESI 简要回顾</h2><p>单核场景下，通过</p><ul><li><em><strong>写通（write through）</strong></em></li><li><em><strong>写回（write back）</strong></em> : 只有当脏缓存块被换出时才写入主存<br>可以保证缓存与主存的一致性。然而在多核场景下，事情变得复杂了起来</li></ul><blockquote><p>core 0的写还没有更新到主存，core1请求读，将读到旧值；或者core1读到其自己缓存中的旧值</p></blockquote><p>因此需要更多的方法来保证多核间缓存一致性，同步多核缓存中的数据</p><ul><li><em><strong>写传播</strong></em>：core0的缓存更新后要通知给其它核，并将缓存更新传播到其它核的缓存中【如果此时其它核上也有这个数据的缓存时，没有的话就不用了】</li><li>多核同时写相同数据的缓存的完成顺序，在多个核看起来顺序需要是一致的。叫做<em><strong>事务的串行化</strong></em></li></ul><p>要实现<em><strong>事务的串行化</strong></em>，要做到两点</p><ul><li>core对缓存的操作要同步给其它core</li><li>要引入<em><strong>锁🔒</strong></em>：如果两个core有相同数据的缓存，那么对于这个缓存的更新，只有拿到了<em><strong>🔒</strong></em>才能进行</li></ul><h3 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h3><p>core将监听总线事件，当出现缓存更新事件时，core会比较自己有没有相同数据的缓存，如果有的话，就更新自己的缓存内容</p><h3 id="MESI状态更新简要"><a href="#MESI状态更新简要" class="headerlink" title="MESI状态更新简要"></a>MESI状态更新简要</h3><h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><ul><li>当前处于修改模式，再写时，无需写传播</li></ul><h4 id="E"><a href="#E" class="headerlink" title="E"></a>E</h4><ul><li>当前处于独享模式，写缓存时，无需写传播</li></ul><h4 id="S"><a href="#S" class="headerlink" title="S"></a>S</h4><ul><li>当前处于共享模式，其它core有相同数据的缓存；写缓存时需要：<ol><li>先向其它core发送缓存失效指令</li><li>等待其它core对缓存失效指令的确认回复【其它core收到后，无效化相关的缓存块，之后发送确认回复】</li><li>收到所有确认回复之后，才能对缓存进行更新，并切换状态到<em><strong>M</strong></em></li></ol></li></ul><h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><ul><li>无效状态，得先将数据从主存加载到缓存，才能进行后续的读写</li></ul><h3 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h3><p>两个无关的变量A，B，由于处在同一个<code>cache line</code>上，且<em><strong>MESI的最小作用单位为一个cache line</strong></em>，因此如果两个核心上的两个线程分别读写自己的变量，则会导致不断的缓存失效：这就是伪共享问题</p><h4 id="避免伪共享问题"><a href="#避免伪共享问题" class="headerlink" title="避免伪共享问题"></a>避免伪共享问题</h4><ol><li>经常会修改的热点数据，要避免刚好在同一个cache line上；即单独的共享数据要与缓存行大小对齐：<em><strong>用空间换时间</strong></em></li></ol><h2 id="有了MESI为什么还需要内存屏障"><a href="#有了MESI为什么还需要内存屏障" class="headerlink" title="有了MESI为什么还需要内存屏障"></a>有了MESI为什么还需要内存屏障</h2><h3 id="问题根源-写"><a href="#问题根源-写" class="headerlink" title="问题根源 - 写"></a>问题根源 - 写</h3><hr><p>可以看到在<em><strong>S</strong></em>状态时，想要修改缓存，有可能需要等待很长时间</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>引入<em><strong>store buff</strong></em>；&#x3D;&#x3D;写缓存时将数据写入store buff&#x3D;&#x3D;<ul><li>并由store去执行漫长的核间MESI同步</li><li>为提升性能，放弃了缓存一致性【弱缓存一致性】</li></ul></li><li>但是又引入了新的问题：store buffe的运行机制会导致 -&gt; <em><strong>写到缓存&#x2F;主存的先后顺序可能与程序序不一样</strong></em><ul><li>CPU<em><strong>乱序执行</strong></em></li><li>【即使CPU不乱序执行】后写的缓存行可能处于E&#x2F;M状态，而先写的缓存行可能处于S状态；因此后发出的缓存写的可能先于先发出的缓存写的到达主存 -&gt; <em><strong>乱序完成</strong></em></li></ul></li></ul><h4 id="这个问题就交给工程师吧"><a href="#这个问题就交给工程师吧" class="headerlink" title="这个问题就交给工程师吧"></a>这个问题就交给工程师吧</h4><ul><li>需要工程师自己在合适的地方加内存屏障【硬件无法为我们提供进一步的保证了】<ul><li>暂停让store buffer完成所有缓存更新的同步</li><li>保证<em><strong>先发出的缓存写先走完MESI的整个流程</strong></em>；再走后发出的缓存写的MESI</li><li>保证其它CPU能观察到CPU0按顺序的缓存更新</li></ul></li><li>使用写相关内存屏障的时候，要考虑到<em><strong>stroe buffer</strong></em>机制</li></ul><h3 id="问题根源-读"><a href="#问题根源-读" class="headerlink" title="问题根源 - 读"></a>问题根源 - 读</h3><hr><p>MESI中写时，要向其它CPU发缓存失效请求，并等待回复；其它CPU在接收到请求后，从把缓存置为无效，到发出确认回复的过程是比较漫长的</p><ul><li>容易导致store buffer写到cache的等待时间较长，导致store buffer容量爆掉</li></ul><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>引入 <em><strong>invalid queue</strong></em> 失效队列：<ul><li>收到 invalid 缓存块的消息后，立即向对方回复✅</li><li>但并没有把自己的缓存由<em><strong>S</strong></em>更新为<em><strong>I</strong></em></li><li>而是把这个失效消息放入<em><strong>queue</strong></em>中</li><li>等到<em><strong>空闲的时候</strong></em>再去处理失效消息。这里的空闲，在编程开发时要认为是未处理</li></ul></li><li>引入了新的问题：<ul><li>core1收到core0的无效缓存块消息后，放到了queue中；然而从放入，到该invalid实际被core处理还要经过一段时间；如果在这段时间内，core要读取对应的数据，则仍然使用自己缓存中的旧值</li></ul></li></ul><h4 id="也交给工程师处理"><a href="#也交给工程师处理" class="headerlink" title="也交给工程师处理"></a>也交给工程师处理</h4><ul><li>在作出这种关键的读取之前，要加入内存屏障<ul><li>暂停后面的读写指令，等待core处理完<em><strong>invalid queue</strong></em>中的无效消息</li></ul></li></ul><h2 id="内存屏障分类"><a href="#内存屏障分类" class="headerlink" title="内存屏障分类"></a>内存屏障分类</h2><h3 id="强屏障-【全量屏障】"><a href="#强屏障-【全量屏障】" class="headerlink" title="强屏障 【全量屏障】"></a>强屏障 【全量屏障】</h3><ul><li>有些内存屏障可以同时对<em><strong>store buffer</strong></em>、<em><strong>invalid queue</strong></em>产生效果<ul><li>例如arm64的<code>DMB</code>指令</li><li>做的事情太多，性能下降</li></ul></li></ul><h3 id="读写屏障"><a href="#读写屏障" class="headerlink" title="读写屏障"></a>读写屏障</h3><ul><li>alpha架构</li></ul><h5 id="写屏障：精细控制store-buffer-【StoreStore-barrier】"><a href="#写屏障：精细控制store-buffer-【StoreStore-barrier】" class="headerlink" title="写屏障：精细控制store buffer 【StoreStore barrier】"></a>写屏障：精细控制<em><strong>store buffer</strong></em> 【StoreStore barrier】</h5><p>写屏障的作用是让屏障前后的写操作都不能翻过屏障。也就是说，写屏障之前的写操作一定会比之后的写操作先写到缓存中。<em><strong>写屏障时，暂停处理所有已发出的缓存写；处理完后，才会越过屏障</strong></em></p><h5 id="读屏障-：精细控制-invalid-queue-【LoadLoad-barrier】"><a href="#读屏障-：精细控制-invalid-queue-【LoadLoad-barrier】" class="headerlink" title="读屏障 ：精细控制 invalid queue 【LoadLoad barrier】"></a>读屏障 ：精细控制 <em><strong>invalid queue</strong></em> 【LoadLoad barrier】</h5><p>保证屏障前后的读操作都不能翻过屏障。假如屏障的前后都有缓存失效的信息，那屏障之前的失效信息一定会优先处理，也就意味着变量的新值一定会被优先更新。<em><strong>读屏障时，暂停处理所有已经收到的缓存失效请求；处理完后才会越过屏障</strong></em></p><h3 id="单向屏障：-half-way-barrier"><a href="#单向屏障：-half-way-barrier" class="headerlink" title="单向屏障： half - way barrier"></a>单向屏障： half - way barrier</h3><ul><li>arm<br>它并不是以读写来区分的，而是 <strong>像单行道一样，只允许单向通行</strong>，例如Arm中的<code>stlr</code>和<code>ldar</code>指令就是这样</li></ul><h4 id="stlr-store-release-register-release-语义"><a href="#stlr-store-release-register-release-语义" class="headerlink" title="stlr: store release register -&gt; release 语义"></a><code>stlr</code>: store release register -&gt; release 语义</h4><p>如果我们采用了带有release语义的写内存指令，那么这个<em><strong>屏障之前的所有读写都不能发生在这次写操作之后</strong></em>，相当于在这次写操作之前施加了一个内存屏障。但它并不能保证屏障之后的读写操作不会前移。简单说，它的特点是 <strong>挡前不挡后</strong>。</p><ul><li>可以认为屏障之前的写都已经写到了其他core的缓存&#x2F;主存、或者是使其他core的相关缓存块失效</li><li>可以认为屏障之前的读都已经处理完了invalid queue，且读到了最新值<br>需要注意的是，<em><strong>stlr指令除了具有StoreStore的功能</strong></em>，它<em><strong>同时还有LoadStore的功能</strong></em>。LoadStore barrier可以解决的问题是真实场景中比较少见的，所以在这里我们就先不关心它了。对于最常用的StoreStore的问题，我们在Arm中经常使用stlr这条带有release语义的写指令来解决，尽管它的能力相比我们的诉求还是大了一些</li></ul><h4 id="ldar-load-acquire-register-acquire-语义"><a href="#ldar-load-acquire-register-acquire-语义" class="headerlink" title="ldar: load acquire register -&gt; acquire 语义"></a><code>ldar</code>: load acquire register -&gt; acquire 语义</h4><p>作用是这个屏障之后的所有读写都不能发生在barrier之前，但它不管这个屏障之前的读写操作。简单说就是 <strong>挡后不挡前</strong>。<br>与stlr相对称的是，它同时具备<em><strong>LoadLoad barrier</strong></em>的能力和<em><strong>StoreLoad barrier</strong></em>的能力。在实际场景中，我们使用最多的还是LoadLoad barrier，此时我们会使用ldar来代替。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式-架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我思考</tag>
      
      <tag>内存屏障</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>enable_shared_from_this</title>
    <link href="/2024/08/28/CPP/enable_shared_from_this/"/>
    <url>/2024/08/28/CPP/enable_shared_from_this/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp - weak_ptr</title>
    <link href="/2024/08/28/CPP/weak_ptr/"/>
    <url>/2024/08/28/CPP/weak_ptr/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://csguide.cn/cpp/memory/how_to_understand_weak_ptr.html#weak-ptr-%E6%98%AF%E4%BB%80%E4%B9%88">深入理解C++ weak_ptr</a></li><li><a href="https://0cch.com/2022/10/31/some-tips-about-weakptr/">关于std::weak_ptr使用的理解</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>抽象出一个对立的概念<ul><li>&#x3D;&#x3D;内存所有者&#x3D;&#x3D;：用于管理内存的创建&#x2F;释放</li><li>&#x3D;&#x3D;内存观察者&#x3D;&#x3D;：可以访问内存；<ul><li>但是访问前需要变为临时的内存所有者</li><li>或者锁住对内存的创建&#x2F;释放&#x2F;修改等操作</li></ul></li></ul></li><li><h2 id="weak-ptr-和-shared-ptr一样，多线程使用时会涉及到数据竞争的问题"><a href="#weak-ptr-和-shared-ptr一样，多线程使用时会涉及到数据竞争的问题" class="headerlink" title="weak_ptr 和 shared_ptr一样，多线程使用时会涉及到数据竞争的问题"></a>weak_ptr 和 shared_ptr一样，多线程使用时会涉及到数据竞争的问题</h2></li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对话-内存屏障</title>
    <link href="/2024/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%AF%B9%E8%AF%9D-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <url>/2024/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%AF%B9%E8%AF%9D-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>IT知识刺客:<br>你好，欢迎关注IT知识刺客！</p><p>深蓝:<br>老师您好，最近看了您的《HPC-一文彻底搞懂并发编程与内存屏障》系列文章，收获颇多。有个问题想请教一下您，考虑在X64架构下手动实现一个多核使用的自旋锁。</p><ol><li>这应该是一个load store的访存顺序模型；</li><li>考虑初始时自旋锁变量为0；</li><li>core 0 load 发现是0 (t0)；判断为0(t1)；继续执行store 1(t2)；1被写入主存(t3); 进入关键区</li><li>core1在t4时刻也尝试获取自旋锁，因此它也load</li></ol><hr><p>如果t4处于t2-t3，有可能拿到自己缓存中的旧值0，之后执行store 1操作；接着也会进入关键区。这里明显是有问题的，因此需要在load 之前加内存屏障，确保拿数据前其它CPU的写操作都执行完成；这里不符合“写我的，读你的”场景，但是好像也要使用内存屏障消除MESI的同步延迟。是我哪里理解错了嘛？烦请老师指点~</p><hr><p>如果t4处于t0-t1&#x2F;t2之间，那么core0的load也会返回0，因此它也尝试执行store。这里会有碰撞，因该要使用您前文里说的lock进行；这里有个疑问：如果后来的core1的store没有获取总线锁，那core会采取什么操作呢？</p><ol><li>继续等待，直到写成功嘛？但是感觉也有问题，因为已经是1了，我后续写1成功，但是app后续都会进入关键区</li><li>返回失败。这样感觉可以，但是CPU如何通知汇编程序员？难道store后，还需要检查某些系统寄存器的状态位？ -&gt; </li><li>这种情况感觉是会发生的，老师可以推荐些相关资料嘛？</li></ol><ul><li>！！因此store 1操作也要使用屏障，确保写操作完成<ul><li>详细看一下arm64的<code>DSB</code>内存屏障指令</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spinlock内部一定要使用内存屏障技术</title>
    <link href="/2024/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/spinlock%E5%86%85%E9%83%A8%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/spinlock%E5%86%85%E9%83%A8%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="内存屏障总结"><a href="#内存屏障总结" class="headerlink" title="内存屏障总结"></a>内存屏障总结</h2><ul><li>应用开发用到的锁&#x2F;信号量等<code>粗粒度同步机制的内部实现</code><ul><li>肯定会用到<em><strong>内存屏障</strong></em></li><li>例如自旋锁 -&gt; <code>需要结合一个具体的实现仔细看一下</code><ul><li>都在自己的缓存中，lock_val &#x3D; 0</li><li>core 0 尝试获取，将lock_val的值写为1。接着执行关键代码<ul><li>底层MESI协议开始起作用</li><li>但是有一定延迟</li></ul></li><li>接着，core 1尝试获取，发现自己缓存中lock_val的值仍然为0，因此获取成功，也开始执行关键代码</li></ul></li><li>可以看到这里两个core都进入了关键区</li><li>因此 core 0必须等待该写操作执行完成【<code>写到内存中/或者MESI同步完成</code>】才可以继续执行后续的指令 <ul><li>因此 core 1 必须在读之前确保拿到被修改后的变量【必须从内存中获取】；即一定要<code>使用内存屏障，确保这之前其它core做的修改均已写入到主存中</code></li><li>这样看来，这里两处等待只需要一处即可？❌如果只放在读取之前<ul><li>如果 core 1的读取在core 0的写入之前&#x2F;读取之后</li><li>接着两者都会尝试写<ul><li>因此也要在写完成【即写进入了主存】之后才能进入关键区</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存屏障</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步 vs 内存屏障</title>
    <link href="/2024/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%90%8C%E6%AD%A5%20vs%20%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <url>/2024/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%90%8C%E6%AD%A5%20vs%20%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title> CPU乱序执行-内存屏障</title>
    <link href="/2024/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/CPU%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <url>/2024/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/CPU%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://mp.weixin.qq.com/s/vZDZGv1n6Ihz3A5sv7coZA">HPC(高性能计算第一篇):一文彻底搞懂并发编程与内存屏障(完结篇)</a></li></ul><h2 id="为什么CPU会乱序执行"><a href="#为什么CPU会乱序执行" class="headerlink" title="为什么CPU会乱序执行"></a>为什么CPU会乱序执行</h2><ol><li>前后两条指令没有依赖；但是前一条指令访存地址不在L1 cache中，而后一条指令的访存地址在L1 cache中，因此可以先执行第二条指令，等待第一条指令将访存单元加载到L1 cache中再执行第1条指令。有些CPU是这样做的<ul><li>但是&#x3D;&#x3D;X64&#x3D;&#x3D;架构保证写操作按序完成【顺序开始、乱序执行、顺序完成】<ul><li>也保证读操作按序完成【顺序开始、乱序执行、顺序完成】</li></ul></li><li>X64也不会将store乱序到之前的load前执行【同一个CPU】</li><li>&#x3D;&#x3D;！！&#x3D;&#x3D; 但是：读可以被乱序到它之前的写之前进行 -&gt; X64平台唯一可能会被重排的内存操作<ul><li>store to ptr_2</li><li>load from ptr_1</li><li>开始执行&#x2F;完成执行都有可能乱序</li><li>这里&#x3D;&#x3D;后来的load有可能被乱序到store之前执行&#x3D;&#x3D;</li><li>当然<em><strong>CPU在这种情况下也不会无缘无故乱序</strong></em>：只有当前面的写操作还不具备执行、完成的条件时，才会跳过写，让后面的读先完成</li></ul></li></ul></li></ol><h3 id="考虑范围"><a href="#考虑范围" class="headerlink" title="考虑范围"></a>考虑范围</h3><ul><li>考虑内存屏障时，基本忽略了不同层级cache、内存之间的写&#x2F;读延时</li></ul><h3 id="什么情况下会有问题"><a href="#什么情况下会有问题" class="headerlink" title="什么情况下会有问题"></a>什么情况下会有问题</h3><h4 id="X64"><a href="#X64" class="headerlink" title="X64"></a>X64</h4><ul><li>两个核均在短时间内执行【同一个核内前后两条&#x2F;有限多条】指令进行<ul><li><em><strong>写我的，读你的</strong></em>操作</li><li>可能会有问题</li></ul></li></ul><h2 id="MESI协议作为硬件层级的协议究竟保护了什么？"><a href="#MESI协议作为硬件层级的协议究竟保护了什么？" class="headerlink" title="MESI协议作为硬件层级的协议究竟保护了什么？"></a>MESI协议作为硬件层级的协议究竟保护了什么？</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>完成硬件级的cache同步<ul><li>但是同步有延迟，因此会带来一系列的问题 &lt;- 需要使用内存屏障解决</li><li>这里的&#x3D;&#x3D;同步&#x3D;&#x3D;概念与应用开发用到的同步有很大的不同？❌<ul><li>本质上是一样的，只是<code>粒度不同</code><ul><li>我要读同一个地址（操作同一个对象）</li><li>如果某些分支依赖于对象某些值<ul><li>但是在进入分支后，其它进&#x2F;线程对该对象的该值进行了修改，那么当前线程后续的操作肯定会出大问题的</li><li>而且这些操作离CPU太远了</li></ul></li></ul></li></ul></li><li>应用开发用到的锁&#x2F;信号量等<code>粗粒度同步机制的内部实现</code><ul><li>肯定会用到<em><strong>内存屏障</strong></em></li><li>例如自旋锁 -&gt; <code>需要结合一个具体的实现仔细看一下</code><ul><li>都在自己的缓存中，lock_val &#x3D; 0</li><li>core 0 尝试获取，将lock_val的值写为1。接着执行关键代码<ul><li>底层MESI协议开始起作用</li><li>但是有一定延迟</li></ul></li><li>接着，core 1尝试获取，发现自己缓存中lock_val的值仍然为0，因此获取成功，也开始执行关键代码</li></ul></li><li>可以看到这里两个core都进入了关键区</li><li>因此 core 0必须等待该写操作执行完成【<code>写到内存中/或者MESI同步完成</code>】才可以继续执行后续的指令<ul><li>因此 core 1 必须在读之前确保拿到被修改后的变量【必须从内存中获取】；即一定要使用内存屏障，确保这之前其它core做的修改均已写入到主存中</li></ul></li></ul></li></ul></li></ul><h3 id="考虑场景"><a href="#考虑场景" class="headerlink" title="考虑场景"></a>考虑场景</h3><ul><li>CPU0 写地址 ptr_a -&gt; 对于CPU来说需要一个周期，之后接着执行后面的指令；但是该写入实际被写入到内存中还没有完成【即指令的完成时间还没到】<ul><li>CPU1 同时读地址 ptr_a</li></ul></li><li>对于每个core，读写变量都是针对L1 cache的【当然要在开启cache的情况下讨论；此外某些MC U的某些地址位段有cache，而有些没有】</li></ul><h3 id="都在各自缓存中"><a href="#都在各自缓存中" class="headerlink" title="都在各自缓存中"></a>都在各自缓存中</h3><ul><li>则标记为S</li><li>CPU0写之后会向另一个CPU发缓存失效信息 ： 这里需要时间<ul><li>CPU0<code>写到自己的缓存后，就不管后续的操作了</code>-&gt;只花费一个周期；<code>接着执行后续的指令</code><ul><li>在之后的时间内，CPU的其它部件会完成剩余的工作，运行MESI协议</li><li>因此前一个写<code>指令实际完成的时间</code>可能晚于后续的读【不同地址】操作</li></ul></li><li>在这段时间内，如果CPU1发起读操作怎么办？-&gt; 如果CPU1那边发出的缓存失效信息还没有到达CPU1，那么CPU1会读到一个无效值！！</li></ul></li><li>这种由<code>MESI协议同步延迟</code>带来的不一致问题，也可以使用内存屏障来解决</li></ul><h2 id="如果两个Core真的同时访存同一个地址怎么办？"><a href="#如果两个Core真的同时访存同一个地址怎么办？" class="headerlink" title="如果两个Core真的同时访存同一个地址怎么办？"></a>如果两个Core真的同时访存同一个地址怎么办？</h2><p>- </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux - 开发可以的debug手段</title>
    <link href="/2024/08/26/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/Debug%E6%89%8B%E6%AE%B5/"/>
    <url>/2024/08/26/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/Debug%E6%89%8B%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="一次真实的内存泄漏检测"><a href="#一次真实的内存泄漏检测" class="headerlink" title="一次真实的内存泄漏检测"></a>一次真实的内存泄漏检测</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/715909392?utm_medium=social&utm_psn=1811515281429893123&utm_source=ZHShareTargetIDMore">Linux如何查找内存泄露和内存占用过大？</a></li></ul><h3 id="观察步骤"><a href="#观察步骤" class="headerlink" title="观察步骤"></a>观察步骤</h3><ul><li><code>pidstat</code>观察某个进程的内存使用统计【随时间变化】<ul><li>还可以观察io&#x2F;cpu&#x2F;上下文切换等信息</li></ul></li><li><code>pmap -x &lt;pid&gt;</code>显示程序的虚拟内存分布及虚拟内存映射情况，得到泄漏内存大小约为4K</li><li>查到可能是由于malloc或mmap系统调用分配内存导致的</li><li>使用<code>strace</code>跟踪系统调用，并<code>grep</code>过滤需要的信息</li></ul><h2 id="内存检测-valgrind"><a href="#内存检测-valgrind" class="headerlink" title="内存检测 -  valgrind"></a>内存检测 -  valgrind</h2><ul><li>它的一个被广泛使用的默认工具——‘Memcheck’——可以拦截malloc()，new()，free()和delete()调用。换句话说，它在检测下面这些问题非常有用：<ul><li>内存泄露</li><li>重释放</li><li>访问越界</li><li>使用未初始化的内存</li><li>使用已经被释放的内存等<br> 但是也有明显的缺点</li><li>增加了内存占用，会减慢你的程序</li><li>它有时会造成误报和漏报</li><li>它不能检测出<em><strong>静态分配的数组</strong></em>的访问越界问题  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 直接命令行执行，test为用户程序 <br>valgrind –tool=memcheck –leak-check=yes test<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="内存检测-AddressSanitizer-ASan-工具"><a href="#内存检测-AddressSanitizer-ASan-工具" class="headerlink" title="内存检测 - AddressSanitizer(ASan)工具"></a>内存检测 - AddressSanitizer(ASan)工具</h2><h3 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h3><p>AddressSanitizer（ASan）是一种内存错误检测工具，属于Clang&#x2F;LLVM编译器工具套件的一部分。它用于检测和调试C&#x2F;C++程序中的内存问题，如缓冲区溢出、使用已释放或未初始化的内存等</p><p>ASan在编译时通过插入额外的代码来动态地检测程序运行过程中的内存访问错误。它会跟踪每个分配的内存块，并在程序执行期间监视对这些内存块的访问情况。如果发现任何非法操作，比如访问已释放或越界的内存，ASan将立即报告该错误，并提供有关问题位置和堆栈跟踪信息</p><p>它包括一个编译器instrumentation模块和一个<code>提供malloc()/free()替代项的运行时库</code>。从gcc 4.8开始，AddressSanitizer成为gcc的一部分。当然，要获得更好的体验，最好使用4.9及以上版本</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>用<code>-fsanitize=address</code>选项编译和链接你的程序</li><li>用<code>-fno-omit-frame-pointer</code>编译，以得到更容易理解stack trace</li><li>可选择<code>-O1</code>或者更高的优化级别编译<br>  &#96;gcc&#x2F;clang++&#x2F;g++ -fsanitize&#x3D;address -o main -g main.c </li><li>具体使用方法需要后续查找</li></ul><h2 id="内存泄漏-无法之法-meminfo"><a href="#内存泄漏-无法之法-meminfo" class="headerlink" title="内存泄漏 - 无法之法 - meminfo"></a>内存泄漏 - 无法之法 - meminfo</h2><p>上面的内存泄露是我们知道了具体的泄露的进程，然后再做详细分析。那么如果不知道哪里内存泄露了，有什么办法，可以通过分析<code>meminfo</code>文件，来观察泄露的类型</p><p><strong>meminfo文件</strong>‌是Linux系统中用于显示内存使用情况的详细信息文件，它位于<code>/proc</code>目录下，提供了关于系统内存使用的全面信息。通过查看和分析meminfo文件的内容，可以了解系统的内存使用状况，包括总内存、空闲内存、缓存、交换分区等信息，这对于排查内存相关的问题非常有帮助</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>cat /proc/meminfo</code></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>首先，使用<code>cat /proc/meminfo</code>命令查看meminfo文件的内容，了解系统的整体内存使用情况。</li><li>分析MemTotal和MemFree的值，了解系统的总内存和可用空闲内存。</li><li>注意MemAvailable的值，它表示应用程序可用的内存，与MemFree的区别在于MemAvailable考虑了Buffers和Cached的大小，这些通常在系统需要时可以被回收。</li><li>检查SwapUsage（虽然meminfo文件中没有直接显示SwapUsage，但可以通过SwapTotal和SwapFree计算得出），如果Swap空间被大量使用，可能意味着物理内存不足。</li><li>注意Active、Inactive、Dirty和Writeback等值，这些指标可以帮助你了解系统当前的内存使用模式和可能的性能瓶颈。</li><li>如果发现某些特定类型的内存使用异常高（如AnonPages、Shmem等），可能需要进一步调查这些类型的内存使用情况，以确定是否存在内存泄漏或其他问题。</li><li>使用其他工具如<code>free</code>、<code>vmstat</code>、<code>top</code>或<code>htop</code>等命令提供的信息与meminfo文件的内容进行对比，以获得更全面的系统内存使用情况视图。</li></ol><h2 id="coredump"><a href="#coredump" class="headerlink" title="coredump"></a>coredump</h2><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://cloud.tencent.com/developer/article/1177442">Linux下使用gdb调试core文件</a></li></ul><h3 id="简要介绍-1"><a href="#简要介绍-1" class="headerlink" title="简要介绍"></a>简要介绍</h3><ol><li><p>coredump文件：当程序运行过程中出现Segmentation fault (core dumped)错误时，程序停止运行，并产生core文件。core文件是程序运行状态的内存映象。使用gdb调试core文件，可以帮助我们快速定位程序出现段错误的位置。当然，可执行程序&#x3D;&#x3D;编译时应加上-g编译选项&#x3D;&#x3D;，生成调试信息</p></li><li><p>当程序访问的内存超出了系统给定的内存空间，就会产生Segmentation fault (core dumped)，因此，段错误产生的情况主要有：</p><ul><li>访问不存在的内存地址</li><li>访问系统保护的内存地址</li><li>数组访问越界等</li></ul></li><li><p>控制coredump文件的生成</p><ul><li>使用<code>ulimit -c</code>命令可查看core文件的生成开关<ul><li>若结果为0，则表示关闭了此功能，不会生成core文件</li></ul></li><li>使用<code>ulimit -c filesize</code>命令，可以限制core文件的大小（filesize的单位为KB）。如果生成的信息超过此大小，将会被裁剪，最终生成一个不完整的core文件。在调试此core文 件的时候，gdb会提示错误。比如：ulimit -c 1024</li><li>使用ulimit -c unlimited，则表示core文件的大小不受限制。</li></ul></li><li><p>在终端通过命令<code>ulimit -c unlimited</code>只是临时修改，重启后无效 ，要想永久修改有三种方式：</p><ul><li>在<code>/etc/rc.local</code> 中增加一行 <code>ulimit -c unlimited</code></li><li>在<code>/etc/profile</code> 中增加一行 <code>ulimit -c unlimited</code></li><li>在<code>/etc/security/limits.conf</code>最后增加如下两行记录：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">@root soft core unlimited<br>@root hard core unlimited<br></code></pre></td></tr></table></figure></li></ul></li><li><p>默认生成：core默认的文件名称是<code>core.pid</code>，pid指的是产生段错误的程序的进程号。 默认路径是产生段错误的程序的当前目录</p></li></ol><h3 id="GDB调试步骤"><a href="#GDB调试步骤" class="headerlink" title="GDB调试步骤"></a>GDB调试步骤</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><ol><li>进入 <code>gdb [exec file] [core file]</code><ul><li>值得注意的是，core文件中已经含有程序执行时给定的命令行参数，因此这里无需再指定命令行参数</li><li><a href="https://stackoverflow.com/questions/8305866/how-do-i-analyze-a-programs-core-dump-file-with-gdb-when-it-has-command-line-pa">How do I analyze a program’s core dump file with GDB when it has command-line parameters?</a></li></ul></li><li>查找段错误位置：<code>where</code> 或者 <code>bt</code><ul><li>打印出错时的调用栈</li></ul></li><li>使用<code>up</code> and <code>down</code>上下切换调用栈，查看具体出错信息</li></ol><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><ol><li>进入<code>gdb --core=[core file]</code></li><li>进入gdb后指定&#x3D;&#x3D;core文件对应的符号表&#x3D;&#x3D;：<code>file [exec file]</code></li><li>查找段错误位置：<code>where</code> 或者 <code>bt</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/26/Untitled/"/>
    <url>/2024/08/26/Untitled/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp异常</title>
    <link href="/2024/08/26/CPP/%E5%BC%82%E5%B8%B8/"/>
    <url>/2024/08/26/CPP/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>C++编译器，在编译除法操作时，<em><strong>没有为它加上额外的检查代码以抛出一个异常</strong></em>；也没有要求处理不同OS之间对（已经发生的）除0错的处理。</p>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title> Linux - 系统调度点</title>
    <link href="/2024/08/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%82%B9/"/>
    <url>/2024/08/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%82%B9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造函数-析构函数的调用时机 VS 异常</title>
    <link href="/2024/08/25/CPP/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%20vs%20%E5%BC%82%E5%B8%B8/"/>
    <url>/2024/08/25/CPP/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%20vs%20%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="一般地"><a href="#一般地" class="headerlink" title="一般地"></a>一般地</h2><ul><li>这两个函数&#x3D;&#x3D;由编译器保证调用&#x3D;&#x3D;<ul><li>构造函数在创建对象时调用</li><li>析构函数在对象离开作用域时调用<ul><li>即使在作用域内发生异常(throw)，对象的析构函数仍然能确保调用</li></ul></li></ul></li><li>RAII思想的重要基础</li></ul><h2 id="CPP异常机制"><a href="#CPP异常机制" class="headerlink" title="CPP异常机制"></a>CPP异常机制</h2><ul><li>try -&gt; throw() -&gt; catch()<ul><li>开发人员可以手动使用throw来触发异常</li><li>某些std库函数也具有throw异常的功能<ul><li>总之异常的throw是先判断条件是否满足</li><li>若不满足则主动调用throw抛出异常<ul><li>是无法处理某些硬件级exception的</li></ul></li></ul></li><li>程序将从throw点返回到最近的try -&gt; catch语句块的catch中<ul><li>猜测这里是由编译器做的：跳转到最近的catch，且将中间待释放的对象的析构函数在这里进行调用&#x2F;【或者返回到catch之后再调用？】</li></ul></li><li>栈解退的过程，编译器也会在适当时机调用【静态编译出的结果；程序编译完成后，其在各种分支下应该调用的函数链就已经是确定的了（除了虚函数还有某些类似机制）】析构函数</li></ul></li></ul><h2 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h2><ul><li>是的，创建对象时，会在适当位置调用相应的构造函数，而在离开作用域时会调用析构函数<ul><li><a href="https://godbolt.org/z/YKW56YE87">compiler explorer</a><br>   ![[构造-析构调用.png]]</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯法</title>
    <link href="/2024/08/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2024/08/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="常用剪枝技巧"><a href="#常用剪枝技巧" class="headerlink" title="常用剪枝技巧"></a>常用剪枝技巧</h2><h2 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h2><ul><li><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a><ul><li>思路<ul><li>共有k个桶</li><li>每个球都要选择划分到哪一个桶，并进行回溯</li></ul></li><li>重要剪枝：如果当前桶与上一个桶的和相同，则跳过当前桶</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索</title>
    <link href="/2024/08/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2024/08/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="常见的记忆化key方案"><a href="#常见的记忆化key方案" class="headerlink" title="常见的记忆化key方案"></a>常见的记忆化key方案</h2><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><ul><li>得先想出递归的完整方案</li><li>将递归的参数引入记忆化搜索中</li><li><em><strong>记忆化搜索key压缩技术</strong></em></li></ul><h2 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h2><ul><li><p><a href="https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/">3154. 到达第 K 级台阶的方案数</a></p><ul><li>想到了递归方案 -&gt; 但是边界条件的处理不适合转化为记忆化<ul><li>想到的递归没有带返回值</li></ul></li><li>但是没有想出如何进行递归化搜索</li><li>边界条件处理的逻辑</li><li><em><strong>还是子问题的逻辑没有想好</strong></em></li></ul></li><li><p><a href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/">3144. 分割字符频率相等的最少子字符串</a></p><ul><li>记忆化递归的过程比较容易想到</li><li>难点在于：如何在遍历的过程中进行字串是否平衡的判断<ul><li>平衡：字串长度 &#x3D; 字符种类✖️字符出现的最大次数</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>位运算技巧</title>
    <link href="/2024/08/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/08/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="熟悉位运算"><a href="#熟悉位运算" class="headerlink" title="熟悉位运算"></a>熟悉位运算</h2><ul><li><p><a href="https://leetcode.cn/problems/minimum-array-end/">3133. 数组最后一个元素的最小值</a></p><ul><li>零位，1位单独处理</li><li>需要思考清楚再动手</li></ul></li><li><h2 id="3145-大数组元素的乘积"><a href="#3145-大数组元素的乘积" class="headerlink" title="3145. 大数组元素的乘积"></a><a href="https://leetcode.cn/problems/find-products-of-elements-of-big-array/">3145. 大数组元素的乘积</a></h2></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么C++的成员模板函数不能是 virtual</title>
    <link href="/2024/08/22/CPP/%E4%B8%BA%E4%BB%80%E4%B9%88C++%E7%9A%84%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%20virtual/"/>
    <url>/2024/08/22/CPP/%E4%B8%BA%E4%BB%80%E4%B9%88C++%E7%9A%84%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%20virtual/</url>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://csguide.cn/cpp/object_oriented/why_template_cannot_be_virtual.html#%E9%97%AE%E9%A2%98%E5%90%AB%E4%B9%89">为什么C++的成员模板函数不能是 virtual</a></li></ul><h2 id="自己分析"><a href="#自己分析" class="headerlink" title="自己分析"></a>自己分析</h2><h3 id="模版可以作为非虚成员函数"><a href="#模版可以作为非虚成员函数" class="headerlink" title="模版可以作为非虚成员函数"></a>模版可以作为非虚成员函数</h3><ul><li>成员函数，也就是代码，存储在代码段；是与具体的对象无关的；其不会影响类实例化对象的大小</li><li>借助name mangling，类中成员函数，类的作用基本就是给该函数进行name mangling提供名称前缀</li><li>因此，当在某个编译单元中实例化某个模版成员函数时，只需要对其进行name mangling；为了防止重定义，或许会添加弱符号特性</li><li>最后交给链接器就可以<ul><li>多个弱符号，选择占用空间最大的一个</li></ul></li></ul><h3 id="不可以为虚函数"><a href="#不可以为虚函数" class="headerlink" title="不可以为虚函数"></a>不可以为虚函数</h3><ul><li>某个编译单元内，遇到模版函数实例化，不知道该虚函数在虚表中的位置！！！</li><li>如果编译器维护cnt信息，或许可以为虚函数<ul><li>但是对并行编译提出了巨大的挑战</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重载、重写、隐藏</title>
    <link href="/2024/08/22/CPP/%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%9A%90%E8%97%8F/"/>
    <url>/2024/08/22/CPP/%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%9A%90%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://csguide.cn/cpp/object_oriented/overloading_overriding_and_hiding.html">重载、重写、隐藏的区别</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>发生在同一个作用域中<ul><li>函数名字相同，但是参数列表不同</li><li>函数返回值不参与</li></ul></li><li>依赖于name mangling - g++<ul><li>std空间使用<code>St</code></li><li>其余空间使用<code>名字长度</code>+<code>名字</code></li><li>+函数名</li><li>+参数列表类型首字母</li></ul></li></ul><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ul><li>派生类重写基类虚方法【只识记这一种情况】<ul><li>返回值相同</li><li>函数名相同</li><li>参数列表相同</li></ul></li><li>基类方法中必须含有<code>virtual</code>关键字<ul><li>基类的析构函数最好（必须）定义为虚函数</li><li>默认析构函数为非虚<ul><li><em><strong>是出于内存、运行时消耗考量</strong></em></li><li>不要为不需要的特效付出代价</li></ul></li></ul></li></ul><h3 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h3><ul><li>发生在派生类和基类之间<ul><li>只要函数名相同就会隐藏</li><li>子类对象不加作用域符号，直接调用父类中被隐藏的函数<ul><li>编译报错</li></ul></li></ul></li><li>从<em><strong>对象-数据</strong></em>本身出发：<ul><li>既然子类提供了同名的数据操作函数，那么它应该是想对子类本身的数据做个性化操作</li><li>因此将父类同名函数隐藏；</li><li>不然的话，如果子类中函数和父类中函数同名，且参数一致的话：<ul><li>还需要编译器去判断究竟使用哪一个函数最好</li></ul></li><li>这东西肯定是标准规定的</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytest-简单上手</title>
    <link href="/2024/08/22/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/Pytest-%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/"/>
    <url>/2024/08/22/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/Pytest-%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Pytest是基于Python的一套测试框架，<code>venv</code>虚拟环境配置好&#x2F;并激活后，安装好Pytest时，可以直接命令行执行pytest指令</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.cnblogs.com/superhin/p/17755515.html" title="发布于 2023-10-10 19:16">Pytest测试框架基础及进阶</a></li></ul><h2 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h2><ul><li>默认识别以<code>test_</code>开头的函数和类，进行执行</li></ul><h2 id="pytest-fixture"><a href="#pytest-fixture" class="headerlink" title="@pytest.fixture"></a>@pytest.fixture</h2><ul><li>一般用于修饰函数，而且修饰的函数一般集中存放，供其他模块复用</li><li>其修饰的函数可以作为其他模块函数定义时的参数；修饰函数的返回值作为实际的参数传递给定义的函数</li><li>@pytest.fixture(autouse&#x3D;True)<ul><li>平常写自动化用例会有一些前置的fixture操作，用例需要用到就直接将该函数的作为参数传递即可。但当用例很多的时候，会比较麻烦。可以使用该参数，这样用例(修饰的函数)就会被自动调用</li></ul></li><li>调用fixture的三种方法<ul><li>作为函数或类的参数</li><li>使用装饰器<code>@pytest.mark.usefixture()</code></li><li>autouse&#x3D;True</li></ul></li></ul><h2 id="pytest-mark-user-defined-mark"><a href="#pytest-mark-user-defined-mark" class="headerlink" title="@pytest.mark.(user_defined_mark)"></a>@pytest.mark.(user_defined_mark)</h2><ul><li>用于修饰测试函数，只有命令执行时使用<code>-m</code>指定的用例才会执行</li><li>配合自定义的pytest插件，实现一些个性化的测试用例过滤策略</li><li>一个测试函数可能会有多个mark<ul><li>只要有一个mark被指定，该测试项就会被选中执行</li><li>但是也需要服从自定义mark过滤规则</li></ul></li></ul><h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><h3 id="插件加载"><a href="#插件加载" class="headerlink" title="插件加载"></a>插件加载</h3><ul><li><code>conftest.py</code>文件存在时，加载其<code>pytest_plugins</code>变量声明的插件：按照声明的顺序加载</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2024/08/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2024/08/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li><p><a href="https://oi-wiki.org/dp/number/">OI-Wiki</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/">3007. 价值和小于等于 K 的最大数字</a></p><ul><li>只想到了普通的记忆化搜索</li></ul></li></ul><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h4 id="2088-统计农场中肥沃金字塔的数目"><a href="#2088-统计农场中肥沃金字塔的数目" class="headerlink" title="2088. 统计农场中肥沃金字塔的数目"></a><a href="https://leetcode.cn/problems/count-fertile-pyramids-in-a-land/">2088. 统计农场中肥沃金字塔的数目</a></h4><ul><li>二维转化为一维DP的时候，一定要注意递归过程中会不会覆盖此次递归需要的旧值</li><li>这题第一次提交错误，就是因为当前更新时覆盖了旧值，但是之后的计算需要被覆盖的旧值；但是忘记了另外存储旧值导致的！！！<ul><li><code>dp[i][j] = 1 + min(dp[i+1][j-1], dp[i+1][j], dp[i+1][j+1])</code></li><li>再遇到这样的得注意</li></ul></li></ul><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><ul><li><a href="https://leetcode.cn/problems/delete-and-earn/">740. 删除并获得点数</a><ul><li><a href="https://leetcode.cn/problems/delete-and-earn/solutions/2840359/dpha-xi-biao-shen-du-kong-jian-you-hua-b-i9r2">参考题解</a></li></ul></li><li>对比使用<code>[1][0]</code>两个状态的，和一个状态的</li></ul><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><ul><li><a href="https://leetcode.cn/problems/maximum-strength-of-a-group/solutions/2897806/on-yi-ci-bian-li-jian-ji-xie-fa-pythonja-xni2">2708.一个小组的最大实力值</a><ul><li>维护两个状态：最小乘积，最大乘积</li><li>状态更新：不选当前元素、当前元素单独乘积、当前元素为负时✖️最小 -&gt; 最大乘积、当前元素为正时✖️最大 -&gt; 最大乘积；当前元素为负时✖️最大 -&gt; 最小乘积、当前元素为正时✖️最小 -&gt; 最小乘积</li></ul></li></ul><h2 id="记忆化-动规"><a href="#记忆化-动规" class="headerlink" title="记忆化-&gt; 动规"></a>记忆化-&gt; 动规</h2><p><a href="https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/">3177. 求出最长好子序列 II</a></p><ul><li>容易想出记忆化搜索 -&gt; 但是转化为动归有点难☹️</li><li>下次遇到记忆化搜索的，都尝试翻译成动态规划试一试</li></ul><h2 id="利用动规预处理数据，为后续计算做准备"><a href="#利用动规预处理数据，为后续计算做准备" class="headerlink" title="利用动规预处理数据，为后续计算做准备"></a>利用动规预处理数据，为后续计算做准备</h2><ul><li><a href="https://leetcode.cn/problems/count-increasing-quadruplets/">2552. 统计上升四元组</a><ul><li>这题考虑遍历（j, k） -&gt; 这里就么有想到</li><li>创建二维数组mem   -&gt; 使用二维数组记录大小元素个数信息也没有想到<ul><li>有部分前缀和的思想在里面</li></ul></li><li>事先计算<code>[x, y]</code>范围里，比y小的元素数目 -&gt; 记录到<code>mem[x][y]</code></li><li>计算<code>[y, z]</code>范围里，比y大的元素数目 -&gt; 记录到<code>mem[x][z]</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-基础扫盲</title>
    <link href="/2024/08/21/CPP/cpp%20-%20%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/"/>
    <url>/2024/08/21/CPP/cpp%20-%20%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/</url>
    
    <content type="html"><![CDATA[<ul><li><p>从管理数据的角度理解cpp</p></li><li></li><li><p>定义位于类声明中的函数都将自动成为内联函数</p><ul><li>定义在类声明外部的，也可使用inline限定符使其成为内联的；类内声明无需加上inline限定符</li></ul></li><li><p>类中的<em><strong>函数不占用类&#x2F;对象的内存空间</strong></em>，即使用sizeof()结果不受类中成员函数的影响，仅与数据部分相关</p><ul><li><em><strong>想想：确实应该是这样的</strong></em></li><li>但是含有虚函数的话，可能含有额外的虚函数表指针</li></ul></li><li><p>类中的<em><strong>静态成员变量也不占用类实例对象的内存空间</strong></em></p></li><li><p>即然对象占据的内存空间中没有成员函数的信息，对象是怎么访问到其成员函数呢？</p><ul><li>因此可以看到，普通成员函数的访问与运行时的对象没有任何关系</li><li>普通成员函数的绑定 - <em><strong>完全依赖于编译器的解析与静态绑定</strong></em></li><li><em><strong>编译时完全确定了</strong></em></li></ul></li><li><p>对比虚函数：</p><ul><li>对象内部有虚函数表指针，因此可以访问到真实的对象对应的虚函数地址，因此可以实际调用到对象对应的虚函数</li></ul></li><li><p>当程序创建未显示初始化的对象时，总是调用默认构造函数</p><ul><li>这里就记住了：<ul><li>声明：变量&#x2F;对象，必须加上<em><strong>extern</strong></em>关键字</li></ul></li></ul></li><li><p>在类中以下面的方式声明的枚举的作用域为整个类</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bakery</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">enum</span> &#123;Month = <span class="hljs-number">12</span>&#125;;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里并没有给出枚举的变量名，因此类中并没有这个成员变量的声明；创建的类实例对象中也没有这个这个枚举成员；<code>Month</code>只是一个符号，在作用域为整个类的代码中遇到它时，编译器将用12替换它</li></ul></li><li><p>extern int test_arr[]</p><ul><li><code>test_arr</code>是不完整类型，不能对其使用sizeof()操作</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp-常见的关键字</title>
    <link href="/2024/08/21/CPP/cpp-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2024/08/21/CPP/cpp-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li>类中静态成员变量&#x2F;方法，是属于类的；即不创建对象时也可以直接使用</li><li>类中静态成员变量需要在类外显示的初始化定义</li><li>会由cpp运行时环境，在程序加载初期进行全局的初始化（包括初始化的全局变量）<ul><li>编译器在编译每个单元时，会生成一个全局变量、局部静态变量的初始化函数<ul><li>里面会调用相应的类构造函数</li><li>该初始化函数会由cpp运行时环境调用吧！！！</li></ul></li></ul></li></ul><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ul><li>静态成员变量的定义必须放在类外：<code>int child::a = 0;</code>，且<em><strong>类外定义时无需加static关键字</strong></em>进行修饰</li><li>c++语言规定静态成员变量会被默认初始化为0，<em><strong>类外定义可有可无</strong></em> ❌<ul><li>但是实际上在一些编译器中，如果不加上类外定义，会出现一些不可知的情况，<em><strong>因此在实际使用中最好在类外加上定义</strong></em></li></ul></li><li>需要在类外进行显示的初始化 -&gt; 不然编译器会报错<ul><li>ld错误，undefined reference</li></ul></li></ul><h3 id="静态成员方法"><a href="#静态成员方法" class="headerlink" title="静态成员方法"></a>静态成员方法</h3><ul><li>相比于普通成员方法<ul><li>静态方法不会隐式传递指向具体对象的<code>this</code>指针，因此其可以直接通过类来访问<ul><li>因此静态成员方法中<em><strong>也不能访问普通成员函数、普通成员变量</strong></em></li><li>只能访问静态成员变量、静态方法</li></ul></li><li>而普通成员调用时会隐式传递<code>this</code>指针<ul><li>可以访问静态成员变量</li><li>可以调用静态成员方法</li></ul></li></ul></li><li>如果在静态成员函数中声明一个静态变量，则该类的所有对象将共享这个静态变量<ul><li>那如何访问到这个静态变量呢？</li><li>无法访问到，只是其它对象在调用该静态方法前，该静态变量的值将保持</li><li>也即其它对象也只能在该静态方法中访问到这个静态变量<ul><li>当然可以通过某些技巧，向外部暴漏这个局部静态变量</li></ul></li></ul></li></ul><h3 id="函数内定义的静态变量"><a href="#函数内定义的静态变量" class="headerlink" title="函数内定义的静态变量"></a>函数内定义的静态变量</h3><ul><li>由<code>__cxa_guard_acquire/release()</code>保护，只在首次执行函数时进行初始化，且其初始化是线程安全的</li></ul><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><ul><li><a href="https://www.cnblogs.com/rednodel/p/9299251.html">C++ explicit关键字详解</a></li><li>只需用于类内的单参数构造函数（或者多参数但除了第一个，其它参数都有默认值），这样可以避免编译器的隐式转换</li><li>C11中还可以用于修饰类型转换函数，表示只能进行显示的类型转换</li></ul><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><ul><li>仅从使用的角度考虑这个关键字修饰的函数就可以：一个inline 函数被ODR-use时，其编译单元内必须要有该函数的定义，不论是在头文件中定义，还是在.h文件中定义并包含进来。</li><li>在 -O0优化等级时，如果编译单元内没有inline的定义，会报⚠️，虽然最终编译能过【含有inline定义的地方为该函数生成了符号】；但是在-O1及以上优化等级时就会报ld的错误</li><li>因此使用时要符合第一条规则</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp-内存屏障-MESI</title>
    <link href="/2024/08/18/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <url>/2024/08/18/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">✨ memory-barriers in Linux</a></li><li><a href="http://preshing.com/20120625/memory-ordering-at-compile-time">memory ordering at compile time</a></li><li><a href="https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/">Memory Barriers Are Like Source Control Operations</a></li><li><a href="https://blog.csdn.net/weixin_42877425/article/details/135619468"># C++多线程序列——理解 memory barrier</a></li><li><a href="https://blog.csdn.net/fpcc/article/details/139207281">跟我学C++中级篇——内存屏障内存栅栏和编译器屏障以及相关</a></li></ul><h2 id="CPU内存屏障"><a href="#CPU内存屏障" class="headerlink" title="CPU内存屏障"></a>CPU内存屏障</h2><p>在CPU运行时防止指令乱序执行；另外一个功能是保证数据的可见性，即：每一次值的改动，都可以保证被所有相关者看到。这种指令一般都涉及到了&#x3D;&#x3D;机器指令&#x3D;&#x3D;，对上层开发者来说，就是汇编指令</p><ul><li>在&#x3D;&#x3D;多核程序上&#x3D;&#x3D;需要关注</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>调用具有<code>memory barrier</code>效果的指令可以强制要求CPU产生正确的内存存取顺序，相关的指令有（不限于下面列出的这些指令）：</p><ul><li>GCC 中的某些内联汇编指令</li><li>Any <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684122.aspx">Win32 Interlocked operation</a>, except on Xbox 360</li><li>CPP的原子类型相关操作，例如：<code>load(std::memory_order_acquire)</code></li><li>POSIX锁操作，例如<code>pthread_mutex_lock</code></li><li>需要注意的是，以上这些操作产生的<code>memory barrier</code>可能是不同类型的</li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>LoadLoad</li><li>StoreStore</li><li>LoadStore</li><li>StoreLoad</li></ul><h2 id="编译器屏障"><a href="#编译器屏障" class="headerlink" title="编译器屏障"></a>编译器屏障</h2><p>对编译器的一种约束，让编译器按要求编译。比如在gcc中有一个定义：<br><code>#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</code></p><ul><li>编写&#x3D;&#x3D;单核程序时也要&#x3D;&#x3D;注意</li></ul><h1 id="Linux内核提供的内存屏障"><a href="#Linux内核提供的内存屏障" class="headerlink" title="Linux内核提供的内存屏障"></a>Linux内核提供的内存屏障</h1><ul><li>对于任何一个类型的内存屏障，用户可以信赖的其最小功能</li><li>实现任一种类型的内存屏障，CPU需要提供的最小功能集</li><li>如何使用内核提供的内存屏障</li></ul><h2 id="CPU应提供的最低保障"><a href="#CPU应提供的最低保障" class="headerlink" title="CPU应提供的最低保障"></a>CPU应提供的最低保障</h2><ul><li>有依赖的内存访问会被按序执行<ul><li><code>Q = READ_ONCE(P); D = READ_ONCE(*Q);</code>对应的CPU实际指令执行顺序应该为：<ul><li><code>Q = LOAD P, D = LOAD *Q</code> ；</li></ul></li><li>在某些架构的实现中<code>READ_ONCE</code>也会加入内存屏障，因此实际上CPU执行的指令顺序为：<ul><li><code>Q = LOAD P, MEMORY_BARRIER, D = LOAD *Q, MEMORY_BARRIER</code></li></ul></li></ul></li><li>有重叠操作数的load&#x2F;store，也会按序执行<ul><li><code>a = READ_ONCE(*X); WRITE_ONCE(*X, b);</code>对应的CPU执行顺序为：<ul><li><code>a = LOAD *X, STORE *X = b</code></li></ul></li></ul></li></ul><h2 id="内存屏障类型"><a href="#内存屏障类型" class="headerlink" title="内存屏障类型"></a>内存屏障类型</h2><h3 id="显式的"><a href="#显式的" class="headerlink" title="显式的"></a>显式的</h3><ul><li>Write (or Store): 屏障前的指令在屏障后指令之前执行；从内存管理器的角度来看：屏障之前的指令先于屏障之后的指令发往内存控制器<ul><li>✨写屏障通常与地址依赖屏障&#x2F;读屏障配对使用</li></ul></li><li>地址依赖屏障（Address-dependency barriers）（weak版的读屏障）<ul><li>5.9之后的内核移除了显式的该屏障API；但是<blockquote><p>APIs for marking loads from shared variables such as <code>READ_ONCE()</code> and <code>rcu_dereference()</code> provide implicit address-dependency barriers.</p></blockquote></li></ul></li><li>Read (or Load): 加强版的地址依赖屏障，同样不会影响Write指令<ul><li>✨读屏障通常与写屏障配对使用</li></ul></li><li>通用屏障：保证在其他部件（内存&#x2F;设备）看来，屏障前的LOAD&#x2F;Write指令先于屏障后的Load?Writer指令到达</li></ul><h3 id="隐式的"><a href="#隐式的" class="headerlink" title="隐式的"></a>隐式的</h3><ul><li><code>ACQUIRE</code>: 保证在其它部件看来，屏障后面的指令在屏障之后到达；但是屏障之前的指令有可能出现在屏障后。<ul><li>通常与release操作成对出现</li><li>相关接口包括：<ul><li>LOCK</li><li><code>smp_load_acquire()</code> and <code>smp_cond_load_acquire()</code></li></ul></li></ul></li><li><code>RELEASE</code>：保证屏障之前的操作在屏障之前发出；但是后面的操作也可能在屏障之前进行</li></ul><h2 id="Address-dependency-barriers"><a href="#Address-dependency-barriers" class="headerlink" title="Address-dependency barriers"></a>Address-dependency barriers</h2><blockquote><p>There is no guarantee that a CPU will see the correct order of effectsfrom a second CPU’s accesses, even <em>if</em> the second CPU uses a memory<br>barrier, unless the first CPU <em>also</em> uses a matching memory barrier (see<br>the subsection on “SMP Barrier Pairing”).</p></blockquote><p><code>✨这部分内容需要好好看一下！！！</code></p><h2 id="Linux开发时必须-禁止的假设"><a href="#Linux开发时必须-禁止的假设" class="headerlink" title="Linux开发时必须&#x2F;禁止的假设"></a>Linux开发时必须&#x2F;禁止的假设</h2><ul><li>对于不受 <code>READ_ONCE() </code>和 <code>WRITE_ONCE() </code>保护的<code>内存引用</code>，不能假定编译器会按你的意愿行事</li><li>不能认为&#x3D;&#x3D;独立的&#x3D;&#x3D;加载和存储将按给出的顺序发出(emit)</li></ul><h2 id="什么时候需要使用内存屏障"><a href="#什么时候需要使用内存屏障" class="headerlink" title="什么时候需要使用内存屏障"></a>什么时候需要使用内存屏障</h2><blockquote><p>不相关的内存存取操作可能以任意顺序被CPU执行，这对CPU-CPU，CPU-IO来说可能会产生问题；因此在CPU-CPU，IO的场景下，某些关键内存访问顺序需要保证按序执行【<code>举例PHY先写地址，后读写数据</code>】。因此需要给程序员提供一些手段来干预引导&#x3D;&#x3D;编译器&#x3D;&#x3D;和&#x3D;&#x3D;CPU&#x3D;&#x3D;按序执行指令</p></blockquote><blockquote><p>它们对屏障两侧的内存操作施加了可感知的部分排序。内存屏障用于覆盖或抑制这些技巧【为了性能进行的指令重排、合并等优化手段】，使代码能够合理地控制多个 CPU 和&#x2F;或设备的交互。</p></blockquote><blockquote><p>只有指令操作的内存涉及多个CPU之间，或者与设备之间进行，才需要考虑使用内存屏障</p></blockquote><blockquote><p>应用开发使用到的粗粒度多核同步技术：自旋锁等，内部实现肯定用到了内存屏障</p></blockquote><h3 id="多核间数据交互"><a href="#多核间数据交互" class="headerlink" title="多核间数据交互"></a>多核间数据交互</h3><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><h3 id="访问设备"><a href="#访问设备" class="headerlink" title="访问设备"></a>访问设备</h3><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我思考</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp-面经待准备</title>
    <link href="/2024/08/17/CPP/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/08/17/CPP/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p>c++11的新特性，多态，平时如何排查bug，智能指针，多线程，如何避免死锁等等。</p><p>智能指针，多线程，原子量</p><p><a href="https://www.nowcoder.com/discuss/645920858334076928?sourceSSR=dynamic">面试真题 | 蔚来嵌入式一二三面面经</a></p><p>介绍一下freertos的任务管理、内存管理、中断管理<br>再介绍一下linux的进程管理、内存管理、中断管理<br>linux怎么管理文件<br>了解什么文件系统<br>freertos的优先级反转了解么<br>如何解决优先级反转问题<br>手撕 反转链表ACM模式<br>继续八股<br>什么是字符设备、块设备<br>如何创建新的进程<br>如何启动子进程<br>服务端如何监听客户端<br>服务端如何接收客户端请求<br>服务端accept多个请求采用什么模型处理<br>线程间的通信方式</p><p>一面：tcp协议里面拥塞控制<br>http协议的get和post常用于什么场景<br>http协议中的常见方法<br>post能否去做一个只读的请求的方法<br>常见页面置换算法<br>抽象类和接口的区别<br>什么时候选择接口什么时候选择抽象类<br>代码：忘了，反正依旧就是个mid，很简单<br>二面：进程和线程的区别<br>线程共享哪些进程系统资源<br>虚拟内存是什么<br>虚拟内存和物理内存的映射和翻译过程<br>浏览器输入一个域名到展示这个界面的完整过程<br>一个ip地址对应100台服务器，tcp会和谁建立连接<br>b树和b+树的区别<br>mysql索引时一个节点一般多大<br>代码：手撕红黑树<br>三面：纯实习经历，无代码无八股。  </p><p>作者：打工coding人<br>链接：<a href="https://www.nowcoder.com/feed/main/detail/71e0476c0f5d4746a8f16d51970d82d5?sourceSSR=search">https://www.nowcoder.com/feed/main/detail/71e0476c0f5d4746a8f16d51970d82d5?sourceSSR=search</a><br>来源：牛客网</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>struct vs class</title>
    <link href="/2024/08/14/CPP/struct%20vs%20class/"/>
    <url>/2024/08/14/CPP/struct%20vs%20class/</url>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://csguide.cn/cpp/basics/class_and_struct.html#google_vignette"># C++ 中 class 和 struct 区别</a></li></ul><h2 id="相同与不同"><a href="#相同与不同" class="headerlink" title="相同与不同"></a>相同与不同</h2><p>cpp中struct 与 class基本是通用的，只有几个细节不一样</p><ul><li>class 中类中的成员默认都是 private 属性的<ul><li>struct 中结构体中的成员默认都是 public 属性的</li></ul></li><li>class 继承默认是 private 继承<ul><li>struct 继承默认是 public 继承</li></ul></li><li>class 可以用于定义模板参数：<code>template &lt;class T&gt;</code> -&gt; 正确的<ul><li>struct 不能用于定义模板参数: <code>template &lt;struct T&gt;</code> -&gt; 错误的</li></ul></li></ul><h2 id="使用习惯"><a href="#使用习惯" class="headerlink" title="使用习惯"></a>使用习惯</h2><p>实际使用中，struct 我们通常用来定义一些 POD(plain old data)<br>POD是 C++ 定义的一类数据结构概念，比如 int、float 等都是 POD 类型的</p><p>Plain 代表它是一个普通类型，Old 代表它是旧的，与几十年前的 C 语言兼容，那么就意味着可以使用 memcpy() 这种最原始的函数进行操作。</p><p>两个系统进行交换数据，如果没有办法对数据进行语义检查和解释，那就只能以非常底层的数据形式进行交互，而拥有 POD 特征的类或者结构体通过二进制拷贝后依然能保持数据结构不变。</p><p>也就是说，能用 C 的 memcpy() 等函数进行操作的类、结构体就是 POD 类型的数据。</p><p>而 class 用于定义一些 非 POD 的对象，面向对象编程。</p>]]></content>
    
    
    <categories>
      
      <category>cpp基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux - 中断下半部的三种机制</title>
    <link href="/2024/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://bbs.aw-ol.com/topic/2470/%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0-linux-tasklet-%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3"># Linux tasklet 机制的理解</a></li></ul><h2 id="Top-half-vs-Bottom-Half"><a href="#Top-half-vs-Bottom-Half" class="headerlink" title="Top half vs Bottom Half"></a>Top half vs Bottom Half</h2><ul><li>上半部关中断 VS 下半部开中断</li></ul><h2 id="softirq"><a href="#softirq" class="headerlink" title="softirq"></a>softirq</h2><ul><li>内核目前配置了10+个softirq，最多只能注册32个</li><li>使用前必须使用<code>open_softirq</code>注册对应的处理函数；使用时调用<code>raise_softirq()</code>触发&#x2F;标记软中断的发生；内核使用<code>softirq_init</code>对软中断系统进行初始化</li><li>在中断上下文执行；因此不能睡眠、触发调度</li><li><em><strong>同一个softirq可以在不同CPU上并行执行；在同一个CPU上只能串行执行</strong></em></li></ul><h2 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h2><ul><li>使用比较灵活，可以动态创建：目前驱动里面用得比较多</li><li>使用<code>tasklet_init</code>进行初始化；在中断上半部调用<code>tasklet_schedule</code>就可以触发其在下半部执行</li><li>实现依赖于<code>TASKLET_SOFTIRQ</code>这一种软中断机制</li><li>在softirq上下文中执行，也即在中断上下文中执行</li><li><em><strong>同一个tasklet不论在同一个CPU还是多个CPU上都只能串行执行</strong></em>，当第二个CPU检测到当前tasklet正在其它CPU上执行时，会将该tasklet重新挂到CPU的tasklet链表中，并重新触发softirq，等待下次执行</li><li>因此使用时不用考虑复杂的重入、并行等问题</li></ul><h2 id="work-queue"><a href="#work-queue" class="headerlink" title="work queue"></a>work queue</h2><ul><li>在进程上下文执行；要执行的工作交给一个内核线程进行。因此其在处理过程中可以睡眠，可以触发调度。而上面两种机制都不可以</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> Linux - 调度策略</title>
    <link href="/2024/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    <url>/2024/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20-%20%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://www.cnblogs.com/LoyenWang/p/12584345.html">Linux进程调度-实时调度器</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>优先级数值越低，则调度优先级越高<ul><li>0-99: 实时任务</li><li>100-139: 普通任务</li></ul></li><li>每个CPU都有三个运行队列<ul><li>dl_queue: SHCED_DEADLINE策略的任务会在这个优先级里，距离当前时间点最近的Deadline任务会被选择执行</li><li>rt_queue</li><li>cfs_queue</li><li>dl &gt; rt &gt; cfs，因此调度点选择下一个待执行任务时，先选dl -&gt;</li></ul></li><li></li></ul><h2 id="Linux-的几种调度策略"><a href="#Linux-的几种调度策略" class="headerlink" title="Linux 的几种调度策略"></a>Linux 的几种调度策略</h2><h4 id="实时进程"><a href="#实时进程" class="headerlink" title="实时进程"></a>实时进程</h4><ul><li>优先级高于普通进程：如果系统中始终有实时进程，那么普通进程将得不到调度【需要进一步明确】</li><li>SCHED_ FIFO<ul><li>没有时间片的概念；当某FIFO线程被调度运行时，其可以占用CPU任意长的时间</li><li>高优先级线程执行完成才会轮到较低优先级进&#x2F;线程的执行</li><li>高优先级线程可以抢占低优先级的线程</li></ul></li><li>SCHED_RR：<ul><li>时间片轮转</li><li>高优先级可以抢占低优先级</li><li>时间片用完后会被放入同一优先级队列的尾部，把CPU让给同一优先级的其它进程</li></ul></li></ul><h4 id="普通进程（非实时进程）"><a href="#普通进程（非实时进程）" class="headerlink" title="普通进程（非实时进程）"></a>普通进程（非实时进程）</h4><ul><li>强调公平性，防止进程饥饿</li><li>SCHED_NORMAL</li><li>SCHED_BATCH</li><li>SCHED_IDLE</li></ul><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>编程时用户指定创建进程&#x2F;线程的调度策略，内核会为其选择对应的调度器</li><li>SCHED_FIFO&#x2F;SCHED_RR均使用实时调度器RT</li><li>SCHED_NORMAL&#x2F;SCHED_BATCH均使用CFS调度器</li><li>SCHED_IDLE使用IDLE调度器</li></ul><h2 id="Linux的调度器发展历程"><a href="#Linux的调度器发展历程" class="headerlink" title="Linux的调度器发展历程"></a>Linux的调度器发展历程</h2><ol><li>楼梯调度<ul><li>证明了完全公平思想的可行性</li></ul></li><li>RSDL<ul><li>对SD算法的改进</li><li>继承了“完全公平”的核心思想</li></ul></li><li>CFS -&gt; 目前采用的调度策略<ul><li>完全公平的核心思想<ul><li>有10个进程，在CPU时间10ms内，每个进程的运行时间应为(10ms&#x2F;10) &#x3D; 1ms</li></ul></li><li>不跟踪进程的睡眠时间</li><li>不再区分交互式进程</li><li>没有将任务维护在链表式的运行队列上</li><li>对每个CPU维护一个以时间为顺序的红黑树</li></ul></li></ol><h4 id="调度器管理模块"><a href="#调度器管理模块" class="headerlink" title="调度器管理模块"></a>调度器管理模块</h4><ul><li>为了支持实时进程</li><li>CFS提供了调度器模块管理器，各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块</li></ul><ol><li>实时调度模块 (<code>sched_rt.c</code>)<ul><li>对应实时进程：SCHED_RR，SCHED_FIFO</li><li>每个CPU的rt_rq中含有100个队列，分别对应优先级0-99；数字越低代表优先级越高</li></ul></li><li>CFS调度模块 (<code>sched_fair.c</code>)<ul><li>对应普通进程：SCHED_NORMAL，SCHED_BATCH</li><li>使用红黑树挂载所有的调度实体(进程&#x2F;线程)；线程先后顺序使用虚拟执行时间进行</li></ul></li><li>IDLE调度器<ul><li>管理SCHEd_IDLE类的线程</li></ul></li></ol><h2 id="CFS调度器实现细节"><a href="#CFS调度器实现细节" class="headerlink" title="CFS调度器实现细节"></a>CFS调度器实现细节</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/LoyenWang/p/12495319.html">Linux进程调度- CFS调度器</a></li></ul><h3 id="简要原理"><a href="#简要原理" class="headerlink" title="简要原理"></a>简要原理</h3><ul><li>调度器计算、维护、更新每个进程的虚拟执行时间 &lt;- 来自进程执行时间【这两个都有相应的计算公式】</li><li>&#x3D;&#x3D;调度点&#x3D;&#x3D;时，调度器选择&#x3D;&#x3D;虚拟执行时间较小&#x3D;&#x3D;的进程进行切换 -&gt; 期望分配给每个普通任务的CPU时间是相同的</li><li>虚拟执行时间计算时，要考虑到任务的&#x3D;&#x3D;权重值&#x3D;&#x3D;</li></ul><h4 id="虚拟执行时间计算"><a href="#虚拟执行时间计算" class="headerlink" title="虚拟执行时间计算"></a>虚拟执行时间计算</h4><ul><li>nice值到权重的映射：nice值从-20 -&gt; 19，<em><strong>每个任务的nice值是固定的</strong></em>，进而得到固定的权重：可以看到nice值越低，越容易获得CPU。默认nice值是0<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> sched_prio_to_weight[<span class="hljs-number">40</span>] = &#123; <br><span class="hljs-comment">/* -20 */</span> <span class="hljs-number">88761</span>, <span class="hljs-number">71755</span>, <span class="hljs-number">56483</span>, <span class="hljs-number">46273</span>, <span class="hljs-number">36291</span>, <br><span class="hljs-comment">/* -15 */</span> <span class="hljs-number">29154</span>, <span class="hljs-number">23254</span>, <span class="hljs-number">18705</span>, <span class="hljs-number">14949</span>, <span class="hljs-number">11916</span>, <br><span class="hljs-comment">/* -10 */</span> <span class="hljs-number">9548</span>, <span class="hljs-number">7620</span>, <span class="hljs-number">6100</span>, <span class="hljs-number">4904</span>, <span class="hljs-number">3906</span>, <br><span class="hljs-comment">/* -5 */</span> <span class="hljs-number">3121</span>, <span class="hljs-number">2501</span>, <span class="hljs-number">1991</span>, <span class="hljs-number">1586</span>, <span class="hljs-number">1277</span>, <br><span class="hljs-comment">/* 0 */</span> <span class="hljs-number">1024</span>, <span class="hljs-number">820</span>, <span class="hljs-number">655</span>, <span class="hljs-number">526</span>, <span class="hljs-number">423</span>, <br><span class="hljs-comment">/* 5 */</span> <span class="hljs-number">335</span>, <span class="hljs-number">272</span>, <span class="hljs-number">215</span>, <span class="hljs-number">172</span>, <span class="hljs-number">137</span>, <br><span class="hljs-comment">/* 10 */</span> <span class="hljs-number">110</span>, <span class="hljs-number">87</span>, <span class="hljs-number">70</span>, <span class="hljs-number">56</span>, <span class="hljs-number">45</span>, <br><span class="hljs-comment">/* 15 */</span> <span class="hljs-number">36</span>, <span class="hljs-number">29</span>, <span class="hljs-number">23</span>, <span class="hljs-number">18</span>, <span class="hljs-number">15</span>, &#125;;<br></code></pre></td></tr></table></figure></li><li>执行时间的计算：<code>runtime = (sched_period * weight / sum(weights)) &gt;&gt; WMULT_SHIFT</code></li><li>sched_period：默认为6ms，当任务较多时为：<code>nr_running * 0.75(默认)</code></li><li>虚拟执行时间：<code>vruntime += runtime * NICE0_LOAD / weight</code></li><li><code>NICE0_LOAD</code>也为一个常量</li></ul><h2 id="实时调度模块"><a href="#实时调度模块" class="headerlink" title="实时调度模块"></a>实时调度模块</h2><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/LoyenWang/p/12584345.html">Linux进程调度-实时调度器</a></li></ul><h2 id="BFS调度器"><a href="#BFS调度器" class="headerlink" title="BFS调度器"></a>BFS调度器</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多核操作系统 vs 运行在多个核上的操作系统</title>
    <link href="/2024/08/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E6%A0%B8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20vs%20%E8%BF%90%E8%A1%8C%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%A0%B8%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/08/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E6%A0%B8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20vs%20%E8%BF%90%E8%A1%8C%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%A0%B8%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><h3 id="多核操作系统"><a href="#多核操作系统" class="headerlink" title="多核操作系统"></a>多核操作系统</h3><ul><li>一个操作系统管理多个核</li><li>基本只有一个调度器 -&gt; <em><strong>每个核都有自己的调度器，但是会主动进行负载均衡</strong></em><ul><li><em><strong>每个CPU都有一个时钟中断，周期性的触发，对应的处理函数为</strong></em><code>scheduler_tick</code>，<ul><li>如果当前时间已经超过了下一次负载均衡时刻，那么<code>raise_softirq</code>,<code>(SCHED_SOFTIRQ)</code>在这个软中断中进行后续的负载均衡</li></ul></li><li>可以使用负载均衡的调度策略，让所有核负载均衡</li><li>进程可以从一个核迁移到另外一个核</li></ul></li><li>就绪列表&#x2F;等待表，等应该都是<code>perCPU</code>的变量？<em><strong>待求证</strong></em></li></ul><h3 id="运行在多个核上的操作系统"><a href="#运行在多个核上的操作系统" class="headerlink" title="运行在多个核上的操作系统"></a>运行在多个核上的操作系统</h3><ul><li>这里的标题有些歧义：实际上这些核之间的操作系统可以看作是<em><strong>没有任何关系的</strong></em><ul><li>可以共享代码段</li><li>可以共享数据</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UART - Console实现</title>
    <link href="/2024/08/10/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/Console%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/08/10/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E5%BC%80%E5%8F%91/Console%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="常用开源实现"><a href="#常用开源实现" class="headerlink" title="常用开源实现"></a>常用开源实现</h2><ul><li>letter-shell</li></ul><h2 id="上位机按下按键"><a href="#上位机按下按键" class="headerlink" title="上位机按下按键"></a>上位机按下按键</h2><ul><li>立即通过接口发送给下位机</li><li>触发下位机的接收中断</li></ul><h2 id="下位机接收中断服务例程"><a href="#下位机接收中断服务例程" class="headerlink" title="下位机接收中断服务例程"></a>下位机接收中断服务例程</h2><ul><li>读取寄存器，获取接收到的字符<ul><li>如果没有按下回车：下位机记录接收到的字符，可能会对特殊字符进行记录；接着回显接收到的字符；</li><li>按下回车：代表执行命令，下位机接收到后，将之前的接收缓存投给命令行<code>parser</code>函数，对命令行进行解析并执行相关的指令</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子文件夹测试</title>
    <link href="/2024/08/10/daily-notes/%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/08/10/daily-notes/%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>测试子文件夹中的md能不能被hexo识别。-&gt; 可以的！！！</p><ul><li>git 练习</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aarch64</title>
    <link href="/2024/08/10/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/aarch64/"/>
    <url>/2024/08/10/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/aarch64/</url>
    
    <content type="html"><![CDATA[<h2 id="异常路由"><a href="#异常路由" class="headerlink" title="异常路由"></a>异常路由</h2><p>&#x3D;&#x3D;问题&#x3D;&#x3D;： 如果某个异常发生，处理器应该使用那个人异常等级来处理这个异常？</p><h3 id="中断路由规则"><a href="#中断路由规则" class="headerlink" title="中断路由规则"></a>中断路由规则</h3><ul><li>路由到EL3：需要设置<code>SCR_EL3.&#123;EA, IRQ, FIQ&#125;</code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">MRS X0, SCR_EL3 // 读取SCR_EL3到X0寄存器<br>ORR X0, X0, #(1&lt;&lt;3) // 设置EA，将SError路由到EL_3<br>ORR X0, X0, #(1&lt;&lt;1) // 设置IRQ<br>ORR X0, X0, #(1&lt;&lt;2) // 设置FIQ<br>MSR SCR_EL3, X0<br></code></pre></td></tr></table></figure></li><li>路由到EL_2：需要设置<code>HCR_EL2.&#123;AMO, FMO, IMO&#125;</code>，并清除<code>SCR_EL3.&#123;&#125;</code></li><li>路由到EL_1：如果中断没有设置路由到EL_3，EL_2，默认路由到EL_1</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title> TRICORE</title>
    <link href="/2024/08/10/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/Tricore/"/>
    <url>/2024/08/10/%E5%B5%8C%E5%85%A5%E5%BC%8F-%E6%9E%B6%E6%9E%84/Tricore/</url>
    
    <content type="html"><![CDATA[<h2 id="任务相关"><a href="#任务相关" class="headerlink" title="任务相关"></a>任务相关</h2><h3 id="CSA"><a href="#CSA" class="headerlink" title="CSA"></a>CSA</h3><ul><li>上下文分别消耗两个CSA<ul><li>上文CSA包含：<code>SP</code>, <code>返回的下文序号</code></li><li>下文CSA包含：<code>PC</code>, <code>参数</code>, <code>绑定的上文序号</code></li></ul></li><li>每个核有一个统一的CSA池子</li></ul><h3 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h3><ul><li><code>0xC0000000</code>: 每个核的local地址，访问其本地的PSPR </li><li><code>0xD0000000</code>: local地址，访问其本地的DSPR<ul><li><code>perCPU</code>的变量链接地址在这个空间内，可以达到不同核上跑相同的代码，但是数据存取访问到的为其本地的数据副本</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式-架构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sat Aug 10 2024 00:00:00 GMT+0800 (中国标准时间)</title>
    <link href="/2024/08/10/daily-notes/2024-08-10/"/>
    <url>/2024/08/10/daily-notes/2024-08-10/</url>
    
    <content type="html"><![CDATA[<h3 id="明日计划"><a href="#明日计划" class="headerlink" title="明日计划"></a>明日计划</h3><ul><li>算法题复习</li><li>大疆真题刷一刷</li><li>投递一下字节的<code>机器人工程师</code> -&gt; 大疆笔试结束后投递</li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-基础</title>
    <link href="/2024/07/27/Linux-%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/07/27/Linux-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="四个关键概念"><a href="#四个关键概念" class="headerlink" title="四个关键概念"></a>四个关键概念</h3><ol><li><strong>文件描述符（File Descriptor）</strong>:<ul><li>文件描述符是一个非负整数，用于在程序中引用打开的文件、套接字或其他I&#x2F;O资源。</li><li>每当一个进程打开一个文件、创建一个套接字或进行其他类似的操作时，内核都会为该进程分配一个新的文件描述符。</li><li>文件描述符是进程级的，不同的进程可以有各自的文件描述符表，互不影响。</li></ul></li><li><strong>文件描述符表（File Descriptor Table）</strong>:<ul><li>每个进程都有一个文件描述符表，它是一个数组结构，数组的每个元素都指向一个文件表项。</li><li>文件描述符作为数组的索引，使得进程能够快速找到对应的文件表项。</li></ul></li><li><strong>文件表项（File Table Entry）</strong>:<ul><li>文件表项包含了关于打开文件的信息，比如文件状态标志（如只读、只写、追加等）、当前文件偏移量（即下一次读写操作的位置）等。</li><li>文件表项还包含一个指向inode的指针，这个指针用于定位文件在文件系统中的实际位置。</li><li><em><strong>同一个文件可以被多个进程打开，但每个进程都有自己的文件表项，这样可以保证每个进程对文件的操作（如偏移量）互不影响</strong></em>。</li><li>只要有打开某个文件的操作，就会生成一个文件表现</li></ul></li><li><strong>inode（索引节点）</strong>:<ul><li>inode是文件系统的核心概念之一，它包含了关于文件本身的信息，如文件大小、时间戳（创建时间、修改时间、访问时间等）、文件类型（普通文件、目录、符号链接等）等。</li><li>inode还包含了磁盘上文件数据的位置信息，比如数据块的位置。</li><li>对于不同的文件系统，inode的结构可能会有所不同，但基本原理是相似的。</li></ul></li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>一个进程中不同文件描述符可以指向同一个文件表项：通过<code>DUP</code>进行</li><li>不同进程中的不同文件描述符也可以指向同一个文件表现：通过<code>fork+dup</code>进行，fork时子进程会继承父进程的文件描述符表</li><li>不同的打开文件表现可以指向同一个inode节点：对同一个文件打开多次</li></ul><h3 id="软链接-VS-硬链接"><a href="#软链接-VS-硬链接" class="headerlink" title="软链接 VS 硬链接"></a>软链接 VS 硬链接</h3><ul><li>软连接会产生inode节点，删除软链接对源文件没有影响</li><li>硬链接指向同一个inode，每增加一个硬链接会增加节点链接数；只要节点的链接数不为0，文件就一直存在</li></ul><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a><a href="https://gnu-linux.readthedocs.io/zh/latest/Chapter03/00_link.html#id2" title="永久链接至标题">硬链接</a></h4><p>一般情况下，<em>文件名</em>和 inode 号码是”一一对应”的关系，每个 inode 号码对应一个文件名（<em>每个文件默认有一个硬链接</em>）。但是，<em><strong>Unix&#x2F;Linux 系统允许多个文件名指向同一个 inode 号码</strong></em>。</p><p>这意味着，可以用不同的文件名访问同样的内容，对文件内容进行修改后，会影响所有文件名。但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p><p><em><strong>创建一个硬链接，就会为文件创建了一个新的文件名</strong></em>。硬链接有两个重要局限性：</p><ol><li>硬链接不能链接不在同一系统的文件。也就是说硬链接不能链接与文件不在同一磁盘分区上的文件；</li><li>硬链接不能链接目录。</li></ol><p>一个硬链接和文件本身没有什么区别。当你列出一个包含硬链接的文件时，不会有特殊的链接指示说明。当一个硬链接被删除时，文件本身的内容仍然存在（也就是说，它所占的磁盘空间不会被重新分配），直到所有关联这个文件的硬链接都删掉。</p><blockquote><p>&#x3D;&#x3D;目录文件的硬链接&#x3D;&#x3D;:<br>创建目录时，默认会生成两个目录项： <code>.</code> 和 <code>..</code> 。 <code>.</code> 相当于当前目录的硬链接； <code>..</code> 相当于父目录的硬链接。所以，目录的硬链接总数，等于 2 加上它的子目录总数（含隐藏目录）。其实使用 <code>ln -d</code> 命令也允许 root 用户尝试建立目录硬链接。<br>这些都说明系统限制对目录进行硬链接只是一个硬性规定，并不是逻辑上不允许或技术上不可行。<br>&#x3D;&#x3D;为什么操作系统要进行这个限制呢&#x3D;&#x3D;？<br>由于 Linux 操作系统中的目录是以 <code>/</code> 为节点的树状结构，对目录的硬链接有可能破坏这种结构，甚至形成循环如： <code>/usr/bin -&gt; /usr/</code> ，在使用遍历目录的命令时（如： <code>ls -R</code> ）系统就会陷入无限循环中。软链接的 inode 号码不一样，所以不会出现这种问题。</p></blockquote><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>除了硬链接以外，还有一种软链接，创建软链接是为了克服硬链接的局限性。</p><p>软链接是通过创建一个特殊类型的文件（指针）链接到文件或目录。就像是 Windows 的快捷方式，当然，符号链接早于 Windows 的快捷方式很多年。</p><p>文件 A 和文件 B 的 <em>inode 号码虽然不一样</em>，但是<em><strong>文件 A 的内容是文件 B 的路径</strong></em>。读取文件 A 时，系统会自动将访问指向文件 B。因此，无论打开哪一个文件，最终读取的都是文件 B。但是，文件 A 依赖于文件 B 而存在，如果删除了文件 B，打开文件 A 就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：<em><strong>文件 A 指向文件 B的文件名，而不是文件 B 的 inode 号码</strong></em>。</p><blockquote><p>&#x3D;&#x3D;软链接的应用&#x3D;&#x3D;<br>想象这样一个情景，一个程序需要使用 foo_1.1 文件中的共享资源，由于 foo 经常改变版本号。每次升级后都得将使用 foo_1.1 的所有程序更新到 foo_1.2 文件，那么每次更新 foo 版本后，都要重复上边的工作。<br>符号链接能很好的解决这个问题。比如，创建一个 foo 的软链接指向 foo_1.2。这时，当一个程序访问 foo 时，实际上是访问 foo_1.2。当升级到 foo_1.3 时，只需要更新软链接指向。这不仅解决了版本升级问题，而且还允许在系统中保存两个不同的版本，如果 foo_1.3 有错误，再更新回原来的 foo_1.2 链接就可以。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2024/07/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://www.runoob.com/w3cnote/bubble-sort.html">十大经典排序算法</a></li><li><a href="https://cloud.tencent.com/developer/article/1182321">八大排序算法稳定性分析，原来稳定性是这个意思…</a></li></ul><h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><ul><li>排序前后两个相等的数相对位置不变，则算法稳定</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ol><li>小的元素往前调或者把大的元素往后调；</li><li>比较是相邻的两个元素比较，交换也发生在这两个元素之间；</li><li><strong>稳定排序算法</strong></li><li>排序遍历次数为<code>len - 1</code>，每次从头开始冒泡<ul><li>示例代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i, j;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)<br>                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)<br>                        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<br>                                <span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ol><li>选定的piviot必须位于开始排序的起始位置；即使选中间某个数，也要将其交换至起始位置才能开始排序</li><li>考虑&#x3D;&#x3D;占空&#x3D;&#x3D;来识记算法排序的过程<ul><li>判断起始序号  &lt; 结尾序号</li><li>第一个空位在起始位置，i</li><li>从右边找第一个小于piviot的元素，占据已有的空位；此时形成新的空位在右侧，j</li><li>接着从左边开始找第一个大于piviot的元素，占据前述空位；此时形成新的空位在左侧</li><li>重复上述查找，直至&#x3D;&#x3D;i &gt;&#x3D; j&#x3D;&#x3D;</li><li>最后，将piviot的值放在空位上</li><li>对左序列、右序列进行递归操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">swap</span>(nums[start], nums[(start+end)/<span class="hljs-number">2</span>]);<br><span class="hljs-type">int</span> piviot = nums[start];<br><span class="hljs-type">int</span> i = start, j = end;<br><span class="hljs-keyword">while</span> (i &lt; j)<br>&#123;<br><span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= piviot) --j;<br>nums[i] = nums[j];<br><span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= piviot) ++i;<br>nums[j] = nums[i];<br>&#125;<br>nums[i] = piviot;<br><span class="hljs-built_in">dfs</span>(nums, start, i<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">dfs</span>(nums, i+<span class="hljs-number">1</span>, end);<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> nums;<br>&#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP学习-超时与重传</title>
    <link href="/2024/07/24/TCP%E5%AD%A6%E4%B9%A0-%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/"/>
    <url>/2024/07/24/TCP%E5%AD%A6%E4%B9%A0-%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP超时与重传"><a href="#TCP超时与重传" class="headerlink" title="TCP超时与重传"></a>TCP超时与重传</h1><h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><ul><li>发送时设置一个定时器来解决<strong>数据</strong>和<strong>确认</strong>可能丢失的问题</li><li>如何确定超时判断间隔？</li><li>如何确定重传的频率？<ul><li>1，2，4，8， 16，32，64……</li></ul></li></ul><h2 id="典型实现"><a href="#典型实现" class="headerlink" title="典型实现"></a>典型实现</h2><ul><li>测量TCP报文段的往返时间<ul><li>这样才能比较好的确定超时时间</li><li>发出数据 -&gt; 收到ACK的时间间隔？</li></ul></li><li>使用测量结果对下一个将要传输的报文段建立重传超时时间</li></ul><h2 id="四个定时器"><a href="#四个定时器" class="headerlink" title="四个定时器"></a>四个定时器</h2><ul><li>对每个连接，TCP管理四个不同的定时器<ul><li><strong>重传定时器</strong>使用于当希望收到<u>另一端的确认</u></li><li><strong>坚持(persist)定时器</strong>使<u>窗口大小信息</u>保持不断流动，即使另一端关闭了其接收窗口</li><li><strong>保活(keepalive)定时器</strong>可检测到一个<u>空闲连接的另一端何时崩溃或重启</u></li><li><strong>2MSL定时器</strong>测量一个连接处于TIMEWAIT状态的时间</li></ul></li></ul><h2 id="往返-RTT-时间测量"><a href="#往返-RTT-时间测量" class="headerlink" title="往返(RTT)时间测量"></a>往返(RTT)时间测量</h2><ul><li>该时间在民用网络中可能是会经常变化的，因此TCP需要跟踪这些变化并相应地调整其超时时间</li></ul><h3 id="测量演进"><a href="#测量演进" class="headerlink" title="测量演进"></a>测量演进</h3><ul><li>测量某报文段和其响应之间地时间差<code>M</code>，并动态更新其RTT值；<code>RTT = k*RTT + (1-k)*M</code></li><li>超时间隔设置为<code>RTO = b*RTT</code>，b地推荐值为2</li><li><code>缺陷</code>：在RTT变化很大地场景下，无法跟踪变化，因此会引起不必要的重传</li><li><code>改进</code>：跟踪RTT的方差并进行平滑，放到RTT估计值中去</li><li><code>Karn算法</code>：当一个分组重传发生时，在重传数据的确认最后到达之前，不能更新RTT的值；这是因为收到的确认不知道对应于哪一次重传</li></ul><h2 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h2><ul><li>应对达到中间路由器转发极限的算法</li><li>假设：分组丢失意味着在源主机和目的主机之间的某处网络上发生了拥塞</li><li>两种<strong>分组丢失的指示</strong><ul><li>发生超时</li><li>接收到重复的确认 -&gt; &#x3D;&#x3D;这个在实际使用中占比达95%以上&#x3D;&#x3D;</li></ul></li><li><strong>慢启动算法</strong>可以降低分组进入网络中的速率，当拥塞发生时可以使用慢启动来做这一动作以减少网络拥塞。实际中，这两个算法通常一起实现：<ul><li>拥塞避免相关参数：cwnd（本地拥塞窗口大小）</li><li>慢启动相关参数：ssthresh（慢启动门限）</li></ul></li></ul><h3 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h3><ul><li>未发生分组丢失时，cwnd逐渐增加，增加的速率取决于cwnd和ssthresh的关系<ul><li>如果cwnd &lt;&#x3D; ssthresh，说明此时处于慢启动阶段，cwnd以指数速率增长</li><li>如果cwnd &gt; ssthresh，说明此时处于拥塞避免阶段，cwnd以固定速率增长【且一个往返时间内cwnd最多增加1】</li></ul></li><li>如果某一时刻发生了分组丢失<ul><li>ssthresh被设置为当前窗口的一半: <code>min(2, min(cwnd, 通告窗口大小))/2</code></li><li>cwnd的设置与分组丢失的原因有关：<ul><li>如果是超时引起，则cwnd &#x3D; 1</li><li>否则，被设置为？？？ -&gt; <strong>快速恢复</strong>，设置为新的ssthresh值+3个报文段大小 -&gt; 直接进入拥塞避免阶段</li></ul></li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>慢启动与拥塞避免是两个阶段</li><li>快速重传与快速恢复是绑定的操作<ul><li>丢包采用快速重传-恢复策略时，cwnd的值被设置为新的ssthresh的值+3；由于cwnd &gt; ssthresh 因此直接进入拥塞避免阶段</li></ul></li></ul><h2 id="快速重传与快速恢复"><a href="#快速重传与快速恢复" class="headerlink" title="快速重传与快速恢复"></a>快速重传与快速恢复</h2><ul><li>承接上面最后的问题，当收到<strong>3个及以上</strong>重复的确认，就非常有可能发生了报文丢失，因此重传丢失的数据报文段，无需等待超时器溢出 -&gt; <strong>快速重传</strong><ul><li>进入拥塞避免阶段，而不是慢启动  -&gt; <strong>快速恢复</strong></li></ul></li><li>收到重复的确认时，接收方一定收到了大于该确认号的数据段；否则接收方不会有任何响应，只能等待发送方超时器超时进行重传</li></ul><h3 id="流程细节【这里需要进一步的思考，记忆】"><a href="#流程细节【这里需要进一步的思考，记忆】" class="headerlink" title="流程细节【这里需要进一步的思考，记忆】"></a>流程细节【这里需要进一步的思考，记忆】</h3><ul><li>当收到第&#x3D;&#x3D;3个重复的ACK&#x3D;&#x3D;时，将&#x3D;&#x3D;ssthresh设置为当前拥塞窗口cwnd的一半&#x3D;&#x3D;。重传丢失的报文段。&#x3D;&#x3D;设置cwnd为ssthresh加上3倍的报文段大小&#x3D;&#x3D;</li><li>每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）</li><li>当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该<br>是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半</li></ul><h2 id="坚持-persist-定时器"><a href="#坚持-persist-定时器" class="headerlink" title="坚持(persist)定时器"></a>坚持(persist)定时器</h2><ul><li>当接收方通告窗口为0时，发送方将不再发送数据，直到接收方通告窗口大于0；<ul><li>但是&#x3D;&#x3D;后续接收方通告窗口大小是通过ACK进行的&#x3D;&#x3D;，然而TCP不对未带数据的ACK进行确认</li><li>如果这个ACK丢包了怎么办？-&gt; 可能会进入“死锁”</li></ul></li><li>为了解决前述提到的问题，TCP在发送端维护一个<strong>坚持(persist)定时器</strong>以周期性地向接收端查询通告窗口的大小</li></ul><h2 id="保活定时器"><a href="#保活定时器" class="headerlink" title="保活定时器"></a>保活定时器</h2><ul><li><p>保活不是TCP规范中的一部分，但是许多实现提供了保活定时器</p><ul><li>保活功能主要为服务器程序提供的；但客户机也可以开启这个功能</li><li>用于主动关闭服务器上存在的半连接【客户机非正常宕机引起】</li></ul></li><li><p>服务器端保活探测的结果</p><ul><li>如果客户机正常，则保活正常，应用程序无感</li><li>如果客户机崩溃，服务器将收不到对探查的响应，服务器应用程序将收到read接口返回的差错信息</li><li>如果客户机关闭后重启，这时客户机会给服务器发回探查响应，但是该响应为RST，使得服务器终止该连接</li><li>如果客户机对于服务器来说不可达，类似于第二种情况</li></ul></li><li><p>这里注意到：</p><ul><li>客户机程序被终止，并且发出了一个FIN，如果该FIN丢包，会重传</li><li>但是整个时间可能会比较长，而客户宿主机上对客户机程序的关闭就导致TCP连接终止异常</li><li>进而可能导致服务器上存在半连接</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-任务切换与内核栈</title>
    <link href="/2024/07/24/Linux-aarch64-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88/"/>
    <url>/2024/07/24/Linux-aarch64-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h1><ul><li><p>task_struct-&gt;stack成员指向的内存空间就是内核栈</p></li><li><p>陷入内核时，用户任务上下文保存在其内核栈上：<strong>且保存的位置也是固定的，就在内核栈空间最上方预留的的pt_regs区域</strong></p><ul><li>参考《vectors.md》种entry_handler的定义：<code>movx0, sp; blel\el\ht\()_\regsize\()_\label\()_handler</code></li><li>参考 <code>kernel_entry</code>宏的定义中，用户上下文的保存 <code>...; stpx2, x3, [sp, #16 * 1]; ...</code></li><li>综合可知，用户任务上下文保存在<strong>当前内核栈指针的上方</strong></li><li>因此，进程工作在用户态时，其内核栈指针应始终指向内核栈空间最高处-sizeof(pt_regs)处？<strong>这里可能会有些问题</strong><ul><li>刚创建该任务，而且还没有被调度运行时，应该是这样的</li></ul></li><li><strong>但是当该任务被调度运行后</strong>：<ol><li>首先在内核态切换到该任务的内核栈：首次切换到内核栈初期【汇编码范围内】sp确实指向了<code>内核栈空间最高处-sizeof(pt_regs)</code></li><li>接着执行部分内核态代码，此时会有入&#x2F;出栈操作<ul><li>这里要注意：首次进入内核态后，之后会向普通函数调用那样，借助<code>lr</code>寄存器进行函数返回</li><li>注意到任务创建时，任务结构体中固定位置处【保存内核态上下文的结构】将<strong>pc &#x3D; ret_from_fork</strong>，因此任务首次被调度执行 -&gt; 首次进入内核态时执行的第一个比较重要的函数就是<code>ret_from_fork</code></li></ul></li><li>如果任务在内核态被抢占 -&gt; 仍然要把内核态上下文保存到任务结构体的固定位置处？</li><li>之后该任务恢复后，依然继续之前内核态的执行</li><li>再之后需要从内核态返回用户空间：<code>ret_to_user/ret_to_fork</code>: 这里面需要把内核栈上保存的用户空间上下文恢复</li><li>需要区分对待第一次返回到用户空间&#x2F;第二次返回到用户空间：因为第一次返回时内核栈上没有保存的用户上下文？<ul><li>这里还需要再深入看一下创建任务时，有没有为内核栈模拟保存的用户空间上下文！！！？？？❗️❗️</li><li>深入看一下<code>ret_from_fork</code></li></ul></li></ol></li></ul></li><li><p>任务切换时，内核态上下文保存在任务结构体的固定位置处：THREAD_CPU_CONTEXT</p><ul><li>新建任务时，要把其内核栈地址放在其任务结构体成员cpu_context.sp处；-&gt; 再去看一下新建任务时，sp的赋值情况，就可以探索出内核栈的初始内存分配情况；</li><li>根据上面的叙述：<code>要把用户上下文保存在内核栈上方【高地址】位置处</code>，因此在初始创建内核栈时，要注意这一点！！！</li><li>要注意：创建任务时，其tsk-&gt;thread.cpu_context.sp要向内核栈空间最高地址 - 足够的空间容纳pt_regs：<em><strong>与后面的代码走读匹配了</strong></em>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">DEFINE(THREAD_CPU_CONTEXT,offsetof(<span class="hljs-keyword">struct</span> task_struct, thread.cpu_context));<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ......<br>    <span class="hljs-type">void</span>   *<span class="hljs-built_in">stack</span>;      <span class="hljs-comment">// 通过查找，明确了这里为task的内核栈?栈顶（往下增长）</span><br><br>    <span class="hljs-comment">/* CPU-specific state of this task: */</span><br>    <span class="hljs-comment">// 这是一个架构相关的结构体</span><br>    <span class="hljs-comment">// 这个成员位于任务结构体的末尾</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span><span class="hljs-title">thread</span>;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * WARNING: on x86, &#x27;thread_struct&#x27; contains a variable-sized</span><br><span class="hljs-comment">    * structure.  It *MUST* be at the end of &#x27;task_struct&#x27;.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * Do not put anything below here!</span><br><span class="hljs-comment">    */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu_context</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x19;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x20;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x21;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x22;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x23;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x24;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x25;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x26;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x27;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x28;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pc;<br>&#125;; <br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="最终的寄存器、栈切换"><a href="#最终的寄存器、栈切换" class="headerlink" title="最终的寄存器、栈切换"></a>最终的寄存器、栈切换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// in file: arch\arm64\kernel\entry.S</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Register switch for AArch64. The callee-saved registers need to be saved</span><br><span class="hljs-comment">* and restored. On entry:</span><br><span class="hljs-comment">*   x0 = previous task_struct (must be preserved across the switch)</span><br><span class="hljs-comment">*   x1 = next task_struct</span><br><span class="hljs-comment">* Previous and next are guaranteed not to be the same.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br>SYM_FUNC_START(cpu_switch_to)<br>    movx10, #THREAD_CPU_CONTEXT<br>    addx8, x0, x10<br>    movx9, sp                  <span class="hljs-comment">// 这里将prev的内核栈地址保存到x9寄存器</span><br>    stpx19, x20, [x8], #<span class="hljs-number">16</span><span class="hljs-comment">// store callee-saved registers</span><br>    stpx21, x22, [x8], #<span class="hljs-number">16</span><br>    stpx23, x24, [x8], #<span class="hljs-number">16</span><br>    stpx25, x26, [x8], #<span class="hljs-number">16</span><br>    stpx27, x28, [x8], #<span class="hljs-number">16</span><br>    stpx29, x9, [x8], #<span class="hljs-number">16</span>      <span class="hljs-comment">// 这里将内核栈当前指针保存到x8寄存器的值指示的地址处</span><br>    strlr, [x8]                <span class="hljs-comment">// 这里将lr寄存器的值保存到...</span><br>    addx8, x1, x10<br>    ldpx19, x20, [x8], #<span class="hljs-number">16</span><span class="hljs-comment">// restore callee-saved registers</span><br>    ldpx21, x22, [x8], #<span class="hljs-number">16</span><br>    ldpx23, x24, [x8], #<span class="hljs-number">16</span><br>    ldpx25, x26, [x8], #<span class="hljs-number">16</span><br>    ldpx27, x28, [x8], #<span class="hljs-number">16</span><br>    ldpx29, x9, [x8], #<span class="hljs-number">16</span>      <span class="hljs-comment">// 从这里可以看出，新建任务时，要把其内核栈地址放在其任务结构体成员cpu_context.sp处</span><br>    ldrlr, [x8]                <span class="hljs-comment">// -&gt; 再去看一下新建任务时，sp的赋值情况，就可以探索出内核栈的初始内存分配情况；</span><br>    movsp, x9                  <span class="hljs-comment">// 这里将sp的值更新为待切换任务的内核栈</span><br>    msrsp_el0, x1              <span class="hljs-comment">// 这里将sp_el0的值更新为待切换任务的任务结构体，供后续current()使用</span><br>    ptrauth_keys_install_kernel x1, x8, x9, x10<br>    scs_save x0<br>    scs_load_current<br>    ret                         <span class="hljs-comment">// 这里ret执行正常的借助lr的返回，因此返回到调用cpu_switch_to()的下一条指令</span><br>SYM_FUNC_END(cpu_switch_to)<br>NOKPROBE(cpu_switch_to)<br><br><br><span class="hljs-comment">// in file: arch\arm64\kernel\process.c</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Thread switching.</span><br><span class="hljs-comment">*/</span><br>__notrace_funcgraph __sched<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *__<span class="hljs-title">switch_to</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">prev</span>,</span><br><span class="hljs-class">                <span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">next</span>)</span><br><span class="hljs-class">&#123;</span><br>    ......<br>    <span class="hljs-comment">/* the actual thread switch */</span><br>    last = cpu_switch_to(prev, next);<br><br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="内核栈构建"><a href="#内核栈构建" class="headerlink" title="内核栈构建"></a>内核栈构建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: kernel\fork.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alloc_thread_stack_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-type">int</span> node)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *<span class="hljs-built_in">stack</span>;<br><span class="hljs-built_in">stack</span> = kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);<br><span class="hljs-built_in">stack</span> = kasan_reset_tag(<span class="hljs-built_in">stack</span>);<br>tsk-&gt;<span class="hljs-built_in">stack</span> = <span class="hljs-built_in">stack</span>;                 <span class="hljs-comment">// 这里申请内核栈，并将地址赋给任务结构体的stack指针</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span> ? <span class="hljs-number">0</span> : -ENOMEM;<br>&#125;<br><br><span class="hljs-comment">// in file: arch\arm64\include\asm\processor.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> task_pt_regs(p) \</span><br><span class="hljs-meta">((struct pt_regs *)(THREAD_SIZE + task_stack_page(p)) - 1)</span><br><br><span class="hljs-comment">// in file: include\linux\sched\task_stack.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> task_stack_page(task)((void *)(task)-&gt;stack)</span><br><br><span class="hljs-comment">// in file: arch\arm64\kernel\process.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">copy_thread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *p, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> kernel_clone_args *args)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span> *<span class="hljs-title">childregs</span> =</span> task_pt_regs(p);<br>    <span class="hljs-built_in">memset</span>(&amp;p-&gt;thread.cpu_context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> cpu_context));<br><br>    ...<br><br>p-&gt;thread.cpu_context.pc = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ret_from_fork;<br>p-&gt;thread.cpu_context.sp = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)childregs;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>仅考虑栈向低地址增长</strong>；结合前面两个宏可以知道：<ul><li>tsk-&gt;stack 指向申请的内核栈空间的起始地址【低地址】</li><li>childregs 指向该内核栈空间的最高地址 - sizeof(struct pt_regs)</li><li><code>p-&gt;thread.cpu_context.sp = (unsigned long)childregs</code>这一行就使得新创建任务的内核栈地址处在内核栈空间的高位，且其上方有一个(struct pt_regs)空间，用于存储用户上下文</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-中断处理初期汇编</title>
    <link href="/2024/07/23/Linux-aarch64-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%88%9D%E6%9C%9F%E6%B1%87%E7%BC%96/"/>
    <url>/2024/07/23/Linux-aarch64-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%88%9D%E6%9C%9F%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h2 id="中断处理初期汇编码-dup2分析"><a href="#中断处理初期汇编码-dup2分析" class="headerlink" title="中断处理初期汇编码&amp;dup2分析"></a>中断处理初期汇编码&amp;dup2分析</h2><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul><li><a href="https://www.cnblogs.com/niezhongle/p/11088658.html">ARM-GNU常用汇编伪指令</a></li><li><a href="https://blog.csdn.net/jasonactions/article/details/115689462">ARM64底层中断处理</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>kernel_ventry : el 0 64 sync<ul><li>el0t_64_sync<ul><li>kernel_entry \el -&gt; 保存异常处理的现场[x0-29, lr, sp(sp_el0&#x2F;1), pc(elr_el1), pstate(spsr_el1)]到当前sp<code>sp_el1，即当前task的内核栈</code>指向的地址处。因此，可以知道 -&gt; 在进行任务切换时，内核应该会把sp_el0的值设置为待切换到的task的内核栈地址。此外，这里还会使用sp_el0存储当前用户态任务的task_struct数据的地址，供get_current()使用<ul><li>el0t_64_sync_handler(struct pt_regs* regs), 这里的参数就使用当前的sp+sizeof(pt_regs)了</li></ul></li></ul></li></ul></li></ul><h3 id="Linux-dup2-的实现中，current返回的为什么是task-struct"><a href="#Linux-dup2-的实现中，current返回的为什么是task-struct" class="headerlink" title="Linux dup2()的实现中，current返回的为什么是task_struct?"></a>Linux dup2()的实现中，current返回的为什么是task_struct?</h3><ul><li>根据下面的分析可知<ul><li><p>异常发生时，在第一阶段的处理<code>macro: kernel_entry</code>中，将当前用户态任务结构体的地址保存到了sp_el0寄存器中</p></li><li><p>根据之后的分析可知：dup2的作用为：把当前进程文件描述符表中oldfd的文件表项指针复制到newfd所在的文件描述符表项</p></li></ul></li></ul><ul><li>相关代码  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE2(dup2, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, oldfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, newfd)<br>&#123;<br>    <span class="hljs-keyword">if</span> (unlikely(newfd == oldfd)) &#123; <span class="hljs-comment">/* corner case */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span> =</span> current-&gt;files;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>        <span class="hljs-type">int</span> retval = oldfd;<br><br>        rcu_read_lock();<br>        f = __fget_files_rcu(files, oldfd, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (!f)<br>            retval = -EBADF;<br>        rcu_read_unlock();<br>        <span class="hljs-keyword">if</span> (f)<br>            fput(f);<br>        <span class="hljs-keyword">return</span> retval;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ksys_dup3(oldfd, newfd, <span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* We don&#x27;t use read_sysreg() as we want the compiler to cache the value where</span><br><span class="hljs-comment">* possible.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-keyword">struct</span> task_struct *<span class="hljs-title function_">get_current</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sp_el0;<br>    <span class="hljs-comment">// 这里使用mrs寄存器读sp_el0，它的当前值为什么指向了被中断的task?</span><br>    <span class="hljs-comment">// 按照目前的理解：sp_el0为用户态的栈指针，是在变化的；而对应的task_struct的地址应该是一个确定的值！</span><br>    <span class="hljs-comment">// 两者是怎么对应起来的？</span><br>    <span class="hljs-keyword">asm</span> (<span class="hljs-string">&quot;mrs %0, sp_el0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (sp_el0));<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> task_struct *)sp_el0;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> current get_current()</span><br></code></pre></td></tr></table></figure></li><li>疑惑探索<ul><li><p>.req 汇编伪指令</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">/* GPRs used by entry code */<br>tsk.reqx28// current thread_info<br>// 伪汇编：name .req register_name -&gt; 为寄存器定义一个别名<br></code></pre></td></tr></table></figure></li><li><p>stp指令：stp reg1, reg2, ptr_: 将寄存器reg1, reg2的值存储到ptr_指示的地址中</p></li><li><p>ldr_this_cpu 汇编宏: \arch\arm64\include\asm\assembler.h<br>  作用为加载percpu的变量值到dst</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">/*<br>* @dst: Result of READ_ONCE(per_cpu(sym, smp_processor_id()))<br>* @sym: The name of the per-cpu variable<br>* @tmp: scratch register<br>*/<br>.macro ldr_this_cpu dst, sym, tmp<br>adr_l\dst, \sym<br>get_this_cpu_offset \tmp<br>ldr\dst, [\dst, \tmp]<br>.endm<br></code></pre></td></tr></table></figure></li><li><p>__entry_task: percpu变量，用于记录当前执行的用户task_struct</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* We store our current task in sp_el0, which is clobbered by userspace. Keep a</span><br><span class="hljs-comment">* shadow copy so that we can restore this upon entry from userspace.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* This is *only* for exception entry from EL0, and is not valid until we</span><br><span class="hljs-comment">* __switch_to() a user task.</span><br><span class="hljs-comment">*/</span><br>DEFINE_PER_CPU(<span class="hljs-keyword">struct</span> task_struct *, __entry_task);<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">entry_task_switch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *next)</span><br>&#123;<br>    <span class="hljs-comment">// 这里可以看到，每次切换任务时，都会将该percpu变量的值更新为待切换任务的task_struct地址</span><br>    __this_cpu_write(__entry_task, next);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>pt_regs：软件保护的异常现场结构：arch\arm64\include\asm\ptrace.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* This struct defines the way the registers are stored on the stack during an</span><br><span class="hljs-comment">* exception. Note that sizeof(struct pt_regs) has to be a multiple of 16 (for</span><br><span class="hljs-comment">* stack alignment). struct user_pt_regs must form a prefix of struct pt_regs.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_pt_regs</span> <span class="hljs-title">user_regs</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            u64 regs[<span class="hljs-number">31</span>];<br>            u64 sp;<br>            u64 pc;<br>            u64 pstate;<br>        &#125;;<br>    &#125;;<br>    u64 orig_x0;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __AARCH64EB__</span><br>    u32 unused2;<br>    s32 syscallno;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    s32 syscallno;<br>    u32 unused2;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    u64 sdei_ttbr1;<br>    <span class="hljs-comment">/* Only valid when ARM64_HAS_GIC_PRIO_MASKING is enabled. */</span><br>    u64 pmr_save;<br>    u64 stackframe[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">/* Only valid for some EL1 exceptions. */</span><br>    u64 lockdep_hardirqs;<br>    u64 exit_rcu;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>kernel_entry宏解析: 位于el0&#x2F;1t_64_sync&#x2F;irq中</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs asm">.macrokernel_entry, el, regsize = 64<br>.if\el == 0<br>alternative_insn nop, SET_PSTATE_DIT(1), ARM64_HAS_DIT<br>.endif<br>.if\regsize == 32<br>movw0, w0// zero upper 32 bits of x0<br>.endif<br>stpx0, x1, [sp, #16 * 0]   // 从用户态陷入内核时触发el0t_sync/irq，因此当前的sp已经指向了sp_el1<br>stpx2, x3, [sp, #16 * 1]   // 接上，此时sp_el1应该指向当前任务的内核栈：应该有一种机制在任务切换时，将sp_el1设置为待切换任务的内核栈<br>stpx4, x5, [sp, #16 * 2]<br>stpx6, x7, [sp, #16 * 3]<br>stpx8, x9, [sp, #16 * 4]<br>stpx10, x11, [sp, #16 * 5]<br>stpx12, x13, [sp, #16 * 6]<br>stpx14, x15, [sp, #16 * 7]<br>stpx16, x17, [sp, #16 * 8]<br>stpx18, x19, [sp, #16 * 9]<br>stpx20, x21, [sp, #16 * 10]<br>stpx22, x23, [sp, #16 * 11]<br>stpx24, x25, [sp, #16 * 12]<br>stpx26, x27, [sp, #16 * 13]<br>stpx28, x29, [sp, #16 * 14]<br><br>.if\el == 0<br>clear_gp_regs<br>mrsx21, sp_el0                             // 这里获取用户态的栈指针<br>ldr_this_cputsk, __entry_task, x20      // 加载percpu变量，用于记录当前执行的用户task_struct<br>msrsp_el0, tsk                             // 将tsk的值加载到sp_el0，供后续get_current()使用<br>...<br>scs_load_current<br>.else                       // 注意这里.else处理异常发生在内核态的情况<br>addx21, sp, #PT_REGS_SIZE  // 栈没有发生切换，因此栈底直接+保存的pt_regs的大小即可<br>get_current_task tsk        // 获取当前正在执行的任务；直接取sp_el0获取，因为之前一定发生过用户态陷入内核态的操作<br>.endif /* \el == 0 */<br>mrsx22, elr_el1            // 异常发生时，硬件将异常返回地址保存到了elr_elx寄存器中。同步异常：当前地址；异步：next<br>mrsx23, spsr_el1           // 异常发生时，硬件将PSTATE值保存到spsr_elx，用于异常返回时，恢复PE的状态<br>stplr, x21, [sp, #S_LR]    // 对于用户态陷入内核的情况，此时x21保存的是sp_el0，即用户态栈地址。lr保存到x[30], x21保存到sp<br>...<br>stpx22, x23, [sp, #S_PC]   // 保存elr_el1, spsr_el1到内核栈的相应栈帧位置处<br>...<br>/*<br>* Registers that may be useful after this macro is invoked:<br>*<br>* x20 - ICC_PMR_EL1<br>* x21 - aborted SP<br>* x22 - aborted PC<br>* x23 - aborted PSTATE<br>*/<br>.endm<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP学习-MISC</title>
    <link href="/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-MISC/"/>
    <url>/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-MISC/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP学习（misc）"><a href="#TCP学习（misc）" class="headerlink" title="TCP学习（misc）"></a>TCP学习（misc）</h1><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul><li>《TCPIP详解：卷1》</li></ul><h2 id="TCP概览-可靠性"><a href="#TCP概览-可靠性" class="headerlink" title="TCP概览 - 可靠性"></a>TCP概览 - 可靠性</h2><h3 id="应用数据被分割成TCP认为最适合发送的数据块；如何确定合适的数据块长度？【18-4】"><a href="#应用数据被分割成TCP认为最适合发送的数据块；如何确定合适的数据块长度？【18-4】" class="headerlink" title="应用数据被分割成TCP认为最适合发送的数据块；如何确定合适的数据块长度？【18.4】"></a>应用数据被分割成TCP认为最适合发送的数据块；如何确定合适的数据块长度？【18.4】</h3><h3 id="TCP发出一个段后启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；【21章：自适应超时及重传机制】"><a href="#TCP发出一个段后启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；【21章：自适应超时及重传机制】" class="headerlink" title="TCP发出一个段后启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；【21章：自适应超时及重传机制】"></a>TCP<strong>发出一个段后启动一个定时器</strong>，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；【21章：自适应超时及重传机制】</h3><h3 id="延迟确认：收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒【19-3】"><a href="#延迟确认：收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒【19-3】" class="headerlink" title="延迟确认：收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒【19.3】"></a><strong>延迟确认</strong>：收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒【19.3】</h3><ul><li>用处<ul><li>主要为了将该ACK与后续可能需要的数据传送放到一起，减小网络负载【数据捎带ACK】</li><li>绝大多数实现采用的时延为200ms：但是这里的定时器并不是从接收到数据开始定时，而是<code>连接建立之后创建的200ms周期定时器</code></li></ul></li></ul><h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><ul><li>该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去</li><li>可以使用<code>TCPNODELAY</code>选项来关闭Nagle算法</li></ul><h3 id="报文重排【根据TCP中的序列号】"><a href="#报文重排【根据TCP中的序列号】" class="headerlink" title="报文重排【根据TCP中的序列号】"></a>报文重排【根据TCP中的序列号】</h3><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul><li>接收端有接收缓冲区【大小有限】：如果发端发的太快，接收端来不及处理，缓冲区剩余可用空间就会一直减小，直至接收缓冲区满；满了之后，接收端不能再接收新的报文，因为旧的报文还没有处理完，不能进行换出操作；因此需要进行流量控制，以调节发端的发送速度</li><li>窗口大小为字节数；起始于接收端发送报文的确认序号：因为确认序号之前的字节流已经确认收到，可以从接收端的接收缓存中换出</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP学习-3</title>
    <link href="/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-3/"/>
    <url>/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-3/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP学习（三）"><a href="#TCP学习（三）" class="headerlink" title="TCP学习（三）"></a>TCP学习（三）</h1><ul><li>滑动窗口是相对于确认号开始的</li></ul><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><ul><li>核心点：新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作</li><li>拥塞窗口【给发送方使用，cwnd】</li><li>发送方使用拥塞窗口与<strong>通告</strong>窗口的最小值作为发送上限：<ul><li>拥塞窗口是发送方使用的流量控制：大小根据接收到的ACK数量指数增加，会与<strong>延迟确认</strong>冲突嘛？</li><li>通告窗口则是接收方使用的流量控制</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP学习-2</title>
    <link href="/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-2/"/>
    <url>/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-2/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP学习（二）"><a href="#TCP学习（二）" class="headerlink" title="TCP学习（二）"></a>TCP学习（二）</h1><h2 id="连接建立-三次握手-沟通双方的初始序列号"><a href="#连接建立-三次握手-沟通双方的初始序列号" class="headerlink" title="连接建立 - 三次握手 - 沟通双方的初始序列号"></a>连接建立 - 三次握手 - 沟通双方的初始序列号</h2><ul><li>请求端发送SYN段，包含<strong>发端初始序号（ISN-C）</strong>，以及服务器端口，MSS</li><li>服务器通过发送SYN进行响应：包含<strong>收端初始序号(ISN-S)<strong>，ACK被设置为1作为对请求端SYN的确认，</strong>确认序号 &#x3D; ISN-C + 1</strong>， MSS</li><li>请求端发送ACK，响应服务器的SYN：ACK被设置为1作为对服务器SYN的确认，<strong>确认序号 &#x3D; ISN-S + 1</strong></li></ul><p>此外，连接建立的过程还会沟通MSS的具体数值，以避免分片的产生；但是只能沟通收发两端，无法避免链路中间节点的分片行为；此时就需要路径上的MTU发现机制</p><h2 id="连接终止-四次挥手"><a href="#连接终止-四次挥手" class="headerlink" title="连接终止 - 四次挥手"></a>连接终止 - 四次挥手</h2><h3 id="全关闭-主动关闭-被动关闭"><a href="#全关闭-主动关闭-被动关闭" class="headerlink" title="全关闭 - 主动关闭 + 被动关闭"></a>全关闭 - 主动关闭 + 被动关闭</h3><p>发送第一个FIN的一方将执行主动关闭，而另一方执行被动关闭</p><ul><li>A首先发送FIN，包含序列号<code>seq-A</code>；</li><li>B收到该FIN后，返回确认：ACK被设置为1，确认序列号为<code>seq-A + 1</code>;    -&gt; 由TCP协议栈内部逻辑处理进行发送<br>一般地，B会向其应用程序递送一个EOF【文件结束符】，接着B的应用程序就关闭该TCP连接，导致</li><li>B主动发一个FIN，序号为<code>seq-B</code>;</li><li>A收到该FIN后，返回确认：ACK被设置为1，确认序列号为<code>seq-B + 1</code>;    -&gt; 由TCP协议栈内部逻辑处理进行发送</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>可以看到，终止的过程和建立的过程在第一次回复时略有不同：<ul><li>连接时，第一次回复带有SYN信息，用于沟通B端的初始序列号</li><li>终止时，第一次回复仅是简单的回复 -&gt; 是否可能将第二次FIN与第一次ACK进行压缩呢？</li></ul></li></ul><h3 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h3><ul><li>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这就是所谓的半关闭；需要注意，TCP是双向连接的，因此可以只关闭单方向的连接，而发送FIN的一端即主动关闭该方-&gt;对方的数据发送通道，但是对方数据发送-本地数据接收还是正常的</li><li><u>为了使用这个特性</u>，必须为用户提供一个编程接口，且该接口表明：我已经完成了数据传送，因此发送一个文件结束(FIN)给另一端，但我还想接收另一端发来的数据，直到它给我发来文件结束(FIN)</li><li>如果应用程序不调用close而调用<code>shutdown</code>，且第2个参数值为1，则插口的API支持半关闭。然而，大多数的应用程序通过调用<code>close</code>终止两个方向的连接</li></ul><h2 id="建立与终止过程中的状态迁移"><a href="#建立与终止过程中的状态迁移" class="headerlink" title="建立与终止过程中的状态迁移"></a>建立与终止过程中的状态迁移</h2><ul><li><p>参考《TCPIP详解：卷1》18.6节</p></li><li><p>关闭时：</p><ul><li>被动关闭：接收到FIN，则进入<code>close_wait</code>状态，等待本地应用程序关闭socket，进而发送FIN进入<code>last_ack</code>状态，等待对端的ACK；接收到ACk后，连接被彻底关闭</li><li>主动关闭：<ul><li>应用进程主动调用<code>close()</code>等关闭连接，首先发送FIN，进入<code>fin_wait_1</code>状态；</li><li>收到对端的ack后，进入<code>fin_wait_2</code>状态；</li><li>之后等待对端发送FIN，进而回复ACK，进入<code>time_wait</code>状态</li><li>2MSL（报文段最大生存时间）后，连接彻底关闭</li></ul></li></ul></li><li><p>2MSL等待状态</p><ul><li>MSL：报文段最大生存时间MSL（Maximum Segment Lifetime）</li><li>该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）</li><li>在连接处于2MSL等待时，任何迟到的报文段将被丢弃</li><li>只有主动关闭连接的一端会进入该状态；而且服务器端，客户端都可以主动关闭连接</li></ul></li><li><p><strong>当有多个连接请求时</strong></p><ul><li>服务器来不及处理这么多连接请求，将会把完成三次握手的连接放到内核中的连接队列中</li><li>如果队列已经满了，则服务器端TCP协议栈将不理会新来的SYN报文，也不会发回RST</li><li>因此后续客户端会重传其SYN，直至与服务器完成连接的建立</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP学习-1</title>
    <link href="/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP学习（一）"><a href="#TCP学习（一）" class="headerlink" title="TCP学习（一）"></a>TCP学习（一）</h1><ul><li><p>TCP只对含有数据的ACK进行确认【发端超时重传】；单独的ACK不会发送不会设置超时定时器</p><ul><li>因此TCP要考虑每个阶段中可能出现的ACK丢失的情况！！！</li></ul></li><li></li></ul><h2 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h2><ul><li><p>通过头部的控制位（6bit）区分不同的报文类型：</p><ul><li>SYN报文：用于建立连接，包含SYN标志    -&gt; <strong>需要占用一个序号</strong>；其中包含<strong>最大报文段长度</strong>信息，且该信息只能出现在SYN中</li><li>ACK报文：用于确认接收到的数据，包含ACK标志    -&gt; 为1时，4Bytes的确认序号字段才有有用；连接一旦建立，该位总是被置为1</li><li>FIN报文：用于结束连接，包含FIN标志    -&gt; <strong>需要占用一个序号</strong>，发端完成发送任务</li><li>RST报文：用于重置连接，包含RST标志</li><li>PSH报文：用于推送数据，包含PSH标志    -&gt; 接收方应尽快把这个报文段交给应用层</li><li>URG报文：用于紧急数据，包含URG标志</li><li>数据报文：包含实际的数据，不包含任何控制位</li></ul></li><li><p>连接建立、终止，超时处理过程中涉及到的报文，大多都是不带数据的报文【控制报文】</p></li><li><p><strong>最大报文段长度（MSS）</strong>信息【首部可选项】，只能出现在SYN中；该信息是沟通双方可以协商确定的；为了不在IP层产生分片，MSS最大为1460（RFC以太网）</p></li></ul><h2 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h2><ul><li>序号：标识从TCP发端向TCP收端发送的数据字节流，它表示在<strong>这个报文段中的的第一个数据字节</strong>。是32bit的无符号数，序号到达2^32-1后又从0开始;<ul><li>那么该条报文数据字段包含的序号范围就是可以计算的了 -&gt; 根据数据负载的长度</li></ul></li></ul><h2 id="分片机制"><a href="#分片机制" class="headerlink" title="分片机制"></a>分片机制</h2><ul><li>注意IP层是有分片机制的<ul><li>IP头部指示总长度的字段占16bits，因此IP报文最大长度为65535Bytes;</li><li>IP<strong>只有针对首部</strong>的校验和</li></ul></li><li>TCP也是有分片机制的：而且一般需要将TCP每帧报文长度控制在IP层MTU范围以内，防止产生IP层分片 -&gt; √<ul><li>TCP报文的长度有限制吗？有长度指示域嘛？ -&gt; 首部没有长度指示位域</li><li>TCP的校验和<strong>覆盖首部和数据</strong>：且收端检测到校验和时，不会确认接收该报文，等待发端触发超时重传</li><li>有IP层分片也可以，只是如果某个IP片丢失后，整个IP报文都会被丢弃，进而导致上层协议重传一整个丢失的报文</li><li>如果使用上层的分片机制，可以将长数据报文分割成多个小的片段；当某一个小的片段丢失后，只需要重传那个丢失的分片报文就可以</li></ul></li></ul><h2 id="IP层路由"><a href="#IP层路由" class="headerlink" title="IP层路由"></a>IP层路由</h2><ul><li>需要注意主机IP地址由网络号，子网号和主机号组成，且主机号不能为0<ul><li>网络号，主要由A，B，C等几类地址而来</li><li>子网号，针对每一个特定的网络号，可以划分为很多子网</li><li>主机号，该子网内的所有真实主机的IP</li></ul></li></ul><h3 id="IP层从某个网络接口接收到报文"><a href="#IP层从某个网络接口接收到报文" class="headerlink" title="IP层从某个网络接口接收到报文"></a>IP层从某个网络接口接收到报文</h3><ul><li>如果该IP报文的目的地址为本机IP地址之一【本机可能有多个IP地址】或者为IP广播地址，则将该IP报文上传给由IP首部协议字段指定的上层协议模块进行处理</li><li>否则，<ul><li>如果机器没有IP路由功能，则将该IP报文丢弃</li><li>如果该机器开启了IP路由功能，则对报文进行转发【类似于本机器发出IP报文】</li></ul></li><li>匹配路由表顺序【IP报文的目的地址与路由表的目的地址字段】：<ul><li>全匹配：</li><li>网段匹配：</li><li>默认条目</li></ul></li><li>如果以上都不能匹配成功，那么数据包就不能被传送：<ul><li>如果该数据报是本机发送的，那么一般IP层会向发送该数据报的上层应用通知：“主机不可达”或者“网络不可达”</li></ul></li></ul><h3 id="路由表内容"><a href="#路由表内容" class="headerlink" title="路由表内容"></a>路由表内容</h3><ul><li>目的IP地址：可以为主机地址，也可以为网络地址【网段地址】</li><li>下一跳路由器【有直接网口相连的主机】的IP地址：</li><li>标志：1. 目的地址是网络地址还是主机地址；2. 下一跳为路由器，还是有直接网口相连的主机</li><li>为数据报的发送指定一个网络接口【卡】，即数据报文将从本机的哪一个网络接口发送出去</li></ul><h2 id="RST报文使用场景"><a href="#RST报文使用场景" class="headerlink" title="RST报文使用场景"></a>RST报文使用场景</h2><ul><li>到不存在端口的连接请求</li><li>异常终止一个连接：可以发送RST而不是FIN来中途释放一个连接</li><li>检测半打开连接</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-Macros</title>
    <link href="/2024/07/22/Linux-Macros/"/>
    <url>/2024/07/22/Linux-Macros/</url>
    
    <content type="html"><![CDATA[<h1 id="常用宏"><a href="#常用宏" class="headerlink" title="常用宏"></a>常用宏</h1><ul><li>WRITE_ONCE &amp;&amp; READ_ONCE<ul><li>从__native_word的定义可以看出，所谓的原子读写并不能保证，只是尽可能地避免</li><li>对一个10字节的数据进行读写，肯定要分成2次以上的内存访问操作</li><li>如果为一个原始类型：char, short, int, long, long long，对其进行读写操作就只产生一次内存访问</li><li>有些需要避免竞态的，需要加锁  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Yes, this permits 64-bit accesses on 32-bit architectures. These will</span><br><span class="hljs-comment">* actually be atomic in some cases (namely Armv7 + LPAE), but for others we</span><br><span class="hljs-comment">* rely on the access being split into 2x32-bit accesses for a 32-bit quantity</span><br><span class="hljs-comment">* (e.g. a virtual address) and a strong prevailing wind.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> compiletime_assert_rwonce_type(t)\</span><br><span class="hljs-meta">    compiletime_assert(__native_word(t) || sizeof(t) == sizeof(long long),\</span><br><span class="hljs-meta">        <span class="hljs-string">&quot;Unsupported access size for &#123;READ,WRITE&#125;_ONCE().&quot;</span>)</span><br><br><span class="hljs-comment">/* Is this type a native word size -- useful for atomic operations */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __native_word(t) \</span><br><span class="hljs-meta">    (sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \</span><br><span class="hljs-meta">    sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Use __READ_ONCE() instead of READ_ONCE() if you do not require any</span><br><span class="hljs-comment">* atomicity. Note that this may result in tears!</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __READ_ONCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __READ_ONCE(x)(*(const volatile __unqual_scalar_typeof(x) *)&amp;(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_ONCE(x)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    compiletime_assert_rwonce_type(x);\</span><br><span class="hljs-meta">    __READ_ONCE(x);\</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __WRITE_ONCE(x, val)\</span><br><span class="hljs-meta">do &#123;\</span><br><span class="hljs-meta">    *(volatile typeof(x) *)&amp;(x) = (val);\</span><br><span class="hljs-meta">&#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITE_ONCE(x, val)\</span><br><span class="hljs-meta">do &#123;\</span><br><span class="hljs-meta">    compiletime_assert_rwonce_type(x);\</span><br><span class="hljs-meta">    __WRITE_ONCE(x, val);\</span><br><span class="hljs-meta">&#125; while (0)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="标量类型（scalar-type）"><a href="#标量类型（scalar-type）" class="headerlink" title="标量类型（scalar type）"></a>标量类型（scalar type）</h1><ul><li>指那些不能被分解成更小的部分的数据类型，如整型（如 int、long、short 等）、浮点型（如 float、double 等）和字符型（如 char）。标量类型与复合类型相对，复合类型是由多个标量类型或其他复合类型组合而成的数据类型，如结构体（struct）、联合体（union）和数组。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving</span><br><span class="hljs-comment">*       non-scalar types unchanged.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Prefer C11 _Generic for better compile-times and simpler code. Note: &#x27;char&#x27;</span><br><span class="hljs-comment">* is not type-compatible with &#x27;signed char&#x27;, and we define a separate case.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __scalar_type_to_expr_cases(type)\</span><br><span class="hljs-meta">        unsigned type:(unsigned type)0,\</span><br><span class="hljs-meta">        signed type:(signed type)0</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __unqual_scalar_typeof(x) typeof(\</span><br><span class="hljs-meta">        _Generic((x),\</span><br><span class="hljs-meta">            char:(char)0,\</span><br><span class="hljs-meta">            __scalar_type_to_expr_cases(char),\</span><br><span class="hljs-meta">            __scalar_type_to_expr_cases(short),\</span><br><span class="hljs-meta">            __scalar_type_to_expr_cases(int),\</span><br><span class="hljs-meta">            __scalar_type_to_expr_cases(long),\</span><br><span class="hljs-meta">            __scalar_type_to_expr_cases(long long),\</span><br><span class="hljs-meta">            default: (x)))</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="sparse-语义检查工具"><a href="#sparse-语义检查工具" class="headerlink" title="sparse 语义检查工具"></a>sparse 语义检查工具</h2><p>这里描述的宏都是在使用sparse工具时才会定义&#x2F;被sparse识别的：</p><ul><li><p><code># define __rcu__attribute__((noderef, address_space(__rcu)))</code></p><ul><li>noderef: 意味着这是一个指针，且后续不能对其直接解引用；否则sparse检查器会报错</li><li>address_space: 这个地址在rcu地址空间中</li></ul></li><li><p><code>#define __safe __attribute__(safe)</code></p><ul><li>不用检查参数是否为控，可以直接取成员</li></ul></li><li><p><code>#define __force __attribute__(force)</code></p><ul><li>表示所定义的变量是可以做强制类型转换的</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>APUE-Learning-高级IO</title>
    <link href="/2024/07/22/APUE-Learning-%E9%AB%98%E7%BA%A7IO/"/>
    <url>/2024/07/22/APUE-Learning-%E9%AB%98%E7%BA%A7IO/</url>
    
    <content type="html"><![CDATA[<h1 id="高级I-O"><a href="#高级I-O" class="headerlink" title="高级I&#x2F;O"></a>高级I&#x2F;O</h1><ul><li>I&#x2F;O多路复用<ul><li>有多个描述符，数据可能在任一个描述符上到达（可用），但是事先无法知道究竟是哪一个描述符</li><li>不能对任意一个描述符进行阻塞读操作，因为数据可能已经在其它描述符上到达<ul><li>使用两个或多个进程&#x2F;线程分别处理一个描述符，但是带来资源开销、同步处理的问题</li><li>不使用阻塞I&#x2F;O：对所有描述符进行轮询处理</li><li>异步I&#x2F;O+信号：信号数量有限，无法与描述符一一对应</li></ul></li><li>I&#x2F;O多路复用：实现准备一张描述符表，内核会在表中任一个描述符准备好时，通知进程并告知哪些文件描述符已经准备好了<ul><li>有三个select，poll，epoll；均会阻塞线程，直到有可用的描述符时才会返回</li><li>描述符集：fd_set</li><li>select: 三组描述符集作为参数（可读、可写、异常条件）</li><li>poll: pollfd数组：包含描述符编号、感兴趣的事件</li></ul></li></ul></li></ul><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><ul><li><p>无名管道</p><ul><li>只能在两个相关的进程间使用；即两个fd通过父进程创建，之后在子进程中使用</li></ul></li><li><p>有名管道（FIFO）</p><ul><li>不相关的进程间也能通信</li><li>它是一种文件类型，它的文件名(路径名)存在于文件系统中</li><li><code>int mkfifo(const char* path, mode_t mode);</code>，返回值为文件描述符</li></ul></li><li><p>三个相似的IPC机制</p><ul><li>使用键（key_t）来标识</li><li><code>key_t ftok(const char* path, int id)</code>，根据一个路径名和ID，创建一个key</li></ul><ul><li>消息队列（1）<ul><li><code>msgget(key_t, int)</code>，【创建或打开已有的】返回非负队列ID，供后续发送、接收、控制使用</li></ul></li><li>信号量（2）<ul><li><code>semget(key_t, int)</code></li><li>删除是立即生效的；会导致其它使用该信号量的程序产生错误</li></ul></li><li>共享内存（3）<ul><li><code>shmget(key_t, int)</code></li></ul></li></ul></li><li><p>POSIX 信号量</p><ul><li>更高性能</li><li>接口更简单</li><li>添加引用计数，删除操作会在最后一次引用结束时删除信号量</li></ul><ul><li><code>sem_t* sem_open(const char* name, int flag, ...)</code>，创建新的或打开一个已有的信号量</li><li><code>sem_close()</code>操作并不会将信号量值减1</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>APUE-Learning-线程</title>
    <link href="/2024/07/22/APUE-Learning-%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/07/22/APUE-Learning-%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul><li><p>每个线程都包含有表示执行环境所必须的信息</p><ul><li>进程中标识线程的线程ID。pthread_t，<strong>所有可移植的操作系统实现不能把它作为整数处理，因此必须提供一个函数来对两个线程ID进行比较</strong></li><li>一组寄存器值</li><li>栈</li><li>调度优先级和调度策略</li><li>信号屏蔽字 -&gt; 继承于创建它的线程</li><li>errno变量</li><li>线程私有数据</li></ul></li><li><p>POSIX线程的功能测试宏是**_POSIX_THREADS**，可以用它在编译时确定是否支持posix线程 </p></li><li><p>线程终止</p><ul><li>影响整个进程<ul><li>如果进程中的任意线程调用了exit, _Exit, _exit，那么整个进程就会终止</li><li>如果信号的默认行为是终止进程，那么发送到线程的信号就会终止整个进程</li></ul></li><li>单个线程退出<ul><li>从线程执行函数中退出</li><li>被同一进程中的其他线程终止：pthread_cancel()，仅提出终止线程的请求，不等待线程终止</li><li>线程调用pthread_exit()</li></ul></li><li>pthread_join() -&gt; 传参时遇到指针一定注意：内存应该处在栈上？还是堆上？所有者是哪个线程？<ul><li>调用线程一直阻塞，直到指定的线程调用pthread_exit()、从执行函数中返回、或者被其他线程取消</li></ul></li></ul></li><li><p>线程的分离状态</p><ul><li>已被分离的线程在终止时，其底层存储资源可以立即被收回</li><li>线程被分离后不能调用pthread_join()等待它终止，会产生未定义行为</li><li>可以调用pthread_detach()分离线程</li><li>在pthread_create时控制传入的线程属性参数，可以直接创建已处于分离状态的线程</li></ul></li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li>程序使用变量的方式也会引起竞争，导致不一致的情况发生。例如，对某个变量+1，然后基于这个值做出某种决定。因为增量操作步骤和这个决定步骤的组合不是原子操作，所以就给不一致情况的出现提供了可能</li></ul><h3 id="互斥量-pthread-mutex-t"><a href="#互斥量-pthread-mutex-t" class="headerlink" title="互斥量 -&gt; pthread_mutex_t"></a>互斥量 -&gt; pthread_mutex_t</h3><ul><li><p>pthread_mutex_lock -&gt; 可能会阻塞</p></li><li><p>pthread_mutex_trylock -&gt; 不会阻塞；不能加锁时返回EBUSY</p></li><li><p>如果有多个线程阻塞在获取锁的状态；当锁被释放时，所有线程都被唤醒？，最终只有一个线程能获取锁，其他线程仍进入阻塞状态?</p><ul><li>这种“惊群现象”会发生嘛？即线程何时被唤醒？</li><li>如果等待的线程数&gt;1，内核可以只唤醒一个线程，避免惊群 &lt;- 这个是futex2（fast user mutex）【Documentation\translations\zh_CN\userspace-api\futex2.rst】<ul><li>翻看pthread_mutex_unlock时，传给futex_wake的参数中nr &#x3D; 1，即只唤醒一个等待的线程</li><li>翻看Linux-futex系统调用的实现，看到其先遍历futex的等待队列，把待唤醒的线程结构加入wake_q【超过nr后，不再添加】，之后调用<code>wake_up_q</code>对wake_q里面的线程进行统一的唤醒：-&gt; 线程使用task_struct结构表示，其中有个成员<code>struct wake_q_nodewake_q;</code>，辅助进行这些步骤</li></ul></li><li>因此mutex不会产生惊群现象</li><li>值得注意的是：futex簇有很多操作：wait，wake等，但都使用同一个系统调用号，最终在<code>do_futex()</code>统一处理，根据传参提取出（cmd）信息，进行细致的处理</li></ul></li><li><p>可以仔细控制相关互斥量的加锁顺序以避免死锁：</p><ul><li>程序1： A -&gt; B；程序2：B -&gt; A；这种情况下可能会出现1获得A，2获得B，之后A阻塞于获取B，而B阻塞与获取A</li><li>如果所有程序都以A -&gt; B的顺序加锁，那么可以避免相关的死锁</li></ul></li><li><p>当锁比较多，不好仔细控制加锁顺序时，可以采用解除已获取锁，并进入等待，稍后再试的方式来避免死锁</p><ul><li>即使用trylock，如果返回EBUSY，则释放之前已获取的锁，并挂起等待</li></ul></li></ul><h3 id="读写锁-pthread-rwlock-t"><a href="#读写锁-pthread-rwlock-t" class="headerlink" title="读写锁 -&gt; pthread_rwlock_t"></a>读写锁 -&gt; pthread_rwlock_t</h3><ul><li>三种状态：适合于读次数远大于写次数的情况<ul><li>读加锁：后续读加锁的线程可以获得访问；而写加锁的线程被阻塞</li><li>写加锁：后续任意形式的加锁都会被阻塞</li><li>不加锁：-&gt;</li></ul></li></ul><h3 id="条件变量-pthread-cond-t"><a href="#条件变量-pthread-cond-t" class="headerlink" title="条件变量 -&gt; pthread_cond_t"></a>条件变量 -&gt; pthread_cond_t</h3><ul><li>需要配合互斥量一起使用，条件本身由互斥量保护，线程在改变条件状态之前必须首先锁住互斥量</li><li>调用pthread_cond_wait时，要把已经锁住的互斥量传递给该函数。一般在while条件循环判断条件是否成立，在while循环体里面调用cond_wiat()</li><li>两个唤醒操作<ul><li>pthread_cond_signal()，唤醒一个特定的线程</li><li>pthread_cond_broadcast()，唤醒所有等待线程</li></ul></li></ul><h3 id="自旋锁-pthread-spinlock-t"><a href="#自旋锁-pthread-spinlock-t" class="headerlink" title="自旋锁 -&gt; pthread_spinlock_t"></a>自旋锁 -&gt; pthread_spinlock_t</h3><ul><li>不通过挂起使进程阻塞，而是循环判断</li><li>适用于锁持有时间短，短至自旋开销远小于线程切换、重新调度的时间开销</li><li>当前只在极少数情况下适合使用</li></ul><h3 id="屏障-pthread-barrier-t"><a href="#屏障-pthread-barrier-t" class="headerlink" title="屏障 -&gt; pthread_barrier_t"></a>屏障 -&gt; pthread_barrier_t</h3><ul><li>允许每个线程等待，知道所有合作的线程都到达某一点，然后从该点继续执行。pthread_join()就是一种屏障</li><li>参数count指定必须到达屏障的线程数目</li><li>线程主动调用pthread_barrier_wait，表明该线程已完成工作，等待其它线程完成</li></ul><h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><ul><li><p>当互斥量&#x2F;读写锁&#x2F;条件变量&#x2F;屏障位于进程共享内存区域，则该互斥量&#x2F;读写锁&#x2F;条件变量&#x2F;屏障可以用于进程间同步</p><ul><li>需要设置属性为进程间共享</li></ul></li><li><p>如果一个函数对多个线程来说是可重入的，就说这个线程是线程安全的</p></li><li><p>同一进程的多个线程如何保持数据的私有性？</p><ul><li>提供了让基于进程的接口适应多线程环境的机制 -&gt; errno<ul><li>一个线程在系统调用中重置errno，也不会影响其它线程对errno的设置</li></ul></li><li>键值与某个地址对应</li></ul></li><li><p>线程取消：pthread_cancel()</p><ul><li>调用pthread_cancel()并不会阻塞等待线程结束</li><li>调用后，目标线程可能还处于运行状态，只有在到达取消点时，它才会检查是否被设置了取消状态  -&gt; <strong>推迟取消模式</strong><ul><li>如果被设置了取消状态，则结束自身的运行</li><li>系统中有很多的cancel point</li></ul></li><li>如果该线程取消属性被设置为：PTHREAD_CANCEL_DISABLE，<ul><li>所有对该线程的取消请求会被保留，但处于挂起状态，即在线程到达取消点时，并不会检查取消状态</li><li>当该线程被再次设置为PTHREAD_CANCEL_ENABLE，在到达取消点时，会检查取消状态【之前设置的取消状态还是有效的】</li></ul></li><li>可以主动调用pthread_testcancel()，由开发人员手动加入取消点</li><li><strong>异步取消模式</strong>：当线程的取消为该种类型时，线程可以在任意时间被取消</li></ul></li><li><p>线程和信号</p><ul><li>每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的</li><li>进程中的信号是递送到单个线程的</li><li>pthread_sigmask()用于设置线程的信号屏蔽字</li><li>sigwait()，线程调用等待一个或多个信号的出现。返回之前，sigwait将从进程中移除处于挂起等待状态的信号</li><li>多个线程在sigwait()调用中因同一个信号而阻塞，那么在信号递送的时候，就只有一个线程可从sigwait()返回</li><li>如果一个信号被设置了sigaction()[即被捕获]，这时由操作系统决定是让sigwait返回，还是激活信号处理程序：只能2选1</li><li>使用pthread_kill()将1个信号发送给线程</li><li>为了避免错误行为，线程在调用sigwait()之前，必须阻塞那些它需要等待的信号。该函数内部会原子地取消即将等待信号集的阻塞状态</li></ul></li><li><p>线程和fork()</p><ul><li>线程调用fork()创建子进程，从父进程继承了每个互斥量、读写锁和条件变量的状态；父进程有多个线程的情况下，子进程中只有一个线程，它是由父进程中调用fork的线程的副本。如果子进程从fork返回以后，不是紧接着调用exec的话，就需要清理锁状态</li><li>但是子进程不知道它占有了哪些锁【这些占有的锁可能是父进程中的其它线程持有的】，因此它无法做细致的清理</li><li>如果fork返回后，紧接着调用exec，就可以避免上述的情况，因为旧的地址空间会被丢弃，所以锁的状态无关紧要</li><li>但如果子进程还要继续进行部分处理工作，就需要重点关注：<ul><li>pthread_atfork，在三个阶段进行辅助清理锁资源<ul><li>父进程调用fork创建子进程之前调用，获取父进程定义的所有锁</li><li>fork创建子进程以后、返回之前在父进程上下文中执行，对前一步获取的所有锁进行解锁</li><li>fork返回之前，在子进程上下文中执行，释放第一步中获取的所有锁</li><li>注意：子进程中的锁和父进程中的锁不是同一把锁？！！！</li></ul></li></ul></li></ul></li><li><p>线程和I&#x2F;O</p><ul><li>pread</li><li>pwrite</li><li>这两个函数对偏移量的设定和数据的读写操作是原子的</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>APUE-Learning-标准IO &amp; 信号</title>
    <link href="/2024/07/22/APUE-Learning-%E6%A0%87%E5%87%86IO-%E4%BF%A1%E5%8F%B7/"/>
    <url>/2024/07/22/APUE-Learning-%E6%A0%87%E5%87%86IO-%E4%BF%A1%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I&#x2F;O"></a>标准I&#x2F;O</h1><h2 id="流与FILE对象"><a href="#流与FILE对象" class="headerlink" title="流与FILE对象"></a>流与FILE对象</h2><ul><li>注意与struct file[打开文件表项]结构的不同</li><li>一个字符可以使用单个(ASCII字符集)或多个(国际字符集)字节表示</li><li>多字节I&#x2F;O函数 (wchar.h)</li><li>标准I&#x2F;O打开文件时，创建了一个流对象，并将其与该文件关联起来</li><li>fopen()打开一个流时，返回一个指向FILE对象的指针</li><li>FILE对象中包含详尽的信息：用于实际I&#x2F;O的文件描述符、指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数、出错标志等</li><li>预定义了三个标准流，使用&lt;stdio.h&gt;中定义的FILE指针，stdin, stdout, stderr</li><li>流和文件的概念是分开的：流即使用FILE表示，文件只能与某个流对应起来</li></ul><h2 id="缓冲类型"><a href="#缓冲类型" class="headerlink" title="缓冲类型"></a>缓冲类型</h2><ul><li><strong>全缓冲</strong>：填满标准I&#x2F;O缓冲区后，才进行实际的I&#x2F;O操作。驻留在磁盘上的文件通常由标准I&#x2F;O实施全缓冲。在一个流上执行第一次I&#x2F;O操作时，相关标准I&#x2F;O函数通常调用malloc函数获得需使用的缓冲区<ul><li>也可调用fflush(file flush)将未填满的缓冲区写到磁盘上</li></ul></li><li><strong>行缓冲</strong>：当在输入&#x2F;输出中遇到换行符时【由于缓冲区长度固定，当缓冲区满时也会执行实际I&#x2F;O操作】，标准I&#x2F;O库执行I&#x2F;O操作。标准输入&#x2F;输出通常为行缓冲</li><li><strong>不带缓冲</strong>：标准错误流通常不带缓冲</li></ul><h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I&#x2F;O"></a>二进制I&#x2F;O</h2><ul><li>指定读写的数据类型长度，及数据个数</li></ul><h1 id="进程流程控制"><a href="#进程流程控制" class="headerlink" title="进程流程控制"></a>进程流程控制</h1><h2 id="setjump-jmp-buf-env"><a href="#setjump-jmp-buf-env" class="headerlink" title="setjump(jmp_buf env)"></a>setjump(jmp_buf env)</h2><ul><li>调用该宏时将当前上下文环境保存再env中，包括栈指针、PC、寄存器等，以便后续longjump使用</li><li>如果该宏直接返回则它的返回值为0</li><li>如果它从后续的longjump()返回，则返回一个非零值</li></ul><h2 id="longjump"><a href="#longjump" class="headerlink" title="longjump()"></a>longjump()</h2><ul><li>使用env中保存的前面某个流程的环境，跳转到该执行流</li></ul><h1 id="信号-异步场景解决方案"><a href="#信号-异步场景解决方案" class="headerlink" title="信号 -&gt; 异步场景解决方案"></a>信号 -&gt; 异步场景解决方案</h1><ul><li>不存在编号为0的信号，kill函数对编号0有特殊的应用</li></ul><h2 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h2><p>初始化时，可以告诉内核在某个信号发生时按下列三种方式之一进行处理：</p><ul><li><strong>忽略</strong>此信号：<strong>SIGKILL</strong>和<strong>SIGSTOP</strong>信号是不能被忽略的。实际应用编程时可以设置忽略吗？ -&gt; 不可以</li><li><strong>捕捉</strong>信号：某种信号发生时，内核调用用户提前注册的回调函数。无法捕捉<strong>SIGKILL</strong>和<strong>SIGSTOP</strong>信号</li><li><strong>默认</strong>动作：大多数信号的默认动作是终止进程</li></ul><h2 id="早期的不可靠信号"><a href="#早期的不可靠信号" class="headerlink" title="早期的不可靠信号"></a>早期的不可靠信号</h2><ul><li>进程每次接收到信号对其进行处理时，随即将该信号动作重置为默认值<ul><li>只得在处理完逻辑后重新设置该信号的信号处理函数</li><li>然而在接收处理到重新设置这段时间内，有可能新的信号产生</li><li>并执行默认动作（有可能是终止程序）</li></ul></li></ul><h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><ul><li>在信号处理函数中调用不可重入函数，其结果是不可预知的</li><li>信号处理函数可以运行在用户态，打断之前执行的用户进程</li></ul><h2 id="可靠信号"><a href="#可靠信号" class="headerlink" title="可靠信号"></a>可靠信号</h2><ul><li><p>信号产生 -&gt;  这段时间内信号是<strong>未决(pending)<strong>的  -&gt;内核在进程结构体中设置标志位（向进程</strong>递送</strong>信号）</p></li><li><p>信号<strong>阻塞</strong>：进程可以设置阻塞某信号，如果该信号的处理方式为默认或者捕获时；当该信号产生时，内核将保持该信号为pending状态，直至进程解除了对该信号的阻塞，或者忽略该信号。于是，进程在信号传递给它之前仍可改变对该信号的动作</p><ul><li>如果解除阻塞之前，该信号产生了多次，如何处理？<ul><li>POSIX允许内核递送该信号一次或多次(排队，且需支持POSIX.1实时扩展)</li><li>此外，内核可能已经有了新的变化</li></ul></li><li>不能阻塞SIGKILL和SIGSTOP信号</li></ul></li><li><p>如果同时有多个待递送的信号，如何处理？</p><ul><li>POSIX.1没有规定递送顺序，但是建议：先递交与进程当前状态有关的信号，如SIGSEGV</li></ul></li><li><p><strong>信号屏蔽字</strong>：每个进程都有一个信号屏蔽字，每一位与一个具体的信号规定。使用数据类型：<code>sigset_t</code></p></li><li><p>信号集：<code>sigset_t</code>，可以表示多个信号</p></li><li><p>sigaction</p><ul><li>sa_mask：在调用通过sigaction()注册的信号处理函数之前，要将sa_mask声明的信号屏蔽字加到进程的信号屏蔽字中；仅当从该信号处理函数返回时再恢复进程的信号屏蔽字</li><li>sa_flags:<ul><li>SA_INTERRUPT：由此信号中断的系统调用不自动重启</li><li>SA_RESTART：此信号中断的系统调用自动重启</li><li>SA_SIGINFO：信号处理函数多了两个形参</li></ul></li></ul></li><li><p>sigsetjump&#x2F;siglongjump -&gt; POSIX规范定义</p><ul><li>在使用sigaction，当执行其注册的信号处理函数时，进程的信号屏蔽字可能已经被修改，如果此时在信号处理函数中使用longjump()改变执行流，那么进程的信号屏蔽字不会恢复</li><li>因此，提供了新的宏用于信号处理的情况下使用</li><li>从这里也可以看出，信号处理函数应该是工作在用户态的，否则不能使用longjump跳转回用户程序</li></ul></li><li><p>信号阻塞与pause</p><ul><li>pasue系统调用会挂起当前进程，直到某个信号产生、被处理并返回，之后该进程被唤醒</li><li>考虑：某信号被阻塞，之后想要等待该信号的发生。因此要先解除阻塞，并且使用pause()</li><li>如果该信号在阻塞期间产生，则其可能在解除阻塞后立即被递送给进程，导致后续的pause()不再被唤醒</li><li>为了解决这个问题，需要原子的修改进程信号屏蔽字并进入等待<ul><li>sigsuspend()函数完成这个原子操作</li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>破除迷雾-重定位</title>
    <link href="/2024/07/22/%E7%A0%B4%E9%99%A4%E8%BF%B7%E9%9B%BE-%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
    <url>/2024/07/22/%E7%A0%B4%E9%99%A4%E8%BF%B7%E9%9B%BE-%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>之前一直不理解重定位表中的条目是如何生成的</li><li>需要为哪些代码，哪些数据创建重定位条目</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li><p>《深入理解计算机操作系统》7.7节：</p><ul><li>当汇编器生成一个模块时，在遇到对最终位置未知的目标引用时，它就会创建一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用<ul><li>offset:该条目表示的要修改的位置在该节的偏移</li><li>symbol:需要修改引用指向的符号</li><li>type:告知链接器如何对该位置进行修改</li></ul></li></ul></li><li><p>每个重定位条目都表示了一个必须修改的引用处</p></li><li><p>经过这部分描述，可以看出：</p><ul><li>如果当前编译单元引用了外部的函数、变量，那肯定要为其生成一个重定位条目；但是对于当前编译单元中定义的函数、变量呢 ????</li><li>这是因为，后续所有目标文件链接为可执行文件时，需要聚合相同的节为一个段，会改变每个编译单元中代码段、数据段的原本相对位置。如果编译单元中使用相对地址寻址，后续聚合时仍会产生问题！ -&gt; 猜测也需要生成重定位表项</li><li>经过实验发现，在编译某个编译单元时，<strong>也会为当前编译单元中定义的全局变量、函数生成重定位表项</strong>！！！即使最终也是使用相对地址寻址的方式进行！！！</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>程序员的自我修养</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-系统调用-2</title>
    <link href="/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-2/"/>
    <url>/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-2/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux系统调用的处理"><a href="#Linux系统调用的处理" class="headerlink" title="Linux系统调用的处理"></a>Linux系统调用的处理</h2><ul><li>注意本系列以Linux6.9为例</li><li>这里为aarch64</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>dup2() of POSIX interface: defined in glibc</p><ul><li>INLINE_SYSCALL_CALL() -&gt; __INLINE_SYSCALL2() -&gt; INLINE_SYSCALL(): 针对不同的UNIX实现，定义了不同的宏实现<ul><li>for Linux: INLINE_SYSCALL() -&gt; INTERNAL_SYSCALL(): 针对不同的架构，定义了不同的宏实现<ul><li>for aarch64: INTERNAL_SYSCALL_RAW()<ul><li>将系统调用号放在x8寄存器，将调用参数放到x0-x6寄存器中</li><li><code>svc0</code> 触发SVC异常，陷入内核</li></ul></li></ul></li></ul></li></ul></li><li><p>陷入内核后：（SVC异常属于同步异常）</p><ul><li>根据vectors，进入el0，64，sync处理流程<ul><li>执行部分汇编码 -&gt; b(无条件，不返回)跳转到 el0t_64_sync<ul><li>el0t_64_sync (由entry_handler宏定义，汇编标号) -&gt; el0t_64_sync_handler (c函数)<ul><li>el0t_64_sync_handler -&gt; el0_svc -&gt; do_el0_svc<ul><li>do_el0_svc(从x8获取系统调用号) -&gt; el0_svc_common<ul><li>el0_svc_common: 从调用表中拿到Linux定义的系统调用函数__arm64_sym_sys_dup2()<ul><li>进入执行 SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd): in file.c</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="分步梳理"><a href="#分步梳理" class="headerlink" title="分步梳理"></a>分步梳理</h3><ul><li><p>参考《vectors.md》可知，系统调用触发软件中断，为同步异常，因此会进入el0t_64_sync的处理流程</p></li><li><p>必要的汇编 -&gt; el0t_64_sync -&gt; el0t_64_sync_handler</p></li><li><p>el0t_64_sync_handler</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">asmlinkage <span class="hljs-type">void</span> noinstr <span class="hljs-title function_">el0t_64_sync_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esr = read_sysreg(esr_el1);<br><br>    <span class="hljs-keyword">switch</span> (ESR_ELx_EC(esr)) &#123;<br>    <span class="hljs-keyword">case</span> ESR_ELx_EC_SVC64:<br>        el0_svc(regs);          <span class="hljs-comment">// 这里处理 svc 同步异常</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ESR_ELx_EC_DABT_LOW:<br>        el0_da(regs, esr);<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>el0_svc -&gt; do_el0_svc</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> noinstr <span class="hljs-title function_">el0_svc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    enter_from_user_mode(regs);<br>    cortex_a76_erratum_1463225_svc_handler();<br>    fp_user_discard();<br>    local_daif_restore(DAIF_PROCCTX);<br>    do_el0_svc(regs);<br>    exit_to_user_mode(regs);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>do_el0_svc -&gt; el0_svc_common -&gt; invoke_syscall</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_el0_svc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-comment">// 这里从x8中获取调用号; sys_call_table为系统调用表</span><br>    el0_svc_common(regs, regs-&gt;regs[<span class="hljs-number">8</span>], __NR_syscalls, sys_call_table);<br>&#125;<br><br><span class="hljs-comment">// sys_call_table的“创建”, in file: arch\arm64\kernel\sys.c</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Wrappers to pass the pt_regs argument.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __arm64_sys_personality__arm64_sys_arm64_personality</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL(nr, sym)asmlinkage long __arm64_##sym(const struct pt_regs *);</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL(nr, sym)[nr] = __arm64_##sym,</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">syscall_fn_t</span> sys_call_table[__NR_syscalls] = &#123;<br>    [<span class="hljs-number">0</span> ... __NR_syscalls - <span class="hljs-number">1</span>] = __arm64_sys_ni_syscall,<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/unistd.h&gt;</span></span><br>    [<span class="hljs-number">23</span>] = __arm64_sym_sys_dup,     <span class="hljs-comment">// 在《syscall-1.md》的分析中，已经见到了该函数的定义</span><br>    [<span class="hljs-number">24</span>] = __arm64_sym_sys_dup3<br>&#125;;<br><br><span class="hljs-comment">// 上面两个#include &lt;asm/unistd.h&gt;，最终会包含linux\include\uapi\asm-generic\unistd.h 这个重要文件</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_dup 23</span><br>__SYSCALL(__NR_dup, sys_dup)<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_dup3 24</span><br>__SYSCALL(__NR_dup3, sys_dup3)<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR3264_fcntl 25</span><br>__SC_COMP_3264(__NR3264_fcntl, sys_fcntl64, sys_fcntl, compat_sys_fcntl64)<br>...<br></code></pre></td></tr></table></figure></li><li><p>invoke_syscall：从调用表中所引到某个表项，取得syscall_fn_t，调用即可</p><ul><li>对于POSIX标准规范的dup()<ul><li>调用到__arm64_sym_sys_dup()<ul><li>__se_sys_dup()<ul><li>__do_sys_dup()<ul><li>file.c 中 dup 的定义：<code>SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd)</code></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-系统调用-1</title>
    <link href="/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1/"/>
    <url>/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux系统调用定义相关"><a href="#Linux系统调用定义相关" class="headerlink" title="Linux系统调用定义相关"></a>Linux系统调用定义相关</h2><ul><li><p>相关代码： </p><ul><li>for general arch: sys_*name -&gt; aliased to _<em>se_sys</em>*name -&gt; call _<em>do_sys</em>*name to do actual work</li><li>for arm64 arch: _<em>arm64_sys</em>* -&gt; call  _<em>se_sys</em>* -&gt; call _<em>do_sys</em>*name to do actual work</li></ul></li><li><p>因此，实际的系统调用函数为__do_sys_*()</p></li><li><p>asmlinkage：声明函数传参不使用寄存器，而使用栈进行。后续为Linux源码中的系统调用</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">// in file : syscalls.h</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span><br><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span><br><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_METADATA(sname, nb, ...)</span><br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * __MAP - apply a macro to syscall arguments</span><br><span class="hljs-comment">   * __MAP(n, m, t1, a1, t2, a2, ..., tn, an) will expand to</span><br><span class="hljs-comment">   *    m(t1, a1), m(t2, a2), ..., m(tn, an)</span><br><span class="hljs-comment">   * The first argument must be equal to the amount of type/name</span><br><span class="hljs-comment">   * pairs given.  Note that this list of pairs (i.e. the arguments</span><br><span class="hljs-comment">   * of __MAP starting at the third one) is in the same format as</span><br><span class="hljs-comment">   * for SYSCALL_DEFINE&lt;n&gt;/COMPAT_SYSCALL_DEFINE&lt;n&gt;</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP0(m,...)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP1(m,t,a,...) m(t,a)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP(n,...) __MAP##n(__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __SC_DECL(t, a)t a</span><br><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)\</span><br><span class="hljs-meta">       SYSCALL_METADATA(sname, x, __VA_ARGS__)\</span><br><span class="hljs-meta">       __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br><br>   <span class="hljs-comment">// in file：arch\arm64\include\asm\syscall_wrapper.h</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)\   <span class="hljs-comment">// arm64定义了自己的__SYSCALL_DEFINEx宏</span></span><br>asmlinkage <span class="hljs-type">long</span> __arm64_sys#<span class="hljs-meta">#name(const struct pt_regs *regs);\</span><br><span class="hljs-meta">ALLOW_ERROR_INJECTION(__arm64_sys##name, ERRNO);\</span><br><span class="hljs-meta">static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\</span><br><span class="hljs-meta">static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span><br><span class="hljs-meta">asmlinkage long __arm64_sys##name(const struct pt_regs *regs)\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">return __se_sys##name(SC_ARM64_REGS_TO_ARGS(x,__VA_ARGS__));\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="hljs-meta">__MAP(x,__SC_TEST,__VA_ARGS__);\</span><br><span class="hljs-meta">__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\</span><br><span class="hljs-meta">return ret;\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       <span class="hljs-comment">// 这一行看着很奇怪，需要结合一个具体的系统调用定义才能看明白</span></span><br><br>   <span class="hljs-comment">// 这里提取x0-x6</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SC_ARM64_REGS_TO_ARGS(x, ...)\</span><br><span class="hljs-meta">__MAP(x,__SC_ARGS\</span><br><span class="hljs-meta">      ,,regs-&gt;regs[0],,regs-&gt;regs[1],,regs-&gt;regs[2]\</span><br><span class="hljs-meta">      ,,regs-&gt;regs[3],,regs-&gt;regs[4],,regs-&gt;regs[5])</span><br><br>   <span class="hljs-comment">// in file: file.c</span><br>   SYSCALL_DEFINE2(dup2, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, oldfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, newfd)<br>   &#123;<br>       <span class="hljs-keyword">if</span> (unlikely(newfd == oldfd)) &#123; <span class="hljs-comment">/* corner case */</span><br>           <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span> =</span> current-&gt;files;<br>           <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>           <span class="hljs-type">int</span> retval = oldfd;<br><br>           rcu_read_lock();<br>           f = __fget_files_rcu(files, oldfd, <span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">if</span> (!f)<br>               retval = -EBADF;<br>           rcu_read_unlock();<br>           <span class="hljs-keyword">if</span> (f)<br>               fput(f);<br>           <span class="hljs-keyword">return</span> retval;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ksys_dup3(oldfd, newfd, <span class="hljs-number">0</span>);<br>   &#125;<br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * The asmlinkage stub is aliased to a function named __se_sys_*() which</span><br><span class="hljs-comment">   * sign-extends 32-bit ints to longs whenever needed. The actual work is</span><br><span class="hljs-comment">   * done within __do_sys_*().</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __SYSCALL_DEFINEx       <span class="hljs-comment">// 不同架构可能定义了自己的__SYSCALL_DEFINEx宏</span></span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)\</span><br><span class="hljs-meta">       __diag_push();\</span><br><span class="hljs-meta">       __diag_ignore(GCC, 8, <span class="hljs-string">&quot;-Wattribute-alias&quot;</span>,\</span><br><span class="hljs-meta">               <span class="hljs-string">&quot;Type aliasing is used to sanitize syscall arguments&quot;</span>);\</span><br><span class="hljs-meta">       asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\</span><br><span class="hljs-meta">           __attribute__((alias(__stringify(__se_sys##name))));\</span><br><span class="hljs-meta">       ALLOW_ERROR_INJECTION(sys##name, ERRNO);\</span><br><span class="hljs-meta">       static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span><br><span class="hljs-meta">       asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\</span><br><span class="hljs-meta">       asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\</span><br><span class="hljs-meta">       &#123;\</span><br><span class="hljs-meta">           long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="hljs-meta">           __MAP(x,__SC_TEST,__VA_ARGS__);\</span><br><span class="hljs-meta">           __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\</span><br><span class="hljs-meta">           return ret;\</span><br><span class="hljs-meta">       &#125;\</span><br><span class="hljs-meta">       __diag_pop();\</span><br><span class="hljs-meta">       static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __SYSCALL_DEFINEx */</span></span><br></code></pre></td></tr></table></figure></li><li><p>实际使用中会直接调用dup2()，由其触发svc同步异常，最终调用Linux定义的系统调用“服务函数”。其函数原型在相应的头文件[unistd.h]中有声明，但其定义在哪里？</p><ul><li>显然，在Linux中，它直接使用GNU的C库，因此dup2()的定义在GNU的C库源文件中。下载glibc的源码后，可以看到dup2()的定义</li><li>可以看到，对于不同的标准&#x2F;UNIX实现，glibc中也定义了不同的dup2()实现  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: sysdeps/posix/dup2.c</span><br>    <span class="hljs-type">int</span><br>__dup2 (<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> fd2)<br>&#123;<br><span class="hljs-type">int</span> save;<br><br><span class="hljs-keyword">if</span> (fd2 &lt; <span class="hljs-number">0</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPEN_MAX</span><br>    || fd2 &gt;= OPEN_MAX<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>)<br>    &#123;<br>    __set_errno (EBADF);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-comment">/* Check if FD is kosher.  */</span><br><span class="hljs-keyword">if</span> (fcntl (fd, F_GETFL) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span> (fd == fd2)<br>    <span class="hljs-keyword">return</span> fd2;<br><br><span class="hljs-comment">/* This is not atomic.  */</span><br><br>save = errno;<br>(<span class="hljs-type">void</span>) close (fd2);<br>__set_errno (save);<br><br><span class="hljs-keyword">return</span> fcntl (fd, F_DUPFD, fd2);<br>&#125;<br>libc_hidden_def (__dup2)<br>weak_alias (__dup2, dup2)<br><br><span class="hljs-comment">// in file: sysdeps/unix/sysv/linux/dup2.c</span><br><span class="hljs-type">int</span><br>__dup2 (<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> fd2)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NR_dup2</span><br><span class="hljs-keyword">return</span> INLINE_SYSCALL_CALL (dup2, fd, fd2);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">/* For the degenerate case, check if the fd is valid (by trying to</span><br><span class="hljs-comment">    get the file status flags) and return it, or else return EBADF.  */</span><br><span class="hljs-keyword">if</span> (fd == fd2)<br>    <span class="hljs-keyword">return</span> __libc_fcntl (fd, F_GETFL, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : fd;<br><br><span class="hljs-keyword">return</span> INLINE_SYSCALL_CALL (dup3, fd, fd2, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br>libc_hidden_def (__dup2)<br>weak_alias (__dup2, dup2)<br></code></pre></td></tr></table></figure></li><li>INLINE_SYSCALL_CALL 宏展开  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: sysdeps/unix/sysdep.h</span><br><br><span class="hljs-comment">/* Issue a syscall defined by syscall number plus any other argument</span><br><span class="hljs-comment">required.  Any error will be handled using arch defined macros and errno</span><br><span class="hljs-comment">will be set accordingly.</span><br><span class="hljs-comment">It is similar to INLINE_SYSCALL macro, but without the need to pass the</span><br><span class="hljs-comment">expected argument number as second parameter.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INLINE_SYSCALL_CALL(...) \</span><br><span class="hljs-meta">__INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INTERNAL_SYSCALL_DISP(b,...) \</span><br><span class="hljs-meta">__SYSCALL_CONCAT (b,__INTERNAL_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_CONCAT_X(a,b)     a##b</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)</span><br><span class="hljs-comment">// 以上几个宏的作用就是：根据参数个数，展开为宏__INLINE_SYSCALLn()</span><br><br><span class="hljs-comment">// 接着将参数展开，如下所示</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL0(name) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL1(name, a1) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 1, a1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL2(name, a1, a2) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 2, a1, a2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL3(name, a1, a2, a3) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 3, a1, a2, a3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL4(name, a1, a2, a3, a4) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 4, a1, a2, a3, a4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL5(name, a1, a2, a3, a4, a5) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 5, a1, a2, a3, a4, a5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL6(name, a1, a2, a3, a4, a5, a6) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 6, a1, a2, a3, a4, a5, a6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL7(name, a1, a2, a3, a4, a5, a6, a7) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 7, a1, a2, a3, a4, a5, a6, a7)</span><br><br><span class="hljs-comment">// in file: sysdeps/unix/sysdep.h</span><br><span class="hljs-comment">/* Wrappers around system calls should normally inline the system call code.</span><br><span class="hljs-comment">But sometimes it is not possible or implemented and we use this code.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> INLINE_SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INLINE_SYSCALL(name, nr, args...) __syscall_##name (args)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// in file: sysdeps/unix/sysv/linux/sysdep.h</span><br><span class="hljs-comment">/* Define a macro which expands into the inline wrapper code for a system</span><br><span class="hljs-comment">call.  It sets the errno and returns -1 on a failure, or the syscall</span><br><span class="hljs-comment">return value otherwise.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> INLINE_SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INLINE_SYSCALL(name, nr, args...)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    long int sc_ret = INTERNAL_SYSCALL (name, nr, args);\</span><br><span class="hljs-meta">    __glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (sc_ret))\</span><br><span class="hljs-meta">    ? SYSCALL_ERROR_LABEL (INTERNAL_SYSCALL_ERRNO (sc_ret))\</span><br><span class="hljs-meta">    : sc_ret;\</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-comment">// 宏 INTERNAL_SYSCALL 是专属于**sysv/linux**实现的，而且不同的硬件架构，其具体定义不同</span><br><span class="hljs-comment">// for x86-64, in file: sysdeps/unix/sysv/linux/x86_64/sysdep.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> INTERNAL_SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERNAL_SYSCALL(name, nr, args...)\</span><br><span class="hljs-meta">    internal_syscall##nr (SYS_ify (name), args)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> internal_syscall0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> internal_syscall0(number, dummy...)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    unsigned long int resultvar;\</span><br><span class="hljs-meta">    asm volatile (\</span><br><span class="hljs-meta">    <span class="hljs-string">&quot;syscall\n\t&quot;</span>\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;=a&quot;</span> (resultvar)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;0&quot;</span> (number)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;memory&quot;</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="hljs-meta">    (long int) resultvar;\</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-comment">// 这里可以看到，x86_64使用 syscall触发软中断，调用号应该也是放到寄存器中：&quot;0&quot;(number);参数分别放在r9,r8,r10,rdx,rsi,rdi中</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> internal_syscall1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> internal_syscall1(number, arg1)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    unsigned long int resultvar;\</span><br><span class="hljs-meta">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="hljs-meta">    register TYPEFY (arg1, _a1) asm (<span class="hljs-string">&quot;rdi&quot;</span>) = __arg1;\</span><br><span class="hljs-meta">    asm volatile (\</span><br><span class="hljs-meta">    <span class="hljs-string">&quot;syscall\n\t&quot;</span>\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;=a&quot;</span> (resultvar)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;0&quot;</span> (number), <span class="hljs-string">&quot;r&quot;</span> (_a1)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;memory&quot;</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="hljs-meta">    (long int) resultvar;\</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-comment">// for aarch64, in file: sysdeps/unix/sysv/linux/aarch64/sysdep.h</span><br><span class="hljs-meta"># <span class="hljs-keyword">undef</span> INTERNAL_SYSCALL</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> INTERNAL_SYSCALL(name, nr, args...)\</span><br><span class="hljs-meta">    INTERNAL_SYSCALL_RAW(SYS_ify(name), nr, args)</span><br><br><span class="hljs-comment">// 这里，SYS_ify将系统调用名，扩展为具体的系统调用号</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> SYS_ify</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_ify(syscall_name)(__NR_##syscall_name)</span><br><br><span class="hljs-comment">// 这里可以看到使用 svc 0 触发软中断，陷入内核，并在x8寄存器中存储系统调用号</span><br><span class="hljs-meta"># <span class="hljs-keyword">undef</span> INTERNAL_SYSCALL_RAW</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> INTERNAL_SYSCALL_RAW(name, nr, args...)\</span><br><span class="hljs-meta">(&#123; long _sys_result;\</span><br><span class="hljs-meta">    &#123;\</span><br><span class="hljs-meta">    LOAD_ARGS_##nr (args)\</span><br><span class="hljs-meta">    register long _x8 asm (<span class="hljs-string">&quot;x8&quot;</span>) = (name);\</span><br><span class="hljs-meta">    asm volatile (<span class="hljs-string">&quot;svc0// syscall &quot;</span> # name     \</span><br><span class="hljs-meta">            : <span class="hljs-string">&quot;=r&quot;</span> (_x0) : <span class="hljs-string">&quot;r&quot;</span>(_x8) ASM_ARGS_##nr : <span class="hljs-string">&quot;memory&quot;</span>);\</span><br><span class="hljs-meta">    _sys_result = _x0;\</span><br><span class="hljs-meta">    &#125;\</span><br><span class="hljs-meta">    _sys_result; &#125;)</span><br><br><span class="hljs-comment">// 可以看到，系统调用使用x0-6这7个寄存器进行参数传递</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> LOAD_ARGS_0()\</span><br><span class="hljs-meta">register long _x0 asm (<span class="hljs-string">&quot;x0&quot;</span>);</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> LOAD_ARGS_1(x0)\</span><br><span class="hljs-meta">long _x0tmp = (long) (x0);\</span><br><span class="hljs-meta">LOAD_ARGS_0 ()\</span><br><span class="hljs-meta">_x0 = _x0tmp;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-中断处理流程</title>
    <link href="/2024/07/10/Linux-aarch64-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/07/10/Linux-aarch64-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="中断处理流程"><a href="#中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>*<br>    *<br>        * </p><h3 id="aarch64"><a href="#aarch64" class="headerlink" title="aarch64"></a>aarch64</h3><ul><li><p>参考《vectors.md》可知，中断响应时，执行部分汇编码[kernel_ventry宏]后，进入<code>el0t_64_irq</code>[in file entry.S，用entry_handler宏定义]，紧接着调用<br><code>el0t_64_irq_handler</code>[in file: entry-common.c]，进行后续的处理</p></li><li><p>el0t_64_irq_handler -&gt; __el0_irq_handler_common -&gt; el0_interrupt(regs, handle_arch_irq);</p><ul><li><p>这里要注意：<code>handle_arch_irq</code>是一个全局的变量，定义在&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;irq.c文件中</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*handle_arch_irq)(<span class="hljs-keyword">struct</span> pt_regs *) __ro_after_init = default_handle_irq;     <span class="hljs-comment">// __ro_after_init 是编译器提供的属性</span><br><span class="hljs-type">void</span> (*handle_arch_fiq)(<span class="hljs-keyword">struct</span> pt_regs *) __ro_after_init = default_handle_fiq;<br><br><span class="hljs-type">int</span> __init <span class="hljs-title function_">set_handle_irq</span><span class="hljs-params">(<span class="hljs-type">void</span> (*handle_irq)(<span class="hljs-keyword">struct</span> pt_regs *))</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (handle_arch_irq != default_handle_irq)<br>        <span class="hljs-keyword">return</span> -EBUSY;<br><br>    handle_arch_irq = handle_irq;<br>    pr_info(<span class="hljs-string">&quot;Root IRQ handler: %ps\n&quot;</span>, handle_irq);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结合<code>__init set_handle_irq</code>可知，在系统启动阶段，irqchip的驱动会调用set_handle_irq，根据使用的中断控制器，将handle_arch_irq设置为对应的处理函数</p></li><li><p>对应的中断处理函数有：gic_handel_irq -&gt; GIC控制器</p></li></ul></li><li><p>gic_handle_irq</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: drivers/irqchip/irq-gic-v3.c</span><br><span class="hljs-type">static</span> asmlinkage <span class="hljs-type">void</span> __exception_irq_entry <span class="hljs-title function_">gic_handle_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (unlikely(gic_supports_nmi() &amp;&amp; !interrupts_enabled(regs)))<br>        __gic_handle_irq_from_irqsoff(regs);<br>    <span class="hljs-keyword">else</span><br>        __gic_handle_irq_from_irqson(regs);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>如果不是NMI中断，则__gic_handle_irq_from_irqson -&gt; __gic_handle_irq -&gt; generic_handle_domain_irq. 注意这里的irqnr为从相应寄存器[iar]读出的硬件中断号</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __gic_handle_irq(u32 irqnr, <span class="hljs-keyword">struct</span> pt_regs *regs)<br>&#123;<br>    <span class="hljs-keyword">if</span> (gic_irqnr_is_special(irqnr))<br>        <span class="hljs-keyword">return</span>;<br><br>    gic_complete_ack(irqnr);<br><br>    <span class="hljs-keyword">if</span> (generic_handle_domain_irq(gic_data.domain, irqnr)) &#123;<br>        WARN_ONCE(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;Unexpected interrupt (irqnr %u)\n&quot;</span>, irqnr);<br>        gic_deactivate_unhandled(irqnr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>generic_handle_domain_irq : irqdomain 管理hwirq 到 Linux irqnr的映射，有四种映射类型[Documentation\translations\zh_CN\core-api\irq\irq-domain.rst]</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: /kernel/irq/irqdesc.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">generic_handle_domain_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_domain *domain, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hwirq)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> handle_irq_desc(irq_resolve_mapping(domain, hwirq));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>handle_irq_desc</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">handle_irq_desc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_desc *desc)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_data</span> *<span class="hljs-title">data</span>;</span><br><br>    <span class="hljs-keyword">if</span> (!desc)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    data = irq_desc_get_irq_data(desc);<br>    <span class="hljs-keyword">if</span> (WARN_ON_ONCE(!in_hardirq() &amp;&amp; handle_enforce_irqctx(data)))<br>        <span class="hljs-keyword">return</span> -EPERM;<br><br>    generic_handle_irq_desc(desc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>generic_handle_irq_desc：根据描述符中的内容，执行相应的回调</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">generic_handle_irq_desc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_desc *desc)</span><br>&#123;<br>    desc-&gt;handle_irq(desc);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-向量表</title>
    <link href="/2024/07/10/Linux-aarch64-%E5%90%91%E9%87%8F%E8%A1%A8/"/>
    <url>/2024/07/10/Linux-aarch64-%E5%90%91%E9%87%8F%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="arm64-aarch64-的中断入口"><a href="#arm64-aarch64-的中断入口" class="headerlink" title="arm64(aarch64)的中断入口"></a>arm64(aarch64)的中断入口</h1><ul><li><p>总结</p><ul><li>部分汇编码，由宏kernel_ventry定义</li><li>el0t_64_irq</li><li>el0t_64_irq_handler</li><li>ret_to_user&#x2F;kernel</li></ul></li><li><p>相关两个宏定义：下面 \el，对宏参数展开</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs asm">    .macro entry_handler el:req, ht:req, regsize:req, label:req<br>SYM_CODE_START_LOCAL(el\el\ht\()_\regsize\()_\label)<br>    kernel_entry \el, \regsize<br>    movx0, sp<br>    blel\el\ht\()_\regsize\()_\label\()_handler      // 这里先调用el0t_64_irq_handler[在entry-common.c中定义]，bl是带返回的跳转[lr存储返回地址]<br>    .if \el == 0<br>    bret_to_user                                    // 返回用户空间<br>    .else<br>    bret_to_kernel                                  // 返回内核空间<br>    .endif<br>SYM_CODE_END(el\el\ht\()_\regsize\()_\label)<br>    .endm<br><br>// 这里使用上面的宏，定义了不同等级的异常入口：例如，el0t_64_irq， el0t_32_sync<br>/*<br>* Early exception handlers<br>*/<br>    entry_handler1, t, 64, sync<br>    entry_handler1, t, 64, irq<br>    entry_handler1, t, 64, fiq<br>    entry_handler1, t, 64, error<br><br>    entry_handler1, h, 64, sync<br>    entry_handler1, h, 64, irq<br>    entry_handler1, h, 64, fiq<br>    entry_handler1, h, 64, error<br><br>    entry_handler0, t, 64, sync<br>    entry_handler0, t, 64, irq<br>    entry_handler0, t, 64, fiq<br>    entry_handler0, t, 64, error<br><br>    entry_handler0, t, 32, sync<br>    entry_handler0, t, 32, irq<br>    entry_handler0, t, 32, fiq<br>    entry_handler0, t, 32, error<br><br>// 下面的宏使用，定义了向量表<br><br>/*<br>* Exception vectors.<br>*/<br>    .pushsection &quot;.entry.text&quot;, &quot;ax&quot;<br><br>    .align11<br>SYM_CODE_START(vectors)<br>    kernel_ventry1, t, 64, sync// Synchronous EL1t<br>    kernel_ventry1, t, 64, irq// IRQ EL1t<br>    kernel_ventry1, t, 64, fiq// FIQ EL1t<br>    kernel_ventry1, t, 64, error// Error EL1t<br><br>    kernel_ventry1, h, 64, sync// Synchronous EL1h<br>    kernel_ventry1, h, 64, irq// IRQ EL1h<br>    kernel_ventry1, h, 64, fiq// FIQ EL1h<br>    kernel_ventry1, h, 64, error// Error EL1h<br><br>    kernel_ventry0, t, 64, sync// Synchronous 64-bit EL0<br>    kernel_ventry0, t, 64, irq// IRQ 64-bit EL0<br>    kernel_ventry0, t, 64, fiq// FIQ 64-bit EL0<br>    kernel_ventry0, t, 64, error// Error 64-bit EL0<br><br>    kernel_ventry0, t, 32, sync// Synchronous 32-bit EL0<br>    kernel_ventry0, t, 32, irq// IRQ 32-bit EL0<br>    kernel_ventry0, t, 32, fiq// FIQ 32-bit EL0<br>    kernel_ventry0, t, 32, error// Error 32-bit EL0<br>SYM_CODE_END(vectors)<br><br>    .macro kernel_ventry, el:req, ht:req, regsize:req, label:req<br>    .align 7<br>.Lventry_start\@:<br>    .if\el == 0<br>    /*<br>    * This must be the first instruction of the EL0 vector entries. It is<br>    * skipped by the trampoline vectors, to trigger the cleanup.<br>    */<br>    b.Lskip_tramp_vectors_cleanup\@<br>    .if\regsize == 64<br>    mrsx30, tpidrro_el0<br>    msrtpidrro_el0, xzr<br>    .else<br>    movx30, xzr<br>    .endif<br>.Lskip_tramp_vectors_cleanup\@:<br>    .endif<br><br>    subsp, sp, #PT_REGS_SIZE<br>#ifdef CONFIG_VMAP_STACK<br>    /*<br>    * Test whether the SP has overflowed, without corrupting a GPR.<br>    * Task and IRQ stacks are aligned so that SP &amp; (1 &lt;&lt; THREAD_SHIFT)<br>    * should always be zero.<br>    */<br>    addsp, sp, x0// sp&#x27; = sp + x0<br>    subx0, sp, x0// x0&#x27; = sp&#x27; - x0 = (sp + x0) - x0 = sp<br>    tbnzx0, #THREAD_SHIFT, 0f<br>    subx0, sp, x0// x0&#x27;&#x27; = sp&#x27; - x0&#x27; = (sp + x0) - sp = x0<br>    subsp, sp, x0// sp&#x27;&#x27; = sp&#x27; - x0 = (sp + x0) - x0 = sp<br>    bel\el\ht\()_\regsize\()_\label                                  // 前面如果成功的话，会跳转到相应的前面定义的elnt_size_name：el0t_64_irq<br><br>0:<br>    ......<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>APUE-Learning-1</title>
    <link href="/2024/07/10/APUE-Learning-1/"/>
    <url>/2024/07/10/APUE-Learning-1/</url>
    
    <content type="html"><![CDATA[<h1 id="UNIX基础知识"><a href="#UNIX基础知识" class="headerlink" title="UNIX基础知识"></a>UNIX基础知识</h1><p>主要介绍了基础的UNIX知识，帮助初学者在UNIX环境下“存活下来”</p><ul><li><p>标准系统函数的返回值，一般来解释如下</p><ul><li><code>&gt;= 0</code> -&gt; 表示程序正常执行</li><li><code>&lt; 0</code> -&gt; 表示程序出错，返回的负数可以表征具体的错误码</li></ul></li><li><p>三个标准“文件描述符”</p><ul><li><code>STDIN_FILENO = 0</code></li><li><code>STDOUT_FILENO = 1</code></li><li><code>STDERR_FILENO = 2</code></li></ul></li><li><p>&lt;unistd.h&gt; : unix std -&gt; 标准头文件，包含了很多UNIX系统服务的函数原型</p><ul><li>有很多<code>unistd.h</code>头文件，用户开发应该使用&lt;unistd.h&gt;，其具体指<code>/usr/inlcude/unistd.h</code></li></ul></li><li><p>不带缓冲的I&#x2F;O <code>VS</code> 标准I&#x2F;O (带缓冲)</p><ul><li>&lt;unistd.h&gt; -&gt; 提供不带缓冲I&#x2F;O的函数原型: read, write, lseek。使用时需要提供<code>缓冲区大小</code>参数</li><li>&lt;stdio.h&gt; -&gt; 提供标准I&#x2F;O的函数原型: scanf, printf。使用时无需担心最优缓冲区大小，因为开发人员无需提供缓冲区大小参数。此外，还定义了标准常量<code>stdin</code>，<code>stdout</code></li></ul></li><li><p>用于进程控制的三个主要函数</p><ul><li>fork：返回值为0，表示处于子进程中；返回值大于0，表示处于父进程中，且返回值为子进程的PID；返回值小于0，fork出错</li><li>exec：有7个变体，统称exec函数</li><li>waitpid：</li><li>fork -&gt; exec函数，创建新进程，执行新的程序</li></ul></li><li><p>头文件组织</p><ul><li>&#x2F;usr&#x2F;include&#x2F;linux, &#x2F;usr&#x2F;inlcude&#x2F;asm* 下的头文件是与Linux内核一起分发的</li><li>&#x2F;usr&#x2F;include&#x2F;sys&#x2F;*.h, &#x2F;usr&#x2F;include&#x2F;bits&#x2F;*.h 下的头文件是与C库一起分发的</li><li><code>LC_ALL=C gcc -v -xc -E /dev/null 2&gt;&amp;1 | sed -ne &#39;/search starts here/,/End of search list/p&#39;</code>用于输出gcc的头文件搜索路径</li></ul></li><li><p>时间相关</p><ul><li><strong>日历时间</strong>：UNIX系统的基本时间服务计算自世界协调时间[1970年1月1日00:00:00]以来经过的秒数，以<code>time_t</code>类型表示，可使用<code>time()</code>获取</li><li><strong>进程时间</strong>[CPU时间]：用以度量进程使用的中央处理器资源，以时钟滴答计算，每秒钟多少个滴答是一种系统配置，使用<code>clock_t</code>类型表示</li></ul><p>  UNIX系统为一个进程维护了3个时间值【进程时间】：</p><ul><li><p>时钟时间[real][墙上时间]，进程运行的时间总量，与系统中同时运行的进程数有关</p></li><li><p>用户CPU时间[user]：执行用户指令所用的时间总量</p></li><li><p>系统CPU时间[sys]：程序执行内核服务的时间总量</p></li><li><p>POSIX扩展规范增加了对多个<strong>系统</strong>时钟的支持，通过<code>clockid_t</code>类型标识不同的POSIX系统时钟</p><ul><li>CLOCK_REALTIME：类型于UNIX系统提供的[real]，但是在系统支持高精度时间值的情况下，可以获得更高精度的时间值</li><li>CLOCK_MONOTONIC：不带负跳数的CLOCK_REALTIME</li><li>CLOCK_PROCESS_CPUTIME_ID：调用函数获取该时间的进程的CPU时间<br>  使用<code>clock_gettime(clockid_t id, struct timespec *tsp)</code>获取不同的系统时钟时间，其中<code> struct timespec</code>采用秒+纳秒的方式来表示时间值</li></ul></li></ul></li></ul><h1 id="UNIX标准及实现"><a href="#UNIX标准及实现" class="headerlink" title="UNIX标准及实现"></a>UNIX标准及实现</h1><ul><li>相关的两个标准<ul><li>ISO C</li><li>IEEE POSIX -&gt; 不区分接口是系统调用还是库函数，统称为函数</li><li>这些标准规范了符号标准的UNIX操作系统必须提供的接口。当然，操作系统要发挥作用，还要有其一般的通用功能。因此可以说，<u>标准定义了任一实际系统的子集</u>。</li><li>有些属于UNIX系统必须，但在符合POSIX标准的系统中是可选的功能</li></ul></li><li>限制<ul><li>幻数、常量的值，在不同系统下的值究竟为多少？具体分为如下两种类型：<ul><li>编译时限制（例如，短整型的最大值是多少？）可在头文件中定义</li><li>运行时限制（例如，文件名最多能有多少个字符？），要求进程调用一个相关的函数获取具体的限制值</li><li>然而有些限制在一个给定的UNIX实现中可能是固定的，而在另一个UNIX实现中则可能是变动的</li></ul></li><li>为了解决这类问题，提供了以下三种限制：<ul><li>编译时限制（头文件）</li><li>与文件或目录无关的运行时限制（<code>sysconf</code>函数）</li><li>与文件或目录有关的运行时限制（<code>pathconf</code>和<code>fpathconf</code>函数）</li><li>如果一个运行时限制在一个给定的UNIX实现上并不改变，则可将其静态地定义在一个头文件中。如果没有将其定义在头文件中，应用程序就必须调用上述的三个<code>conf</code>函数之一以确定其运行时值</li></ul></li><li>ISO C 标准的所有限制都在&lt;limits.h&gt;文件中</li></ul></li></ul><h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><ul><li><p>Unbuffered I&#x2F;O: “不带缓冲”指每个read&#x2F;write都调用内核中的一个系统调用[实际还是会使用内核的缓冲区的]。它们不是ISO C标准，而是POSIX.I的组成部分</p><ul><li>open(), 除非指定<code>O_APPEND</code>flag，否则打开文件时的偏移量都为0，返回值为文件描述符</li><li>lseek(), 显式地为一个已经打开的文件设置偏移量。返回值为添加之后新的文件偏移量。它仅将当前的文件偏移量记录在内核，不会引起任何I&#x2F;O操作<ul><li>相对文件开始的偏移量，只能为+</li><li>相对当前值的偏移量，+-均可</li><li>相对文件结尾的偏移量，+-均可</li></ul></li><li>read(), 返回读到的字节数</li><li>write(), 返回实际写入的字节数</li></ul></li><li><p>多个进程间如何共享文件？【涉及到多进程间资源共享】</p><ul><li>文件描述符表，独属于某个进程，每个描述符表项，包含一个指向某文件表项的指针</li><li>打开文件表，由<strong>内核</strong>维护。每个文件表项包含: 文件状态，<strong>当前文件偏移量</strong>，指向i节点的指针。</li><li>文件系统的i节点表，由<strong>内核</strong>维护。每个打开文件都唯一对应一个i-node节点</li><li>如果有两个进程打开同一个文件：则该文件会有两个文件表项分别对应每个进程；该文件在这两个进程中分别有一个文件描述符；但是该文件只有一个i-node</li></ul></li><li><p>原子操作</p><ul><li>write() 是原子操作的吗？两个进程对该文件同时进行写，如果不加互斥，会出问题吗？</li><li>pwrite() 应该是原子的？</li></ul></li><li><p>文件高级操作</p><ul><li>dup(int fd), dup2(int fd, int fd2)<ul><li>dup() 返回的新描述符一定是当前可用描述符中最小的</li><li>dup2() 可由用户指定fd2为新的描述符；如果fd2已经打开，则先关闭fd2</li><li>这两个函数返回的新描述符与原描述符共享打开文件表项</li></ul></li><li>sync(), fsync(), fdatasync()<ul><li>UNIX系统内核中设有缓冲区，大多数磁盘I&#x2F;O都通过缓冲区进行。例如，当写文件时，内核通常先将数据复制到缓冲区，然后排入队列，晚些时候再写入磁盘，<br>  这种方式称为“延迟写”。</li><li>提供了上述3个函数以保证磁盘上实际文件内容与缓冲区中内容一致</li><li>sync()，将修改过的块缓冲区排入队列，返回。不等待磁盘写操作</li><li>fsync(int fd)，只对由fd指定的文件起作用，且等待实际磁盘I&#x2F;O操作完成</li><li>fdatasync(int fd)，与fsync类型，但是只影响文件数据部分</li></ul></li><li>fcntl(int fd, int cmd, &#x2F;* int arg *&#x2F;)<ul><li>根据cmd的不同，可以提供5大类的功能</li></ul></li><li>ioctl()</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言再学习</title>
    <link href="/2024/07/10/C%E8%AF%AD%E8%A8%80%E5%86%8D%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/10/C%E8%AF%AD%E8%A8%80%E5%86%8D%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="C语言再学习"><a href="#C语言再学习" class="headerlink" title="C语言再学习"></a>C语言再学习</h2><ul><li><p>#incude &lt;&gt; &#x2F; #include “”的区别</p><ul><li>有三个路径需要区分：<ul><li>系统库路径 -&gt; <strong>无需配置</strong>，这个路径已经<u>硬</u>写入了编译器的配置中</li><li>工程定义头文件搜索目录 -&gt; 需要使用编译器提供的参数选项进行配置，例如<code>gcc -I &lt;search_path&gt;</code></li><li>当前目录 -&gt; 无需配置，但是只有使用<code>#include &quot;xxx.h&quot;</code>格式的才会在当前路径下查找</li></ul></li><li>前两种路径都可以使用<code>#inlcude &lt;&gt;</code>进行包含</li></ul></li><li><p>数组与指针变量的区别</p><ul><li>char str[20]; char *ptr_s &#x3D; “abcdefg”;   -&gt; 索引操作：str[5] 与 pstr_s[5]</li><li>str[5]，[汇编层面理解：str表示数组所在的地址]，因此只需要将这个地址加上索引*size，再对新得到的地址进行取值操作即可</li><li>pstr_s[5]，[pstr_s是一个变量，要先取值得到地址值]，之后的操作同上</li><li><strong>作为函数形参</strong>：char *ptr 与 char ptr[]是一样的。这是由于出于性能的考虑，一般把数组传递给函数时，只会传递数组首元素的地址。因此，这两种形参，在函数内部都是得到一个指针。</li></ul></li><li><p>gcc相关编译参数</p><ul><li>-L ：链接时库搜索路径</li><li>-R ：运行时库搜索路径。这个信息会被写入到最终的可执行文件中，并被动态加载其解析使用</li><li>-l : 指定需要参与链接的库</li></ul></li><li><p>little trick -&gt; 静态链接</p><ul><li>gcc -c main.c -lmath -o main  -&gt; 这里源文件出现在库之前</li><li>gcc -lmath -c main.c -o main  -&gt; 库出现在main之前，此时还没有未定义的符号，因此不从库中提取任何符号；因此在链接时可能会报“符号未定义”的错误</li></ul></li><li><p>局部变量及初始化</p><ul><li>不会出现在最终的可执行文件中，运行时在栈上创建</li><li>有明确的代码进行栈空间的开辟，且<strong>初始值会作为指令的操作数</strong>出现在代码段中</li></ul></li><li><p>常见错误：</p><ul><li>总线错误：一般都是由于未对齐的读或写引起</li><li>段错误：通常是由于解引用一个未初始化或非法的地址值引起</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计规范</title>
    <link href="/2024/07/10/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <url>/2024/07/10/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a><a href="http://10.1.14.75/team/compass/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">设计规范</a></h2><ul><li><p>使用指定长度的数据类型，需编译器提供&lt;stdint.h&gt;头文件，或者已知硬件芯片字长的情况下自定义</p></li><li><p>在结构体中，人为添加pad以实现结构体内成员的<strong>自然对齐</strong>，不要依赖编译器进行</p></li><li><p>CPU间通信的数据结构中，不能包含enum类型的变量</p></li><li><p>静态数据表应使用const进行修饰</p><ul><li>一方面，const修饰的通常保存在flash中，节省RAM空间</li><li>其次，防止数据被篡改</li></ul></li><li><p>指针对齐考虑 【这个问题之前还真没有考虑过！！！】</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> buf[<span class="hljs-number">4</span>];             <span class="hljs-comment">// -&gt; 这里buf是1字节对齐的，即buf的值可能为0xc0080001</span><br><span class="hljs-type">uint32_t</span>* ptr_a = buf;      <span class="hljs-comment">// -&gt; 这里ptr_a指向变量类型为4字节对齐，因此ptr_a要求是4字节对齐的。因此，这样赋值可能会出现问题</span><br><br></code></pre></td></tr></table></figure><ul><li>当指针指向的内存地址不能满足指针数据类型的对齐要求时，一般情况下，指针会<strong>向下</strong>做对齐操作。例如指针要求4字节对齐，而指向的地址为0x80000002，指针会自动向下做对齐指向0x80000000地址。</li><li>因此，遇到将小数据类型的地址赋值给大数据类型的指针变量时，要意识到可能会有这种问题的存在</li><li>尤其在回调接口中，为了通用性，一般使用<code>uint8_t*</code>类型的指针，针对用户提供的该指针，后续进行类型强转时，需要先判断其是否符合类型指针对齐的要求，再进行强转操作</li></ul></li><li><p>函数调用时提供函数原型很重要，尤其对于函数返回值；某些情况下，函数形参也很重要，因为涉及到参数入栈</p></li><li><p>独立组件模块：为了提高组件的可移植性，不允许直接使用外部变量，调用外部函数；而是通过回调函数的形式 -&gt; 初始化时，需要向组件注册回调函数，当组件检测到相应场景时，调用相应之前注册的回调函数</p></li><li><p>分层设计：组件与硬件、操作系统等资源相关；将与 <strong>硬件</strong> 、 <strong>操作系统</strong> 等平台相关的代码独立出来，定义成<strong>驱动层</strong>，而与平台无关的代码定义成<strong>核心层</strong>。核心层与驱动层定义一套接口，__接口由核心层定义，驱动来实现__。通过上层应用将驱动层与核心层关联起来，一般采用 <strong>函数指针</strong> 的方式将驱动层与核心关联起来。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CI/CD相关基础</title>
    <link href="/2024/07/10/CI-CD%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/07/10/CI-CD%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="CI-CD相关"><a href="#CI-CD相关" class="headerlink" title="CI&#x2F;CD相关"></a>CI&#x2F;CD相关</h2><ul><li>CI -&gt; 自动化测试<strong>持续集成</strong>， <a href="https://wiki.hikvision.com.cn/pages/viewpage.action?pageId=100687349">参考</a></li><li>**持续集成(CI)**：借助工具对软件项目进行持续的自动化的编译、打包、构建、测试、发布，来检查软件交付质量的一种行为</li><li>**持续部署(CD)**：基于__持续交付__的优势自动将经过测试的代码推入生产环境的过程</li></ul><h3 id="CI各阶段"><a href="#CI各阶段" class="headerlink" title="CI各阶段"></a>CI各阶段</h3><ul><li><em><strong>代码提交阶段</strong></em>：会用到“版本控制工具”进行源代码的版本控制</li><li><em><strong>静态代码检查阶段</strong></em>：只能检查代码语法错误等问题；代码运行时错误需要在后续的流程中进行测试、检查</li><li><em><strong>构建阶段</strong></em>：即 __编译应用程序__；一般包含 __构建验证测试__（检查所有模块是否正确集成？关键功能是否正常？）、__单元测试__（验证开发人员编写的单个元件、组件是否按预期执行）；还要将经过前期验证的 <strong>构建产物存储</strong> 起来</li><li><em><strong>测试阶段</strong></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SVN简单学习</title>
    <link href="/2024/07/10/SVN%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/10/SVN%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="SVN-command"><a href="#SVN-command" class="headerlink" title="SVN command"></a>SVN command</h2><ul><li><p>“改名”操作需要使用SVN进行，不要使用Windows下面的重命名，因为这个操作不受 SVN 控制，SVN 会将其理解为删除原文件、增加一个新文件，从而导致文件改名后不能跟踪到改名前的状态</p></li><li><p>“受SVN控制”是个挺重要的概念，在本地新建文件后，需要使用<code>add</code>操作将该新建文件纳入SVN的控制中；因此<strong>所有的操作最好都使用SVN进行</strong>，包括</p><ul><li>创建新文件&#x2F;夹，创建后要使用<code>add</code>操作</li><li>移动文件&#x2F;夹</li><li>修改文件&#x2F;夹的名字</li><li>删除文件&#x2F;夹</li><li>尽量不要使用Windows&#x2F;Linux提供的文件&#x2F;夹修改功能</li></ul></li><li><p>“更新至版本（U）” -&gt; 用于取回某个历史版本到本地 【类似git里面的checkout？】</p></li><li><p>“还原（V）” -&gt; 只能在“提交”到远程服务器之前进行，用于放弃本地的某些操作【可选的】</p></li><li><p>“复原（显示日志，选择某个要还原的版本）”，在某历史版本上进行后续的操作，提交后此版本将作为远程版本库的最新版本</p></li><li><p>“branch” -&gt; 先在远程创建分支，<strong>再更新</strong>到本地 【与git操作不同】，分支的基点可以选择三种不同的方式：</p><ul><li>“最新版本”，以最先版本作为基点</li><li>“指定版本”</li><li>“工作副本”，以本地工作副本作为基点？【这个内容需要进一步确认】【这个代表什么意思？】【已确认：就是本地工作空间】</li></ul></li><li><p>“合并分支操作” -&gt; </p><ul><li>先将自己工作的分支cyokeo-r1，提交到远程服务器</li><li>拉取要合并到的<code>分支</code>到本地，在该分支的文件夹上点击进行<code>合并</code>操作</li><li>感觉SVN的合并，一般是<code>Leader</code>干的活？</li><li>合并，并解决完冲突后，进行提交操作</li></ul></li><li><p>“切分支”</p><ul><li>优先使用CI进行SVN路径切分支操作，方便CI进行代码目录的继承关系管理。【CI是？】</li><li>CI无法满足要求时，使用SVN客户端切分支，要使用SVN工具的branch&#x2F;tag功能，而不要先下载下来再人为上传到新的目录。如果采用SVN的branch&#x2F;tag功能，只是创建了一个”副本”，方便版本追溯</li></ul></li><li><p>提交颗粒度尽量小，以减小他人合并的难度</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>距离相关</title>
    <link href="/2024/07/09/%E8%B7%9D%E7%A6%BB%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/07/09/%E8%B7%9D%E7%A6%BB%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://oi-wiki.org/geometry/distance/">距离</a></li></ul><h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><ul><li>D(A, B) &#x3D; abs(x1 - x2) + abs(y1 - y2)</li><li>(x, y) -&gt; (x+y, y-x)后，新坐标系下的切比雪夫距离为原坐标系下的曼哈顿距离</li><li><a href="https://leetcode.cn/problems/minimize-manhattan-distances/description/">3102. 最小化曼哈顿距离</a></li><li></li></ul><h2 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h2><ul><li>D(A, B) &#x3D; max(|x1 - x2|, |y1 - y2|)</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动规题单</title>
    <link href="/2024/07/07/%E5%8A%A8%E8%A7%84%E9%A2%98%E5%8D%95/"/>
    <url>/2024/07/07/%E5%8A%A8%E8%A7%84%E9%A2%98%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="我的动态规划题单"><a href="#我的动态规划题单" class="headerlink" title="我的动态规划题单"></a>我的动态规划题单</h2><p>动态规划有两个难点：</p><ul><li>不知道是否应该使用动态规划</li><li>动态规划的递推推导不出来</li></ul><h2 id="递推关系不太难想的，一般都很难想到使用动态规划的方法"><a href="#递推关系不太难想的，一般都很难想到使用动态规划的方法" class="headerlink" title="递推关系不太难想的，一般都很难想到使用动态规划的方法"></a>递推关系不太难想的，一般都很难想到使用<u>动态规划</u>的方法</h2><ul><li><a href="https://leetcode.cn/problems/wildcard-matching/description/">44. 通配符匹配</a><ul><li>这个题目有个点：<code>&#39;*&#39;</code>是万能的，连续的<code>‘*’</code>和一个<code>‘*’</code>是一样的</li></ul></li><li>[10. 正则表达式匹配]</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c/cpp小技巧</title>
    <link href="/2024/07/06/c-cpp%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/07/06/c-cpp%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="如何计算负数的补码"><a href="#如何计算负数的补码" class="headerlink" title="如何计算负数的补码"></a>如何计算负数的补码</h2><ul><li>负数一般以补码的形式存储</li><li>如果位数为(8), 则负数a的补码为<code>pow(2,n) - abs(a)</code></li><li>另外，负数a的补码也可根据：abs(a)的反码 + 1 得到</li></ul><h2 id="lambda把自身作为形参"><a href="#lambda把自身作为形参" class="headerlink" title="lambda把自身作为形参"></a>lambda把自身作为形参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// bool u_compare(string&amp; l, string* r)</span><br><span class="hljs-comment">// &#123;</span><br><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">accountsMerge</span>(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) &#123;<br>        unordered_map&lt;string, vector&lt;<span class="hljs-type">int</span>&gt;&gt; mp;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; accounts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; accounts[i].<span class="hljs-built_in">size</span>(); j++)<br>            &#123;<br>                mp[accounts[i][j]].<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(accounts.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        unordered_set&lt;string&gt; mails;<br>        <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span>&amp;&amp; dfs, <span class="hljs-type">int</span> idx) -&gt; <span class="hljs-type">void</span> &#123;<br>            <span class="hljs-keyword">if</span> (vis[idx] == <span class="hljs-literal">false</span>)<br>            &#123;<br>                vis[idx] = <span class="hljs-literal">true</span>;<br>               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; accounts[idx].<span class="hljs-built_in">size</span>(); i++)<br>               &#123;<br>                    mails.<span class="hljs-built_in">insert</span>(accounts[idx][i]);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : mp[accounts[idx][i]])<br>                    &#123;<br>                        <span class="hljs-built_in">dfs</span>(dfs, it);<br>                    &#125;<br>               &#125; <br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vis.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!vis[i])<br>            &#123;<br>                mails.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-built_in">dfs</span>(dfs, i);<br>                vector&lt;string&gt; tmp&#123;accounts[i][<span class="hljs-number">0</span>]&#125;;<br>                tmp.<span class="hljs-built_in">insert</span>(tmp.<span class="hljs-built_in">end</span>(), mails.<span class="hljs-built_in">begin</span>(), mails.<span class="hljs-built_in">end</span>());<br>                <span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, tmp.<span class="hljs-built_in">end</span>());<br>                ans.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2024/07/06/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/06/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/575568/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86">leetcode 宫水三叶</a></li><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/2600821/kan-bu-dong-ni-da-wo-kmp-suan-fa-chao-qi-z1y0">从next数组的求解解读KMP算法</a></li><li><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF">还是carl的好理解一些</a></li></ul><h2 id="解决场景"><a href="#解决场景" class="headerlink" title="解决场景"></a>解决场景</h2><ul><li>如何快速在「原字符串」中找到「匹配字符串」</li><li>时间复杂度：O(m + n)，其中m，n分别为原字符串，待匹配字符串的长度</li><li>其能在「非完全匹配」的过程中提取到有效信息进行复用，以减少「重复匹配」的消耗。</li></ul><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ul><li>next数组是模式串的相同最长前后缀长度表</li><li>next[j]表示模式串中，字串[0, j-1]的相同最长前后缀的长度</li><li>“a”，“”，“abc”的最长前后缀长度均为0；“aabcaa”的最长相同前后缀的长度为2</li><li>当主串的第i个位置和模式串的第j个位置不相同时，模式串的匹配只需<strong>回退</strong>到 j’ &#x3D; next[j]的下一个位置。因为可以保证：<code>模式串的前j&#39;个字符[0, j&#39;]与主串第i个位置前的j&#39;个字符是相同的</code></li></ul><h2 id="如何求模式串的next数组"><a href="#如何求模式串的next数组" class="headerlink" title="如何求模式串的next数组"></a>如何求模式串的next数组</h2><ul><li><p>“abcabd”</p></li><li><p>“abacabad”：</p>  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="language-ruby">&gt; <span class="hljs-symbol">b:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> 所在的位置与b不同；由于<span class="hljs-keyword">next</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>，所以<span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">2</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">c:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span> 所在的位置与c不同；<span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> 所在的位置与c不同；因此<span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">b:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span> 所在的位置与b相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] = <span class="hljs-number">2</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">3</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">d:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>] = <span class="hljs-number">3</span> 所在的位置与d不同；<span class="hljs-keyword">next</span>[<span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>]] = <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>；因此<span class="hljs-keyword">next</span>[<span class="hljs-number">7</span>] = <span class="hljs-number">0</span>;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="字符串哈希（https-leetcode-cn-problems-shortest-palindrome-solutions-1396220-by-flix-be4y"><a href="#字符串哈希（https-leetcode-cn-problems-shortest-palindrome-solutions-1396220-by-flix-be4y" class="headerlink" title="字符串哈希（https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y)"></a>字符串哈希（<a href="https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y">https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y</a>)</h2><ul><li>构造next数组的算法：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = tmp.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-type">int</span> k = i<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; tmp[next[k]] != tmp[i]) &#123;k = next[k]<span class="hljs-number">-1</span>;&#125;<br>    <span class="hljs-keyword">if</span> (k &gt;= <span class="hljs-number">0</span>) next[i] = next[k] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> next[i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h2><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></li><li><a href="https://leetcode.cn/problems/shortest-palindrome/solutions/392561/zui-duan-hui-wen-chuan-by-leetcode-solution/">214. 最短回文串</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题目复习</title>
    <link href="/2024/07/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/07/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li><p>模版总结</p><ul><li>一定是条件满足时，更新最终结果</li><li>首先最外部的循环<code>while (j &lt; len)</code></li><li>接着内部有一个while循环，需要在里面压缩i<ul><li>条件成立进while：最小窗口；更新值；更新条件；<code>i++</code></li><li>条件不成立进while：最大窗口；更新条件；<code>i++</code></li></ul></li><li>接着走出while循环<ul><li><code>j++</code></li></ul></li></ul></li><li><p>破题思路：<em><strong>窗口应该满足什么条件</strong></em> or <em><strong>不满足什么条件</strong></em>！！！</p></li><li><p>904.水果成篮，结合<a href="https://leetcode.cn/problems/fruit-into-baskets/solutions/1437444/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr">题解</a>，深入理解：</p><ul><li>最大滑动窗口 - 模版  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(nums):<br>    // 判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> 不满足条件：<br>        i += <span class="hljs-number">1</span> //（最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）<br>    // 不断更新结果（注意在<span class="hljs-keyword">while</span>外更新！）<br>    j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>最小滑动窗口 - 模版  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(nums):<br>    // 判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> 满足条件：<br>        // 不断更新结果(注意在<span class="hljs-keyword">while</span>内更新！)<br>        i += <span class="hljs-number">1</span> //（最大程度的压缩i，使得滑窗尽可能的小）<br>    j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>确实，有了模版后，遇到滑窗问题，思路更加清晰了<ul><li>破题思路：<em><strong>窗口应该满足什么条件</strong></em> or <em><strong>不满足什么条件</strong></em>！！！</li><li>最大窗口：<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/">2024. 考试的最大困扰度</a></li><li>最小窗口：<a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">1234. 替换子串得到平衡字符串</a><ul><li>这个题目还是比较难，需要好好思考转换一下思路！！！</li><li>窗口应该满足：<em><strong>包含的多的字符的个数应该 <code>&gt;=</code> 需要替换的个数</strong></em></li></ul></li></ul></li></ul></li><li><p><a href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/submissions/546160358/">1838.最高频元素的频数</a></p><ul><li>需要动脑思考一下，察觉为使用滑动窗口</li><li>而且在做减法的时候有一个溢出问题：<em><strong>啊啊啊啊啊！！！</strong></em></li></ul></li></ul><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><ul><li><p>字符串哈希：使用hash映射，减小索引的存储消耗！！！<a href="https://leetcode.cn/problems/repeated-dna-sequences/solutions/1035568/zhong-fu-de-dnaxu-lie-by-leetcode-soluti-z8zn">参考</a></p><ol><li>选取一个大于字符集大小的质数作为<code>base</code></li><li>将字符映射为小于base的数：<code>int fx = map(x)</code></li><li><code>&quot;abccd&quot; = map(a)*base^0 + map(b)*base^1 + map(c)*base^2 + map(c)*base^3 + map(d)*base^4</code></li><li><a href="https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y">参考</a></li></ol></li><li><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-word-k-periodic/">3137. K 周期字符串需要的最少操作次数</a></p><ul><li>这个题目比较典型，再复习一下cpp中的数据类型及范围</li><li>尝试使用<code>long long</code>但是超出了范围</li><li>该用<code>string</code>直接作为哈希key，但是时间性能较差</li><li>尝试使用<code>double</code>，因为其采用浮点表示法，范围更大但是精度差点；有些案例过不去</li><li>使用<code>unsigned long long</code>，这是能表示的最大整数范围了，通过了</li><li>没必要使用map，改为使用unorder_map，时间性能有提升</li></ul></li><li><p><a href="https://leetcode.cn/problems/minimum-area-rectangle/description/">939. 最小面积矩形</a></p><ul><li>对二维坐标点进行hash<ul><li>题目规定坐标值的范围在[0, 40000]</li><li>因此选取质数40001作为hash的底</li><li>直接选<code>pair&lt;int, int&gt;</code>作为<code>key</code></li></ul></li></ul></li><li><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solutions/2551432/liang-chong-fang-fa-ni-xiang-si-wei-zhen-e3gb">最大&#x2F;小子序和</a></p><ul><li>通过取相反数，将最小子序和转化为最大字序和问题</li><li>前缀和法</li><li>贪心 + dp 法  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cardPoints)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> maxSubArray = [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>            <span class="hljs-comment">//实现1：前缀和</span><br>            <span class="hljs-comment">// int res = INT_MIN, pre_sum = 0, min_pre_sum = 0;</span><br>            <span class="hljs-comment">// for (auto&amp; x : nums) &#123;</span><br>            <span class="hljs-comment">//     pre_sum += x;</span><br>            <span class="hljs-comment">//     res = max(res, pre_sum - min_pre_sum);</span><br>            <span class="hljs-comment">//     min_pre_sum = min(min_pre_sum, pre_sum);</span><br>            <span class="hljs-comment">// &#125;</span><br>            <span class="hljs-comment">// return res;</span><br><br>            <span class="hljs-comment">//实现2：贪心 + dp</span><br>            <span class="hljs-comment">//s = 0考虑了k = 0时的情况</span><br>            <span class="hljs-type">int</span> res = INT_MIN, s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : nums) &#123;<br>                <span class="hljs-keyword">if</span> (s &lt;= <span class="hljs-number">0</span>) s = <span class="hljs-number">0</span>;<br>                s += x;<br>                res = <span class="hljs-built_in">max</span>(res, s);<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-comment">//累加总和为s</span><br>        <span class="hljs-type">int</span> s = <span class="hljs-built_in">accumulate</span>(cardPoints.<span class="hljs-built_in">begin</span>(), cardPoints.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//将数组的每个元素乘以-1, 用来求连续子数组的最大和</span><br>        <span class="hljs-built_in">transform</span>(cardPoints.<span class="hljs-built_in">begin</span>(), cardPoints.<span class="hljs-built_in">end</span>(), cardPoints.<span class="hljs-built_in">begin</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> -x; &#125;);<br>        <span class="hljs-comment">//答案 = 总和 - 连续子数组的最小和</span><br>        <span class="hljs-keyword">return</span> s - (-<span class="hljs-built_in">maxSubArray</span>(cardPoints));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h2><ul><li><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a><ul><li>加深理解：如果字串长度为奇数，则只能为<code>aba</code>类型；但是当字串长度为偶数时，可以为<code>aa</code>，也可以为<code>abaaba</code>！！！</li><li>自己想到了使用dp数组，记忆化遍历，以减小重复遍历。但是时间表现还是很差❗️❗️</li><li>注意到回文串的<em><strong>中间部分一定是由连续且相同的字符</strong></em>串组成，因此可以定位到中间字符，再左右扩展查询，<a href="https://leetcode.cn/problems/longest-palindromic-substring/description/comments/59461">参考</a>❗️<ul><li>这样中间部分根据奇偶，可以统一处理  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><span class="hljs-comment">//         保存起始位置，测试了用数组似乎能比全局变量稍快一点</span><br>        <span class="hljs-type">int</span>[] range = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">char</span>[] str = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><span class="hljs-comment">//             把回文看成中间的部分全是同一字符，左右部分相对称</span><br><span class="hljs-comment">//             找到下一个与当前字符不同的字符</span><br>            i = findLongest(str, i, range);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(range[<span class="hljs-number">0</span>], range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLongest</span><span class="hljs-params">(<span class="hljs-type">char</span>[] str, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span>[] range)</span> &#123;<br><span class="hljs-comment">//         查找中间部分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">while</span> (high &lt; str.length - <span class="hljs-number">1</span> &amp;&amp; str[high + <span class="hljs-number">1</span>] == str[low]) &#123;<br>            high++;<br>        &#125;<br><span class="hljs-comment">//         定位中间部分的最后一个字符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> high;<br><span class="hljs-comment">//         从中间向左右扩散</span><br>        <span class="hljs-keyword">while</span> (low &gt; <span class="hljs-number">0</span> &amp;&amp; high &lt; str.length - <span class="hljs-number">1</span> &amp;&amp; str[low - <span class="hljs-number">1</span>] == str[high + <span class="hljs-number">1</span>]) &#123;<br>            low--;<br>            high++;<br>        &#125;<br><span class="hljs-comment">//         记录最大长度</span><br>        <span class="hljs-keyword">if</span> (high - low &gt; range[<span class="hljs-number">1</span>] - range[<span class="hljs-number">0</span>]) &#123;<br>            range[<span class="hljs-number">0</span>] = low;<br>            range[<span class="hljs-number">1</span>] = high;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><ul><li>得先想出递归的完整方案</li><li>将递归的参数引入记忆化搜索中</li><li><em><strong>记忆化搜索key压缩技术</strong></em></li></ul><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><ul><li><a href="https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/">3154. 到达第 K 级台阶的方案数</a><ul><li>想到了递归方案 -&gt; 但是边界条件的处理不适合转化为记忆化<ul><li>想到的递归没有带返回值</li></ul></li><li>但是没有想出如何进行递归话搜索</li><li>边界条件处理的逻辑</li><li><em><strong>还是子问题的逻辑没有想好</strong></em></li></ul></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="解题参考"><a href="#解题参考" class="headerlink" title="解题参考"></a><a href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/solutions/2321829/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-hzz6">解题参考</a></h3><ul><li><p>从寻找子问题的思路出发</p></li><li><p>找到dfs各参数</p></li><li><p>子序列 DP 的思考套路</p><ul><li>子序列 + 不考虑相邻元素：<strong>选或不选</strong>。代表题目：<a href="https://leetcode.cn/problems/target-sum/">494. 目标和（0-1 背包）</a><ul><li><em><strong>到达该stage时，该stage对应的结果为下面两种情况的叠加</strong></em><ul><li>选择该stage代表的内容</li><li>不选择该stage代表的内容</li></ul></li><li>自己想到了全量的递推做法</li><li>可以采用数学推导：target确定时，前面为<code>+</code>的和也就确定了，因此题目转化为找物品塞满背包的方法有多少种</li></ul></li><li>子序列 + 考虑相邻元素：<strong>枚举选哪个</strong>。代表题目：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a><ul><li><em><strong>到达某个stage时，在前面哪个状态的基础上转移到该状态是最好的</strong></em>？需要枚举选择状态最好的</li></ul></li><li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></li><li><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/">2901. 最长相邻不相等子序列 II</a><ul><li>下面这个题目只想到了子序列的回溯做法，但是超时了</li><li>这两个题目很像，思路很像。第二个题目只是将条件<em><strong>严格递增</strong></em>简单的替换为一个比较复杂的条件；其余思路都是一样的</li><li><em><strong>记录节点路径的方法值得仔细回味</strong></em></li></ul></li></ul></li></ul><h3 id="经典问题-1"><a href="#经典问题-1" class="headerlink" title="经典问题"></a>经典问题</h3><ul><li><p><a href="https://leetcode.cn/problems/maximum-difference-score-in-a-grid/">3148. 矩阵中的最大得分</a></p><ul><li>得好好总结一下，怎么动🧠！！！</li><li>得动动笔啊啊啊啊啊</li><li><a href="https://leetcode.cn/problems/maximum-difference-score-in-a-grid/solutions/2774823/nao-jin-ji-zhuan-wan-dppythonjavacgo-by-swux7">二维前缀+维护列最小</a></li><li><a href="https://leetcode.cn/problems/maximum-difference-score-in-a-grid/solutions/2880985/python3javacgotypescript-yi-ti-yi-jie-do-6g35">维护行列最小值</a></li></ul></li><li><p><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a></p><ul><li>double, long long等数据类型的区别</li></ul></li><li><p><a href="">1186. 删除一次得到子数组最大和</a></p><ul><li>需要动态规划，但是没有想起来</li><li>计算递推时要严谨一些，好好看看下面对递归的步步推导与解释❗️</li><li>动态规划有「选或不选」和「枚举选哪个」这两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考</li></ul></li><li><p><a href="">3098. 求出所有子序列的能量和</a></p><ul><li>这个困难题对于动归非常典型</li><li>它的递推公式真的很难想到</li><li>典型的<em><strong>先想到递归&#x2F;回溯做法，再反推出动规的做法</strong></em></li><li><a href="https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/solutions/2854316/yi-ti-san-jie-pai-xu-ji-yi-hua-sou-suo-y-bj6a">题解</a>：这个题解是比较清楚的</li></ul></li><li><p><a href="https://leetcode.cn/problems/minimum-sum-of-values-by-dividing-array/">3117. 划分数组得到最小的值之和</a></p><ul><li>和上面这个挺像的</li><li>dfs + 记忆化递推</li><li>想到把前面and的结果传到递归函数中去比较难☹️</li><li>记忆化递推的记忆化key想的还不到位</li><li>选或不选！枚举选哪个！</li></ul></li><li><p><a href="https://leetcode.cn/problems/letter-tile-possibilities/description/">1079. 活字印刷</a></p><ul><li>动态规划递推公式难推导啊！！</li><li>从推导子问题开始</li><li><a href="https://leetcode.cn/problems/letter-tile-possibilities/solutions/2275356/on2-ji-shu-dppythonjavacgo-by-endlessche-hmez">题解</a><ul><li>这个题解中，想到使用种类数作为<code>dp[i][j]</code>中的i是有些难度的！！！</li><li>需要较多的<code>数学思考</code></li></ul></li></ul></li><li><p><a href="https://leetcode.cn/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a></p><ul><li>暴力动态规划</li></ul></li></ul><h2 id="匹配-全排列"><a href="#匹配-全排列" class="headerlink" title="匹配 + 全排列"></a>匹配 + 全排列</h2><p>具有明显的匹配意味，使用<code>next_permutation()</code>对其中一个求取全排列，并与另一个进行组合，记录最值</p><ul><li><p><a href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/description/">2850. 将石头分散到网格图的最少移动次数</a></p><ul><li>这题想到这一点还是需要一些思考的：主要注意到均值为1，为0的格子和不为0的格子-1后的和是一致的</li></ul></li><li><p><a href="https://leetcode.cn/problems/maximum-compatibility-score-sum/description/">1947. 最大兼容性评分和</a></p></li><li><p><a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II</a></p><ul><li>含有重复元素的排列问题</li><li>非常经典的回溯解法，有一个“去重”的处理值得体会</li><li>使用used数组进行访问记录，所以遍历当前层时总是从0开始</li></ul></li></ul><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><ul><li><a href="https://leetcode.cn/problems/remove-k-digits/submissions/549759198/">402. 移掉 K 位数字</a><ul><li><a href="https://leetcode.cn/problems/remove-k-digits/solutions/290203/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5">题解</a></li><li>使用vector模拟栈</li></ul></li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><p><a href="https://leetcode.cn/problems/task-scheduler/submissions/546146727/">621. 任务调度器</a></p><ul><li>全排列任务，相同类型任务之间得间隔space，问完成任务的最短时间！</li><li>需要动脑袋思考一下</li><li>当时怎么想出来这种纯数学的计算的？-&gt;似乎没有证明其正确性</li><li>“贪心数学”</li></ul></li><li><p><a href="https://leetcode.cn/problems/task-scheduler-ii/">2365. 任务调度器 II</a></p><ul><li>任务顺序给定，相同任务之间得间隔space，求完成任务的最短时间</li><li>简单模拟即可</li><li>自己想到了DP，在DP的基础上优化即可<ul><li>一维数组变为一个变量</li></ul></li><li>总结一下这两个题目</li></ul></li><li><p><a href="https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-ii/description/">2972. 统计移除递增子数组的数目</a></p></li><li><p><a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/">1574. 删除最短的子数组使剩余数组有序</a></p><ul><li>与2972的思路一样</li></ul></li><li><p><a href="https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/description/">1712. 将数组分成三个子数组的方案数</a></p><ul><li>前缀和，需要动笔简单算一下</li></ul></li><li><p><a href="https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/description/">2106. 摘水果</a></p><ul><li>需要思考想到为前缀和</li><li>简单计算区间公式</li></ul></li><li><p><a href="https://leetcode.cn/problems/number-of-provinces/solutions/550179/dfs-bfs-bing-cha-ji-3-chong-fang-fa-ji-s-edkl/">547. 省份数量</a></p><ul><li>使用并查集</li></ul></li><li><p><a href="">721. 账户合并</a></p><ul><li>并查集</li></ul></li></ul><h2 id="对一个数组求子序列的两种回溯方法差异"><a href="#对一个数组求子序列的两种回溯方法差异" class="headerlink" title="对一个数组求子序列的两种回溯方法差异"></a>对一个数组求子序列的两种回溯方法差异</h2><ul><li><p><a href="">3098. 求出所有子序列的能量和</a></p></li><li><p>不使用for</p></li><li><p>使用for</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> m_min, <span class="hljs-type">int</span> last)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>        result += m_min;<br>        result %= (<span class="hljs-number">1000000000</span> + <span class="hljs-number">7</span>); <br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i + left &gt; nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">int</span> n_min = m_min;<br>            <span class="hljs-keyword">if</span> (last &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                n_min = <span class="hljs-built_in">min</span>(m_min, nums[i] - nums[last]);<br>            &#125;<br>            <span class="hljs-comment">// 注意这里每一次递归都表示选当前元素</span><br>            <span class="hljs-built_in">traversal</span>(nums, i+<span class="hljs-number">1</span>, left<span class="hljs-number">-1</span>, n_min, i);<br>            <span class="hljs-comment">// 针对每个i，到这里都表示不选当前元素</span><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfPowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">traversal</span>(nums, <span class="hljs-number">0</span>, k, INT32_MAX, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>提问记录</title>
    <link href="/2024/06/28/%E6%8F%90%E9%97%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/28/%E6%8F%90%E9%97%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="24-06-27"><a href="#24-06-27" class="headerlink" title="24-06-27"></a>24-06-27</h2><ol><li><p>DDS可靠性相关 -&gt; 如何保证可靠性？接收端来不及处理时，如何保证？</p><ul><li>DDS可以理解为是一种传输协议，它的可靠性可以保证：发端发送一条消息后，可以到达接收端的DDS协议栈中，并驻留在接收端的History中。如果接收端的应用层来不及处理新收到的消息，那就不立即处理，后续可以使用read接口从协议栈中获取之前接收到的数据。</li><li>上述可能会出现接收端缓存满，而尚有消息未处理的情况：此时，就需要扩大History的消息缓存数目。这里就是History QoS 与 Resource QoS这两种不同服务质量要求之间的trade了。</li></ul></li><li><p>MCU上做开发与Linux用户态开发有什么不同？分别有哪些需要注意的内容？</p><ul><li>MCU上直接看到真实物理内存，Linux用户态多了一层虚拟地址转换。因此在MCU上做开发时，更要注意对指针的使用。</li><li>MCU上有时Linker，链接脚本，程序、变量存放位置；Linux用户态不用考虑这些问题。</li><li>调试时，MCU上遇到TRAP等问题，要去翻具体的芯片架构手册进行排查；Linux用户态有一套标准的exception机制。</li><li>MCU上做开发更类似于Linux内核态驱动开发。</li><li>MCU上有时需要考虑boot的问题，Linux用户态不用考虑。</li><li>MCU上开发一般只会用到静态库，而Linux上还会有动态库。</li></ul></li><li><p>(之前软硬件结合提到了对指针的“恍然大悟”)那你现在是如何理解指针的？</p><ul><li>指针就是一个普通的变量，对它进行加减乘除，函数参数，就像普通变量那样使用</li><li>重点在于如何使用指针变量，如何解释指针 -&gt; 这里就得说一下指针类型转换</li><li>使用时，相比于普通变量，要多考虑一层：它指向了某块内存区域！内存区域的大小与指针指向的对象类型有关</li><li>指针使用：大部分都会取成员 -&gt; 指针指向的对象类型是什么？这个问题也要时刻注意</li><li>c++中，class C 继承于 class B , class A。<code>C v_c; B* p_b = &amp;v_c; A* p_a = &amp;v_c</code>，这三行语句，p_b的值与p_a的值是不一样的！</li><li>在c语言中，常把指针和数组进行比较。</li></ul></li><li><p>用一个词形容操作系统</p><ul><li>管理者</li><li>根据管理的内容不同，OS又可以分为宏内核&#x2F;微内核</li><li>MCU上的OS一般只有CPU管理的功能</li><li>SoC上使用基于Linux的操作系统，还会有内存管理，进程通信，文件系统等功能</li></ul></li></ol><h2 id="24-07-04"><a href="#24-07-04" class="headerlink" title="24-07-04"></a>24-07-04</h2><ol><li><p>如何在不使用额外变量的情况下，交换两个整形变量的值</p><ul><li><p>方法一：采用数学运算</p> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = x + y<span class="hljs-comment">;  // -&gt; 虽然这里可能会有溢出的情况，但**由于**负数采用补码的方式表示，后续运算后，也能实现交换的目的</span><br><span class="hljs-attr">y</span> = x - y<span class="hljs-comment">;</span><br><span class="hljs-attr">x</span> = x - y<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>方法二： 采用异或运算</p> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = x ^ y<span class="hljs-comment">;</span><br><span class="hljs-attr">y</span> = x ^ y<span class="hljs-comment">;</span><br><span class="hljs-attr">x</span> = x ^ y<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>叠砖块问题</p><ul><li>要保证第二块及以上所有砖的“重心和”落在第一块砖内<br>这题要分情况讨论：</li><li>如果每块砖伸出的长度可以自由调整， <a href="https://max.book118.com/html/2018/0103/147107237.shtm">参考</a>，可以证明：以1&#x2F;2n的规律无限延伸</li><li>如果每块砖伸出的长度为固定大小，可以证明：最远可伸出1&#x2F;2n</li></ul></li><li><p>“叠砖块问题”的启发</p><ul><li>面试时要大胆的说出自己的直觉，并且额外补充说明：需要进一步的分析与证明</li></ul></li><li><p>有符号数溢出问题</p><ul><li>要注意负数以补码的形式存储：绝对值的反码+1</li><li>unsigned char 和 signed char表示的数据范围是不一样的</li></ul></li><li><p>位数扩展</p><ul><li>有符号数：转为更大数据类型采用的是<strong>符号扩展</strong> -&gt; 添加最高有效位的值【正为0， 负为1】</li><li>无符号数：转换为更大数据类型采用的是<strong>零扩展</strong> -&gt; 添加0</li></ul></li><li><p>CPU位数&#x2F;字长</p><ul><li><a href="https://www.cnblogs.com/komorebi-514/p/16174395.html">机器字长、存储字长、指令字长</a></li><li>CPU位数 <strong>&#x3D;</strong> CPU中寄存器位数 <strong>&#x3D;</strong> CPU一次能够并行处理的数据宽度</li><li>～&#x3D; 数据总线宽度【一般来说】</li><li>机器字长 <strong>～&#x3D;</strong> 数据总线宽度</li></ul></li></ol><h2 id="24-07-27"><a href="#24-07-27" class="headerlink" title="24-07-27"></a>24-07-27</h2><ol><li>当一个问题卡了一段时间，切没有任何头绪的时候，说明需要补相关的知识了</li><li>站在更高层级【本质层级】去看一个问题，就会很通透</li></ol><h2 id="24-08-01"><a href="#24-08-01" class="headerlink" title="24-08-01"></a>24-08-01</h2><ol><li><p>如何理解声明与定义</p><ul><li>对于变量的声明与定义</li></ul><blockquote><p><mark>声明</mark>：不会为变量分配地址和内存空间，仅说明变量的性质</p><ul><li><p>变量的声明必须得加上extern</p></li><li><p>函数的声明可加可不加</p></li></ul><p><mark>定义</mark>：会为变量分配地址和内存空间</p><ul><li>函数定义时一定有函数体</li></ul></blockquote><ul><li>对于结构体类型的声明和定义</li></ul><blockquote><p>一般前置声明用的比较多，用于解决结构体嵌套定义问题</p><p>定义就比较容易理解了</p></blockquote></li><li><p>扩展</p><ul><li>C语言中变量有<mark>存储类型</mark>和<mark>数据类型</mark>两种类型</li></ul><blockquote><p>存储类型-相关的关键字</p><ul><li><p>自动变量（auto）—&gt; 很少使用</p></li><li><p>静态变量 （static）–&gt; 具有隐藏符号的作用</p></li><li><p>外部变量 （extern) </p><ul><li><p>相对于 static来识记就比较简单了</p></li><li><p><u>在函数外部定义的变量，如果没有为其指定存储类型，那么它默认为extern类型</u></p></li><li><p>int a; int a; 是可以的</p></li></ul></li><li><p>寄存器变量 (register)  -&gt; 很少使用</p></li></ul></blockquote></li><li><p>C vs CPP</p></li><li><p>遇到最困难的事情</p><ul><li><p>从0到1是最困难的</p></li><li><p>自己也乐于从0到1的过程</p></li><li><p>看RTOS的代码：-&gt; 自己也希望今后有机会针对一款全新的芯片，完成Linux&#x2F;甚至自研操作系统的bring up</p><ul><li><p>任务切换</p></li><li><p>初始任务上下文的构建【栈指针、函数入口】</p></li><li><p>过程中涉及到架构相关的寄存器操作：</p><ul><li><p>特权级</p></li><li><p>arm64的四种特权级切换</p></li></ul></li><li><p>glibc -&gt; linux ABI规范的遵守</p><ul><li>系统调用约定</li></ul></li></ul></li></ul></li></ol><h2 id="24-08-10"><a href="#24-08-10" class="headerlink" title="24-08-10"></a>24-08-10</h2><ul><li>自我思考</li></ul><h3 id="CAN-FlexRay-Ethernet"><a href="#CAN-FlexRay-Ethernet" class="headerlink" title="CAN -&gt; FlexRay -&gt; Ethernet"></a>CAN -&gt; FlexRay -&gt; Ethernet</h3><ul><li>速率提升</li><li>实时性方面</li></ul><h2 id="24-08-12"><a href="#24-08-12" class="headerlink" title="24-08-12"></a>24-08-12</h2><ol><li>Linux的几种调度策略</li><li>实时调度策略是怎么实现的<ul><li>详见[[Linux - 调度策略]]</li></ul></li><li>智能指针使用时的注意事项<ul><li>循环引用<ul><li>管理的对象内部含有智能指针，且形成循环引用</li></ul></li><li><code>make_shared</code> vs <code>std::shared_ptr(object)</code></li><li>多线程修改引用计数：原子操作，线程安全</li><li>裸指针和智能指针混用<ul><li>将裸指针赋给智能指针，却又在退出作用域时，主动delete裸指针 &#x3D;&gt; 造成double delete</li></ul></li><li>智能指针混用：出作用域时，都释放，导致double<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br> <span class="hljs-function">std::unique_ptr&lt;Type&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Type)</span></span>;<br> <span class="hljs-function">std::shared_ptr&lt;Type&gt; <span class="hljs-title">t1</span><span class="hljs-params">(t.get())</span></span>; <br>&#125;<br></code></pre></td></tr></table></figure></li><li>不要管理同一个裸指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">  </span>&#123; <br>   <span class="hljs-keyword">auto</span> ptr = <span class="hljs-keyword">new</span> Type; <br>   <span class="hljs-function">std::shared_ptr&lt;Type&gt; <span class="hljs-title">t</span><span class="hljs-params">(ptr)</span></span>; <br>   <span class="hljs-function">std::shared_ptr&lt;Type&gt; <span class="hljs-title">t1</span><span class="hljs-params">(ptr)</span></span>; <br>&#125;<br></code></pre></td></tr></table></figure></li><li>避免使用get获取裸指针  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">make_shared</span>&lt;Type&gt;();<br> <span class="hljs-keyword">auto</span> a= ptr.<span class="hljs-built_in">get</span>();<br> <span class="hljs-function">std::shared_ptr&lt;Type&gt; <span class="hljs-title">t</span><span class="hljs-params">(a)</span></span>;<br> <span class="hljs-comment">// 很容易就手滑了</span><br> <span class="hljs-keyword">delete</span> a;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>只管理堆上的对象<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> Type t;<br> <span class="hljs-function">std::shared_ptr&lt;Type&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(&amp;t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>Linux 伙伴系统与slab内存分配器 -&gt; 确实还没有成体系的看内存子系统，该开始着手看了<ul><li>伙伴系统对物理内存的管理是以page为单位的，粒度比较大</li><li>&#x3D;&#x3D;slab&#x3D;&#x3D;是将页拆分成小内存块进行管理，一般和伙伴系统配合使用，它是对伙伴系统的改进和补充<ul><li>slab首先通过伙伴系统的接口向伙伴系统申请一个或多个物理页，然后将其切割成固定大小的块，缓存起来，当分配此大小的内存块的时候，直接返回缓存的内存块，用户释放时，会释放给slab继续缓存起来。slab中的内存块使用链表链起来</li></ul></li><li>有三种类似的内存分配器<ul><li>slab：是内核中最早出现的分配器，随着内核的发展，其实现越来越臃肿</li><li>slub：面向小型嵌入式系统很少内存的简单管理，比如32MB</li><li>slob：是一个轻量级的slab，一般使用在嵌入式系统中</li></ul></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aarch64-linux-内存管理（二）</title>
    <link href="/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://blog.csdn.net/yhb1047818384/article/details/109169979">Linux内存管理(四)：paging_init分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>aarch64-linux-内存管理（一）</title>
    <link href="/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ol><li><a href="https://blog.csdn.net/yhb1047818384/category_10345494.html">Linux内存管理-专栏</a></li><li><a href="http://www.wowotech.net/memory_management/memory_model.html">Linux内存模型</a></li><li><a href="https://www.cnblogs.com/liuhailong0112/p/14465697.html">arm64架构linux内核地址转换__pa(x)与__va(x)分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3Mjg2NDQ0NA==&mid=2247485533&idx=1&sn=bf4dc798fc2cbbe0b55dcd0f5360d933&chksm=cee9878ef99e0e98628bd41f0a733f47d955e470d26840d0f07cc5aa7c9f789e746133c39c82&scene=178&cur_album_id=2707075920913924097#rd">底层开发必知的三个内存结构概念</a></li></ol><h2 id="内存硬件结构"><a href="#内存硬件结构" class="headerlink" title="内存硬件结构"></a>内存硬件结构</h2><p>Linux 把物理内存划分为三个层次来管理: 存储节点(Node)、内存管理区(Zone)和页面(Page)</p><ul><li>Node -&gt; struct pglist_data，包含的重要信息有<ul><li>该 Node 包含的Zone数目</li><li>该node中内存的起始页帧号</li><li>该node地址范围内的实际管理的页面数量</li><li>该node地址范围内的所有页面数量，包括空洞的页面</li><li>ZONE_PADDING宏：让前后的成员分布在不同的cache line中, 以空间换取时间</li></ul></li><li>Zone -&gt; struct Zone<ul><li>将node拆分成zone主要还是出于Linux为了兼容各种架构和平台，对不同区域的内存需要采用不同的管理方式和映射方式；32位系统中，内核和用户地址空间按1:3划分，内核地址空间只有1GB，所以不能把1GB以上的内存直接映射到内核地址空间，因此就把不能直接映射的内存划分到了高端内存区</li><li>ZONE_DMA: 只适用于Intel x86架构，ARM架构没有这个区域，用于ISA设备的DMA操作，物理地址范围为0-16MB</li><li>ZONE_DMA32: 在64位的系统上使用32位地址寻址的适合DMA操作的内存区。例如在AMD64系统上，该区域为低4GB的空间。在32位系统上，本区域通常是空的</li><li>ZONE_NORMAL: 指的是<u>可以直接映射到内核空间的内存</u>。也常称为“普通区域”“直接映射区域”“线性映射区域”。所谓线性映射就是物理地址和映射后的虚拟地址存在一种简单的关系，即虚拟地址&#x3D;物理地址+固定偏移。在32位系统上，内核空间和用户空间按1:3划分，那么这个固定偏移就是：<code>0xC0000000</code> - 物理内存起始地址。因此可以看到：在32位系统中，将物理内存地址的低1G[物理内存起始地址(start): start+1G]映射到内核空间[0xc0000000:0xffffffff]</li><li>ZONE_HIGHMEM: 高端内存区，32位时代的产物。在32位系统上，指的是高于<code>896M</code>的物理内存。32位系统中，内核和用户地址空间按1:3划分，内核地址空间只有1GB，所以不能把1GB以上的内存直接映射到内核地址空间，因此就把不能直接映射的内存划分到了高端内存区。要将高于896MB的物理内存映射在内核空间的话，需要通过单独的映射来完成，并且这类映射不能保证物理地址和虚拟地址之间存在固定的对应关系（例如ZONE_NORMAL的固定偏移）<blockquote><p>64位系统中没有这个区域，即没有高端内存。因为64系统的内核虚拟地址空间非常大，不再需要高端内存区域</p></blockquote></li><li>指向所属的Node节点</li><li>空闲内存链表，用于实现伙伴系统</li></ul></li><li>Page -&gt; struct page<ul><li>Linux内核使用page结构体来描述一个物理页面，每一个page frame有一个一一对应的page数据结构，系统中定义了page_to_pfn和pfn_to_page的宏用来在page frame number和page数据结构之间进行转换，具体如何转换是和<a href="http://www.wowotech.net/memory_management/memory_model.html">memory modle</a>相关</li><li>PFN是page frame number的缩写，所谓page frame，就是针对物理内存而言的，把物理内存分成一个个的page size的区域，并且给每一个page 编号，这个号码就是PFN。假设物理内存从0地址开始，那么PFN等于0的那个页帧就是0地址（物理地址）开始的那个page。假设物理内存从x地址开始，那么第一个页帧号码就是（x&gt;&gt;PAGE_SHIFT）</li></ul></li><li>区分系统物理地址空间 VS 内存占据的物理地址空间<ul><li>整个系统的物理地址空间并不是都用于内存，有些也属于I&#x2F;O空间（当然，有些cpu arch有自己独立的io address space）。因此，内存所占据的物理地址空间应该是一个有限的区间，不可能覆盖整个物理地址空间</li></ul></li></ul><ol><li>UMA 与 NUMA<ul><li>UMA: Uniform Memory Access，统一内存访问，每个CPU共享相同的内存地址空间</li><li>NUMA: Non-Uniform Memory Access，非统一内存访问。系统中会有很多的内存节点和多个CPU簇， 所有节点中的CPU可以访问全部的物理内存，但是CPU访问本地的节点速度远快于访问远端的内存节点的速度</li></ul></li></ol><h2 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h2><p>主要问题有：</p><ol><li><p>内核如何知道系统的物理内存信息？</p><ul><li>DTB 方式，物理内存信息会写到DTB image中，内核在启动初期对DTB进行解析，得到物理内存信息</li><li>ACPI 方式，会在BIOS中写入物理内存信息</li></ul></li><li><p>内核启动初期有一部分汇编编写的位置无关码，它们主要做了什么事情？</p><ul><li>内核绝大部分的代码都不是位置无关码，且其运行时地址基本为虚拟地址，因此在执行到内核主体部分代码时，需要开启MMU，启动虚拟化。开启虚拟化就需要提供页表</li><li>因此，在进入start_kernel()之前的初始阶段汇编代码会进行两个页表映射：<ul><li><code>identity mapping</code>：VA和PA相等的一段映射，主要目的就是为了打开MMU。<u>在打开mmu之前，cpu访问的都是物理地址，打开mmu访问的就是虚拟地址</u>，其实真正打开mmu的操作就是往某个system register的某个bit写1， 如果在开启mmu之前已经下发了某一个数据的操作指令，本来它是想访问物理地址的，结果mmu打开导致访问了虚拟地址，这样会造成混乱。 所以为了解决这一个情况，引入了identity mapping。VA &#x3D; PA， 打开mmu前后，无论访问物理地址还是虚拟地址，都是对应同一段物理内存</li><li><code>kernel image mapping</code>：内核镜像映射，主要目的是为了执行内核代码。打开了MMU后，内核需要运行起来，就需要将kernel运行需要的地址（kernel txt、rodata、data、bss等等）进行映射。映射到的虚拟地址为：内核编译时指定（计算出）的虚拟地址（<em><strong>存疑❓</strong></em>）</li></ul></li></ul></li></ol><p><code>idmap_pg_dir</code>是identity mapping用到的页表，<code>init_pg_dir</code>是kernel_image_mapping用到的页表。这两个页表定义在arch&#x2F;arm64&#x2F;kernel&#x2F;vmlinux.lds.S中，同样定义在该文件中的还有另外三个页表<code>reserved_ttbr0</code>，<code>tramp_pg_dir</code>， <code>swapper_pg_dir</code>。</p><ul><li>reserved_ttbr0：是内核访问用户空间需要用的页表。</li><li>tramp_pg_dir：适用于映射kaslr的内核区域</li><li><u>swapper_pg_dir</u>：在内核启动期间进行常规映射后，用作内核页表。（在4.20的内核之前其实是没有init_pg_dir这个概念的，arm64&#x2F;mm: Separate boot-time page tables from swapper_pg_dir添加了启动时pgd的init_pg_dir）这几个页表的位置、大小在内核链接文件中都有定义。</li><li>使用init_pg_dir，是因为处理FDT的内核代码，后续的内核代码比较大；但是物理内存还没有扫描完成，进行不了最终swapper页表的建立</li></ul><ol start="3"><li><p>初期的kernel image mapping （init_pg_dir）是如何进行（初始化这个页表）的？</p><ul><li>Linux代码如下 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Map the kernel image (starting with PHYS_OFFSET).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x0</span>, init_pg_dir<br><span class="hljs-symbol">mov_q</span>   <span class="hljs-built_in">x5</span>, KIMAGE_VADDR + TEXT_OFFSET   <span class="hljs-comment">// compile time __va(_text)</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x23</span>           <span class="hljs-comment">// add KASLR displacement</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">x4</span>, PTRS_PER_PGD<br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x6</span>, _<span class="hljs-meta">end</span>           <span class="hljs-comment">// runtime __pa(_end)</span><br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x3</span>, _text          <span class="hljs-comment">// runtime __pa(_text)</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x3</span>            <span class="hljs-comment">// _end - _text</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x5</span>            <span class="hljs-comment">// runtime __va(_end)</span><br> <br><span class="hljs-symbol">map_memory</span> <span class="hljs-built_in">x0</span>, <span class="hljs-built_in">x1</span>, <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x7</span>, <span class="hljs-built_in">x3</span>, <span class="hljs-built_in">x4</span>, <span class="hljs-built_in">x10</span>, <span class="hljs-built_in">x11</span>, <span class="hljs-built_in">x12</span>, <span class="hljs-built_in">x13</span>, <span class="hljs-built_in">x14</span><br></code></pre></td></tr></table></figure> ❗️ KIMAGE_VARDDR 即为内核映像的虚拟空间开始地址。这个值也是在编译时指定的【或者可以计算出的】<br> ❗️ TEXT_OFFSET 即为内核代码段相对于内核虚拟地址起始位置的偏移<br> ❗️ <font color=#DC143C>adrp 指令用于获取标号的运行时物理地址【借助运行当前指令时的PC值】</font></li><li><a href="https://stackoverflow.com/questions/51763634/why-physical-address-of-aarch64-kernel-image-is-nonnegative">TEXT_OFFSET</a> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-keyword">in</span> file <span class="hljs-regexp">/arch/</span>arm64<span class="hljs-regexp">/kernel/</span>vmlinux.lds.S<br>. = KIMAGE_VADDR + TEXT_OFFSET; <br>.head.text : &#123;                          <br>_text = .;<br>HEAD_TEXT<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p> 这里，TEXT_OFFSET是一个随机值，因此每次编译时，内核代码的偏移都不是固定的（出于安全的考虑）。最新Linux代码中已经不使用TEXT_OFFSET了。虚拟地址随机化完全依赖于kaslr_offset。init_pg_dir页表的初始化过程也稍有变化：__primary_switch -&gt; __pi_early_map_kernel()[这个函数似乎就是：early_map_kerne()]<br> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs armasm">   . = KIMAGE_VADDR<span class="hljs-comment">;</span><br><br><span class="hljs-symbol">.head.text</span> : &#123;<br>_text = .<span class="hljs-comment">;</span><br>HEAD_TEXT<br>&#125;<br><span class="hljs-symbol">.text</span> : <span class="hljs-meta">ALIGN</span>(SEGMENT_ALIGN) &#123;<span class="hljs-comment">/* Real text segment*/</span><br>_stext = .<span class="hljs-comment">;  </span><br>       ......<br>   &#125;<br>   <br>   <span class="hljs-comment">// in /arch/arm64/kernel/head.S  </span><br><br>   SYM_FUNC_START_LOCAL(__primary_switch)<br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x1</span>, reserved_pg_dir<br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x2</span>, init_idmap_pg_dir<br><span class="hljs-keyword">bl</span>__enable_mmu<br><br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x1</span>, early_init_stack<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">sp</span>, <span class="hljs-built_in">x1</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x29</span>, xzr<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x0</span>, <span class="hljs-built_in">x20</span><span class="hljs-comment">// pass the full boot status</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x1</span>, <span class="hljs-built_in">x21</span><span class="hljs-comment">// pass the FDT</span><br><span class="hljs-keyword">bl</span>__pi_early_map_kernel<span class="hljs-comment">// Map and relocate the kernel</span><br><br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">x8</span>, <span class="hljs-symbol">=__primary_switched</span><br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x0</span>, KERNEL_START<span class="hljs-comment">// __pa(KERNEL_START)</span><br><span class="hljs-keyword">br</span><span class="hljs-built_in">x8</span><br>   SYM_FUNC_END(__primary_switch)<br></code></pre></td></tr></table></figure></p><p> 可以看到，在初始化init_pg_dir时，mmu已经开启了。需要注意：</p><ul><li>❗️<code>bl __pi_early_map_kernel</code>: BL: Branch with Link branches to a PC-relative offset</li><li>❗️<code>br x8</code>: “Adding an L to the B or BR instructions turns them into a branch with link. This means that a<br> return address is written into LR (X30) as part of the branch.” 可以看出B，BR是两个不同的指令。</li><li>❗️ 因此，<code>br x8</code>将__primary_switched标号的虚拟地址赋给PC，从前面的链接文件可以看到，其虚拟地址处于KIMAGE_VADDR开始之后的位置。因此，之后Linux内核将运行于高地址的虚拟内存空间。</li></ul><blockquote><p>[from 《Armv8-A Instruction Set Architecture》]： The unconditional branch instruction B <label> performs a direct, PC-relative, branch to <label>. The offset from the current PC to the destination is encoded within the instruction. The range is limited by the space available within the instruction to record the offset and is +&#x2F;- 128MB. When you use BR <Xn>, BR performs an indirect, or absolute, branch to the address specified in Xn.</p></blockquote> <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// in file /arch/arm64/kernel/pi/map_kernel.c<br><br>asmlinkage void __init early_map_kernel(u64 boot_status, void *fdt)<br>&#123;<br>    u64 v<span class="hljs-built_in">a_base</span>, p<span class="hljs-built_in">a_base</span> = (u64)&amp;_text<span class="hljs-comment">;</span><br>    u64 kaslr_offset = p<span class="hljs-built_in">a_base</span> % MIN_KIMG_ALIGN<span class="hljs-comment">;</span><br><br>    map_fdt((u64)fdt)<span class="hljs-comment">;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * The virtual KASLR displacement modulo 2MiB is decided by the</span><br><span class="hljs-comment">    * physical placement of the image, as otherwise, we might not be able</span><br><span class="hljs-comment">    * to create the early kernel mapping using 2 MiB block descriptors. So</span><br><span class="hljs-comment">    * take the low bits of the KASLR offset from the physical address, and</span><br><span class="hljs-comment">    * fill in the high bits from the seed.</span><br><span class="hljs-comment">    */</span><br>    if (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) &#123;<br>        u64 kaslr_seed = kaslr_early_init(fdt, chosen)<span class="hljs-comment">;</span><br><br>        if (kaslr_seed &amp;&amp; kaslr_requires_kpti())<br>            arm64_use_ng_mappings = <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br><br>        kaslr_offset |= kaslr_seed &amp; ~(MIN_KIMG_ALIGN - <span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>    &#125;<br><br>    if (IS_ENABLED(CONFIG_ARM64_LPA2) &amp;&amp; v<span class="hljs-built_in">a_bits</span> &gt; V<span class="hljs-built_in">A_BITS</span>_MIN)<br>        remap_idmap_for_lpa2()<span class="hljs-comment">;</span><br><br>    v<span class="hljs-built_in">a_base</span> = KIMAGE_VADDR + kaslr_offset<span class="hljs-comment">;</span><br>    map_kernel(kaslr_offset, v<span class="hljs-built_in">a_base</span> - p<span class="hljs-built_in">a_base</span>, root_level)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>kaslr_offset:<br> 这里相当于给内核运行时虚拟地址加了一个随机的偏移，因此后续在map_kernel中需要对内核进行重定位。<u>物理地址随机化比较好处理，虚拟地址随机化之后，内核大部分代码都需要重定位</u>。</li></ul></li><li><p>内核如何去解析这些配置信息？</p><ul><li>现在虽然MMU已经打开，kernel image的页表已经建立，但是内核还没有为DTB这段内存创建映射，现在内核还不知道内存的布局，所以内存管理模块还没能初始化。这个时候就需要用到fixmap。即将DTB的物理地址映射到Fixed map中的区域，然后访问该区域中的虚拟地址即可。</li><li>解析DTB获取系统的物理内存信息，并保存到 <em><strong>memblock</strong></em> 结构中，这是一个全局的变量，用于管理内核早期启动阶段过程中的所有物理内存。</li></ul></li></ol><h2 id="顺序记录"><a href="#顺序记录" class="headerlink" title="顺序记录"></a>顺序记录</h2><h3 id="aarch64-内核内存布局"><a href="#aarch64-内核内存布局" class="headerlink" title="aarch64-内核内存布局"></a>aarch64-内核内存布局</h3><ul><li>0-256T -&gt; 用户空间；256-512T -&gt; 内核空间</li></ul><h4 id="fixed-mappings-4124KB"><a href="#fixed-mappings-4124KB" class="headerlink" title="fixed mappings[4124KB]"></a><a href="https://www.cnblogs.com/alantu2018/p/8447570.html">fixed mappings[4124KB]</a></h4><p>固定映射区，这部分的虚拟地址在编译阶段就已经确定。 在内核的启动过程中，有些模块需要使用虚拟内存并mapping到指定的物理地址上。而且，这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，linux kernel固定分配了一些fixmap的虚拟地址，这些地址有固定的用途。使用该地址的模块在初始化的时候，将这些固定分配的地址mapping到指定的物理地址上去，进而可以通过虚拟化访问到需要访问的特定物理内存。<a href="https://www.cnblogs.com/alantu2018/p/8447570.html">参考</a></p><p><em><strong>个人理解</strong></em>：例如在处理DTB时，内核初始部分代码将启动参数给出的DTB物理地址映射到fixed mappings虚拟空间区域，进而在开启虚拟化之后，实现对DTB的解析</p><p><em><strong>fixed address</strong></em>的具体位置，对于aarch64架构，当前内核中这部分对应的虚拟地址范围为<code>[fffffdfffe5f9000, fffffdfffe9fffff]</code>，总共4124KB大小</p><p><em><strong>fixed address</strong></em>又分为两大类：永久映射 &amp; 临时映射</p><ol><li>永久映射：用于具体的某个内核模块，使用关系是永久的。涉及到的模块主要有：</li></ol><ul><li>DTB解析模块：</li><li>early Console 模块：kernel启动阶段初期可以使用的consol，可以用于输出各种调试信息</li><li>动态打补丁的模块：使用fixed address映射具有RW属性的代码段，进而动态修改这部分代码段的部分内容</li></ul><ol start="2"><li>临时映射：各个内核模块都可以使用，用完之后就释放。主要用于early ioremap模块</li></ol><h3 id="aarch64虚拟地址-物理地址"><a href="#aarch64虚拟地址-物理地址" class="headerlink" title="aarch64虚拟地址-&gt;物理地址"></a>aarch64虚拟地址-&gt;物理地址</h3><p>aarch64有两个页表基地址寄存器：</p><ul><li>ttbr0：用户空间页表基地址。启动初期，idmap_pg_dir填入ttbr0。这里将内核代码映射到低虚拟地址空间。</li><li>ttbr1：内核空间页表基地址。启动初期，init_pg_dir填入ttbr1。这个页表将内核代码映射到高虚拟地址空间。</li></ul><p>64bit的虚拟地址并不是所有bit都被用上的。目前有效的VA_BITS的配置是：36, 39, 42, 47。假设我现在使用64K的页和42bit的虚拟地址空间， 使用三级页表。地址转换过程<a href="https://blog.csdn.net/yhb1047818384/article/details/108210044">举例</a>：</p><ol><li>如果VA[63：42] &#x3D; 1, 那么就会使用ttbr1的地址作为一级页表的基地址；如果VA[63:42] &#x3D; 0, 那么就会使用ttbr0的地址作为一级页表的基地址，那么就会使用ttbr0的地址作为一级页表的基地址；</li><li>VA[41:29]放置Level 1页表中的索引，从而找到对应的描述符地址并获取描述符内容，<u>根据描述符中的内容获取Level 2页表基地址</u></li><li>VA[28:16]放置Level 2页表中的索引，从而找到对应的描述符地址并获取描述符内容，根据描述符中的内容获取<u>物理地址的高36位</u>，以4K地址对齐</li><li>VA[15: 0]放置的是物理地址的偏移，结合获取的物理地址高位，最终得到物理地址</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态库vs静态库</title>
    <link href="/2024/06/26/%E5%8A%A8%E6%80%81%E5%BA%93vs%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/2024/06/26/%E5%8A%A8%E6%80%81%E5%BA%93vs%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加减乘除与mod</title>
    <link href="/2024/06/25/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%B8%8Emod/"/>
    <url>/2024/06/25/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%B8%8Emod/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://leetcode.cn/circle/discuss/mDfnkW/">力扣</a></li></ul><h2 id="记录要点"><a href="#记录要点" class="headerlink" title="记录要点"></a>记录要点</h2><h3 id="两个恒等式"><a href="#两个恒等式" class="headerlink" title="两个恒等式"></a>两个恒等式</h3><ul><li><code>(a + b) mod m = [(a mod m) + (b mod m)] mod m</code></li><li><code>(a b) mod m = [(a mod m) (b mod m)] mod m</code></li></ul><h3 id="幂运算与mod"><a href="#幂运算与mod" class="headerlink" title="幂运算与mod"></a>幂运算与mod</h3><ul><li><font color=DC143C>指数不能随便取余</font>，如果指数在 64 位整数的范围内，可以使用<a href="https://leetcode.cn/problems/powx-n/solutions/2858114/tu-jie-yi-zhang-tu-miao-dong-kuai-su-mi-ykp3i">快速幂</a>计算方法<blockquote><p>注：如果指数超出 64 位整数的范围，需要用「欧拉降幂」处理。</p></blockquote></li></ul><h3 id="负数与mod"><a href="#负数与mod" class="headerlink" title="负数与mod"></a>负数与mod</h3><ul><li>如果<code>x</code>是负数，要采用<code>(x mod m + m) mod m</code>的形式，这样不用判断<code>x</code>是否为负数</li></ul><h3 id="除法与mod"><a href="#除法与mod" class="headerlink" title="除法与mod"></a>除法与mod</h3><ul><li>参考上述链接</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码实现时，上面的加减乘除通常这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MOD = <span class="hljs-number">1</span>_000_000_007<br><br><span class="hljs-comment">// 加</span><br>(a + b) % MOD<br><br><span class="hljs-comment">// 减</span><br>(a - b + MOD) % MOD<br><br><span class="hljs-comment">// 取模到 [0,MOD-1] 中，无论正负</span><br>(a % MOD + MOD) % MOD<br><br><span class="hljs-comment">// 乘</span><br>a * b % MOD<br><br><span class="hljs-comment">// 多个数相乘，要步步取模，防止溢出</span><br>a * b % MOD * c % MOD<br><br><span class="hljs-comment">// 除（MOD 是质数且 b 不是 MOD 的倍数）</span><br>a * <span class="hljs-built_in">qpow</span>(b, MOD - <span class="hljs-number">2</span>, MOD) % MOD<br></code></pre></td></tr></table></figure><p>其中 <code>qpow</code> 为快速幂函数。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子数组相关</title>
    <link href="/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">209. 长度最小的子数组</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></p></li></ul><h2 id="对应解答及注意事项"><a href="#对应解答及注意事项" class="headerlink" title="对应解答及注意事项"></a>对应解答及注意事项</h2><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">长度最小的子数组</a></h3><blockquote><ul><li>这个题是滑动窗口的最佳实践！窗口有左右两个边界索引，有点类似于<em><strong>双指针</strong></em>的方法</li><li>官方题解有一个前缀和的做法：<strong>提前算出[0, i]的和，并保存到一个额外的数组中</strong>，接着将题目转化为：<strong>找到两个前缀和，[0, i)，[0, j)<strong>使得这两个前缀和的差 <strong>&gt;&#x3D;</strong> target，记录此时的子数组长度为：</strong>j-i+1</strong>。后续的操作全都转化为了对<em><strong>前缀和数组</strong></em>的查询操作。</li><li></li></ul></blockquote><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h3><blockquote><ul><li>这题可以用<strong>动态规划</strong>的方法</li><li>评论区有提到<strong>前缀和数组</strong>的方法：也是提前算出前缀和，<strong>子数组的和可以转化为两个前缀和的差</strong>。对于前缀和数组来说，题目转化为了<strong>股票购买&#x2F;卖出最佳时机（可以多次持有股票，但手上最多只能有一支股票）</strong></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题心得</title>
    <link href="/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    <url>/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="读题关键字"><a href="#读题关键字" class="headerlink" title="读题关键字"></a>读题关键字</h2><ul><li>注意总结解题模版！！！</li><li>满足条件的最<em><strong>小</strong></em>整数</li><li>涉及到存储长度类似的：[如果最小的不是32位整数，也返回-1]</li><li>局部变量一定要初始化</li></ul><h2 id="编程脑子-变迟钝"><a href="#编程脑子-变迟钝" class="headerlink" title="编程脑子-变迟钝"></a>编程脑子-变迟钝</h2><ul><li><em><strong>双重循环中，错误使用相同的计数变量，导致程序出现问题</strong></em></li><li><em><strong><code>if (key[i] = &#39;T&#39;)</code></strong></em> -&gt; 注意啊，还真出现了这种错误<ul><li><code>==</code> 不是 <code>=</code> -&gt; 写判断时一定要注意</li><li>写判断，把数值写到&#x3D;&#x3D;左边&#x3D;&#x3D;</li></ul></li><li>不要忘记对循环的尾部进行输出处理: 例如将连续数字替换为平方和<ul><li>例如“avc12vd” -&gt; 在循环中碰到新的字母时才对之前的数字进行处理、输出</li><li>“zvc123” -&gt; 这样就忘记了最后一次的处理</li></ul></li></ul><h2 id="两个区别"><a href="#两个区别" class="headerlink" title="两个区别"></a>两个区别</h2><ul><li><code>sort(nums.begin(), nums.end(), greater&lt;int&gt;());</code><ul><li>这里传入对象</li></ul></li><li><code>map&lt;int, int, greater&lt;int&gt;&gt;mp;</code><ul><li>这里传入类型声明，传入类型即可，如果是自定义的比较，需要传入对象给构造函数: 可能是因为要传入的类型为函数对象，且有成员变量；如果没有的话，应该可以不用显示传入对象  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;item, <span class="hljs-keyword">decltype</span>(dcompare)&gt;<span class="hljs-built_in">st</span>(dcompare)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="常用编程技巧"><a href="#常用编程技巧" class="headerlink" title="常用编程技巧"></a>常用编程技巧</h2><ul><li><p>(long long)(m-1) * (m-2) -&gt; 强制类型转换的优先级高于加减乘除</p></li><li><p>使用<code>std::greater&lt;int&gt;</code>带入sort或者构造声明map</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nume.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;())<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt;&gt;<br><span class="hljs-comment">// 注意它们两个不一样，map声明时需要传入一个类型；而sort需要传入一个函数</span><br></code></pre></td></tr></table></figure></li><li><p>使用lambda表达式自定义sort的比较函数，并使用<code>decltype()</code>传给map声明时的自定义key比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt;points;<br><span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; l, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; r) -&gt; <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> l[<span class="hljs-number">0</span>] &lt; r[<span class="hljs-number">0</span>];<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>使用程序块为变量赋值，要注意函数块需要使用<font color=#DC143C>()</font>包裹起来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> sum = (&#123;<br>        <span class="hljs-type">double</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) tmp += nums[j];<br>        tmp;<br>    &#125;);<br></code></pre></td></tr></table></figure></li><li><p>代码行压缩时，如果有多条语句，必须用{}包围起来，如果只有一条语句不用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;y = <span class="hljs-number">10</span>; z = <span class="hljs-number">100</span>;&#125;<br><span class="hljs-keyword">while</span> (s[i] != <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; i &lt; m) &#123;s[i] -= <span class="hljs-number">1</span>; flag = <span class="hljs-literal">true</span>; i++;&#125;<br><span class="hljs-keyword">while</span>(s[i] == <span class="hljs-string">&#x27;a&#x27;</span>) s[i] -= <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure></li><li><p>在<code>while</code>循环里写额外的for&#x2F;while循环时，一定要记得在内层循环判断越界问题</p></li><li><p>两字符串字典序比较时要注意：循环判断，相等的才会继续，小于或者大于时都会结束判断！！！复习一下这个<a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf">题目</a>，注意提交错误的几个。<strong>可以直接使用string类的&lt;&#x2F;&gt;&#x2F;&gt;&#x3D;运算符，或者compare成员函数进行字典序号的比较</strong></p></li><li><p>体会如何写二叉树的递归：先转化为局部问题，考虑局部root, root-&gt;left, root-&gt;right的递归问题；先不用纠结于前&#x2F;中&#x2F;后的递归顺序，结合这个题目[114.二叉树展开为链表]。</p></li><li><p>判断一个数是否为质数</p><ul><li>daiding</li></ul></li><li><p>计算整数各个位上数字之和：可以先从个位数加起：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfTheDigitsOfHarshadNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = x; v; v /= <span class="hljs-number">10</span>) &#123;<br>        s += v % <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>double, long, int, long long等类型表示的数据范围</p><ul><li>double是双精度浮点型，可以表示小数，在64位系统上占8Bytes。采用的数据表示方法和另外几种数据类型不同，能表示的数据范围是最大的。此外还有float[单精度浮点型], long double[精确度更高]</li><li>其余都是整数类型</li><li>浮点型，牺牲了表示精度，但是增大了数据表示范围</li><li>参考题目：<a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a></li></ul></li></ul><h2 id="个别题目复习"><a href="#个别题目复习" class="headerlink" title="个别题目复习"></a>个别题目复习</h2><ul><li><p>数的前&#x2F;中&#x2F;后遍历的迭代方法要熟悉</p></li><li><p>找数字规律的题目，先找到“主干规律”，再找次要规律，结合题目[6. Z字型变换]</p></li><li><p><em><strong>二叉树层序遍历</strong></em>不一定非得用queue，也可以用vector实现一些重复遍历的操作，结合[2641.]</p></li></ul><h2 id="常用数据结构及其方法"><a href="#常用数据结构及其方法" class="headerlink" title="常用数据结构及其方法"></a>常用数据结构及其方法</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul><li>erase()</li><li>rbegin() -&gt; 最右侧的那个节点</li><li>front()&#x2F;back() -&gt; 用于查看元素</li><li>pop_back()</li><li>push_back() -&gt; 可以用来模拟栈</li><li>rend() -&gt; 第一个节点前面，不在vector中</li><li>insert(pos, start, end)，从pos处插入[start, end)，注意这样的话target[pos] &#x3D; src[start]</li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li><p>&lt;string&gt;</p></li><li><p><code>insert(pos, char *, size)</code></p></li><li><p>string (size_t n, char c)</p></li><li><p>size_t find(string&amp; str, size_t pos &#x3D; 0)   </p><ul><li><p>五种原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// string (1) </span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-comment">// c-string (2)    </span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// buffer (3)    </span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">size_t</span> pos, size_type n)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// character (4)    </span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span> <span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>pos参数：指示原字符串的开始查询位置，而且包括pos指示的位置</p></li><li><p>返回值：</p><ul><li><code>size_t</code>类型</li><li>the pos of the first character of the first match</li><li><code>string::npos</code>if no match find</li></ul></li><li><p>delimiter划分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">// for string delimiter</span><br>  <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">split</span><span class="hljs-params">(std::string s, std::string delimiter)</span></span><br><span class="hljs-function">  </span>&#123;<br>   <span class="hljs-type">size_t</span> pos_start = <span class="hljs-number">0</span>, pos_end, delim_len = delimiter.<span class="hljs-built_in">length</span>();<br>std::string token;<br>   std::vector&lt;std::string&gt; res;<br>  <br><span class="hljs-keyword">while</span> ((pos_end = s.<span class="hljs-built_in">find</span>(delimiter, pos_start))<br>  != std::string::npos)<br>&#123;<br>token = s.<span class="hljs-built_in">substr</span> (pos_start, pos_end - pos_start);<br>pos_start = pos_end + delim_len;<br>res.<span class="hljs-built_in">push_back</span> (token);<br>&#125;<br>  <br>res.<span class="hljs-built_in">push_back</span> (s.<span class="hljs-built_in">substr</span> (pos_start));<br><span class="hljs-keyword">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>find_first_of() -&gt; 类似于find()，但是匹配str中的任一个字符</p></li><li><p>substr(start, len) ❗️ 注意这个方法的第二个参数为<u>长度</u></p></li><li><p>operator &gt; &#x2F; &lt;   -&gt;  string 类重载了这两个运算符，可以直接用于字典序的比较</p></li><li><p>compare(const string&amp; str)，返回值如下：</p><ul><li>0, equal</li><li>-1, lf &lt; rf</li><li>1, lf &gt; rf</li></ul></li><li><p>erase(start_idx, len)   -&gt; 利用索引和长度删除指定范围的字符</p></li><li><p>erase(iterator start, iterator end)  -&gt; 利用迭代器删除指定范围内的字符，[start, end)</p></li><li><p>delimeter划分</p><ul><li>借助<code>find</code>进行划分；但是也只能跳过整体的<code>string</code></li><li>借助getline(string) 和 istringstrem(sstream)对字符串进行划分<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string str=<span class="hljs-string">&quot;She is a girl.&quot;</span>; <span class="hljs-comment">// istringstream 默认以空格进行划分</span><br>   <span class="hljs-function">istringstream <span class="hljs-title">is</span><span class="hljs-params">(str)</span></span>;<br>   string buf;<br>   <span class="hljs-keyword">while</span>(is&gt;&gt;buf)<br>   &#123;<br>     cout&lt;&lt;buf&lt;&lt;endl;<br>   &#125;<br>   <br>   <span class="hljs-comment">// 借助getline -&gt; 缺点是只能delimeter只能为单个字符</span><br>   <span class="hljs-comment">// istream&amp; getline ( istream &amp;is , string &amp;str , char delim );</span><br>   <span class="hljs-type">char</span> del = <span class="hljs-string">&#x27; &#x27;</span>;<br>   <span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(is,buf,del))<br>   &#123;<br>     <span class="hljs-keyword">if</span>(buf.<span class="hljs-built_in">size</span>()) cout&lt;&lt;buf;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li>使用strtok()进行划分 -&gt; 可以忽略很多字符<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// in &lt;string.h&gt; or &lt;cstring&gt;</span><br><span class="hljs-comment">// char* strtok( char* str, const char* delim );</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> input[] = <span class="hljs-string">&quot;one + two * (three - four)!&quot;</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* delimiters = <span class="hljs-string">&quot;! +- (*)&quot;</span>;<br>  <span class="hljs-type">char</span>* token = std::<span class="hljs-built_in">strtok</span>(input, delimiters);<br>  <span class="hljs-keyword">while</span> (token)<br>  &#123;<br>      <span class="hljs-comment">// token may do not have &#x27;\0&#x27; at the end</span><br>      std::cout &lt;&lt; <span class="hljs-built_in">string</span>(token) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>      token = std::<span class="hljs-built_in">strtok</span>(<span class="hljs-literal">nullptr</span>, delimiters);<br>  &#125;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\nContents of the input string now:\n\&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-keyword">sizeof</span> input; ++n)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> c = input[n]; c != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>          std::cout &lt;&lt; c;<br>      <span class="hljs-keyword">else</span><br>          std::cout &lt;&lt; <span class="hljs-string">&quot;\\0&quot;</span>;<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>c_str()</p><ul><li><p>返回值为const char *</p></li><li><p>可以使用<code>const_cast&lt;char *&gt;</code>剥除const符号</p></li><li><p>但是要注意<code>cout &lt;&lt; char *</code>，<code>char*</code> 后面可能没有’\0’，因此程序会有bug</p></li><li><p>可以尝试使用<code>string</code>来装载这个<code>char*</code>，string会在尾部添加’\0’</p></li></ul></li></ul><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><ul><li>&lt;stcak&gt;</li><li>push()</li><li>pop() -&gt; 注意返回值为 void，因此取元素只能用top()方法 ❗️</li><li>top()</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><ul><li><code>&lt;queue&gt;</code></li><li>push()</li><li>pop() ❗️ -&gt; 注意返回值为 void，因此取元素只能用front()方法</li><li>top() ❌ -&gt; 没有这个方法，要使用front()</li><li>front() -&gt; 查看队列头部的元素[先插入的]</li><li>back() -&gt; 查看队列尾部的元素[后插入的]</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul><li><p>set有一个cmp函数，当cmp(l, r)为false且当cmp(r, l)也为false时，说明<strong>l与r为相同的元素</strong></p></li><li><p>自定义cmp函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; l, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; r) -&gt; <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> l[<span class="hljs-number">0</span>]*l[<span class="hljs-number">0</span>] + l[<span class="hljs-number">1</span>]*l[<span class="hljs-number">1</span>] &lt;= r[<span class="hljs-number">0</span>]*r[<span class="hljs-number">0</span>] + r[<span class="hljs-number">1</span>]*r[<span class="hljs-number">1</span>];<br>&#125;;<br>set&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">st</span>(cmp);<br></code></pre></td></tr></table></figure></li><li><p>erase() ❗️ multiset在使用这个方法删除某个key时，会把所有相同的key删除；如果想要删除一个，需要先使用find返回迭代器，并将迭代器作为该方法的参数</p></li><li><p>注意：无法使用迭代器获取有序set中某个元素在set中的序号可以先将其转为vectorset迭代器+n的方法</p></li><li><p>迭代器加法可以使用<code>advance</code></p><ul><li><code>advance(it, 5);</code></li><li>要注意该函数返回值为void</li><li>且第二个参数可以为负值</li></ul></li><li><p>可以使用<code>distance(begin, end)</code>计算两个迭代器之间的距离，注意end一定要在begin的后面</p><ul><li>是的，必须</li></ul></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li><p>&lt;map&gt;</p></li><li><p>lower_bound&#x2F;upper_bound</p></li><li><p>erase() -&gt; 参数可以为 <strong>iterator</strong>；<strong>key</strong>；也可以为范围参数’[first it, last it)’</p></li><li><p>大 -&gt; 小排列 <code>map&lt;int, multiset&lt;int&gt;, std::greater&lt;int&gt;&gt;</code></p></li><li><p>定义map型对象时，如何自定义key比较函数：注意只能定义key的比较函数：也可以定义lambda表达式，并使用<code>decltype</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp_key</span><br>&#123;<br>    <span class="hljs-comment">// 注意，函数的参数需要于map的key的参数类型相同</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">key_t</span> &amp;k1, <span class="hljs-type">const</span> <span class="hljs-type">key_t</span> &amp;k2)</span><span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(k1.dwBussID != k2.dwBussID)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwBussID &lt; k2.dwBussID;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(k1.dwVersion != k2.dwVersion)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwVersion &lt; k2.dwVersion;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k1.dwHashUrl != k2.dwHashUrl)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwHashUrl &lt; k2.dwHashUrl;<br>        &#125;<br>　　　　　　　　  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><ul><li><code>&lt;queue&gt;</code></li><li>需要指定底层使用什么容器类型存放元素：默认为vector，也支持deque。也可以自定义容器</li><li>top() -&gt; 查看尾部元素</li><li>push()&#x2F;pop()</li></ul><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><ul><li><code>&lt;deque&gt;</code></li><li>元素存储不是连续的</li><li>支持<code>[]</code>下标索引操作</li><li>front&#x2F;back -&gt; 查看元素</li><li>puah_back&#x2F;push_front</li><li>pop_back&#x2F;pop_front</li></ul><h2 id="常用库函数运算"><a href="#常用库函数运算" class="headerlink" title="常用库函数运算"></a>常用库函数运算</h2><h3 id="lower-bound-iterator-start-iterator-end-value"><a href="#lower-bound-iterator-start-iterator-end-value" class="headerlink" title="lower_bound(iterator_start, iterator_end, value) -&gt;"></a>lower_bound(iterator_start, iterator_end, value) -&gt;</h3><ul><li>返回第一个迭代器it，其值<strong>不满足</strong> <code>(*it) &lt; value</code></li><li>即找到第一个迭代器，其值<strong>满足</strong> <code>value &lt;= (*it)</code></li><li>参数可以为&amp;arr[i]，返回值也为该类型，<a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/submissions/545900287/">参考</a></li></ul><h3 id="upper-bound-start-end-value"><a href="#upper-bound-start-end-value" class="headerlink" title="upper_bound(start, end, value) -&gt;"></a>upper_bound(start, end, value) -&gt;</h3><ul><li>返回第一个迭代器，其值<strong>满足</strong> <code>(*it) &gt; value</code></li></ul><h3 id="gcd-lcm"><a href="#gcd-lcm" class="headerlink" title="gcd&#x2F;lcm"></a>gcd&#x2F;lcm</h3><ul><li><code>&lt;numeric&gt;</code></li><li>gcd: 最大公因数</li><li>lcm: 最小公倍数</li></ul><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><ul><li><code>&lt;numeric&gt;</code></li><li><code>iota(foreard_iterator start, forward_iterator end, init_val)</code></li><li>序列化<code>[start, end)</code>，第一个值为init_val</li></ul><h3 id="atan2-double"><a href="#atan2-double" class="headerlink" title="atan2() -&gt; double"></a>atan2() -&gt; double</h3><ul><li>求坐标(x, y)到x轴的极角，范围为[-pi, pi]。这里要注意坐标上的点在-x轴上时，其极角可能为-pi，也可能为pi，但只能为一个值<ul><li><a href="https://leetcode.cn/problems/maximum-number-of-visible-points/description/">1610. 可见点的最大数目</a></li></ul></li></ul><h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h3><ul><li><code>&lt;algorithm&gt;</code></li><li>返回数组的全排列</li><li>使用前需要对数组进行小-&gt;大的排序</li></ul><h3 id="浮点数保留指定长度小数"><a href="#浮点数保留指定长度小数" class="headerlink" title="浮点数保留指定长度小数"></a>浮点数保留指定长度小数</h3><ul><li>设置标准输出保留指定位数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#incude <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-comment">// ios::fixed -&gt; 防止0.2000仍然输出0.2</span><br>cout &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 只需设置一次，后续都是这样打印</span><br><span class="hljs-comment">// 或者这样设置</span><br>cout.<span class="hljs-built_in">setf</span>(ios::fixed);<br>cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br><br>cout &lt;&lt; <span class="hljs-number">0.2000</span> &lt;&lt; endl; <span class="hljs-comment">/* 输出为0.20 */</span><br></code></pre></td></tr></table></figure></li><li>运算过程中保留两位小数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#incude <span class="hljs-string">&lt;cmath&gt;</span> <span class="hljs-comment">// for floor</span></span><br><span class="hljs-comment">/*采用数学计算的方式*/</span><br><span class="hljs-type">float</span> a = <span class="hljs-number">0.0239102</span>;<br>a = <span class="hljs-built_in">floor</span>(a*<span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>)/<span class="hljs-number">1000</span>  <span class="hljs-comment">/* + 0.5 是为了四舍五入*/</span><br><br></code></pre></td></tr></table></figure></li><li><code>floor</code>&#x2F;<code>ceil</code>&#x2F;<code>round</code> -&gt; 头文件：<code>cmath</code><ul><li>这三个函数都是给浮点型数据使用的</li></ul></li><li><code>lround</code>&#x2F;<code>llround</code> -&gt; 头文件：<code>cmath</code><ul><li>用于将浮点数四舍五入为<code>long</code>&#x2F;<code>long long</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/monotonous-stack/">单调栈</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>弹出时只能从栈顶[st.top()]弹出</li><li>从栈顶到栈底，元素大小呈某种单调趋势</li><li>当欲压入栈的元素不满足这个单调性时，就要把不满足单调性的所有[栈顶]元素弹出 -&gt; 这个性质用到的比较多</li><li>配合数组使用时，栈内可以存储对应元素的下标，而不是元素值</li></ul><h2 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h2><ul><li>使用时要注意考虑单调顺序：1️⃣递增，2️⃣递减</li><li>要搞清楚单调栈中记录元素的意义：例如题—[503]，单调栈中记录的是还没有找到下一个更大值的<em><strong>下标</strong></em>, 只要遍历到比栈顶元素值更大的数，就意味着栈顶元素找到了答案，记录答案，然后从栈顶弹出</li><li>一定要注意单调栈里存储的是<em><strong>索引</strong></em>还是<em><strong>元素值</strong></em></li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素2</a></li><li><a href="https://leetcode.cn/problems/next-greater-element-iii/description/">556.下一个更大元素3</a>: 变形题，比较有意思！！！</li></ul><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><ul><li>[556] 一定要注意题目的条件 -&gt; <ul><li>满足条件的最小整数</li><li>如果最小的不是32位整数，也返回-1</li></ul></li></ul><h2 id="扩展-循环数组"><a href="#扩展-循环数组" class="headerlink" title="扩展-循环数组"></a>扩展-循环数组</h2><ul><li>处理方式1：将[0:n-1]个个数顺序拷贝到第n个数后面，构成一个普通数组</li><li>处理方式2：遍历[0:2n-1)次，取元素时对下标取模</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li><li><a href="https://writings.sh/post/union-find">并查集简记</a></li></ul><h2 id="Leetcode-题目"><a href="#Leetcode-题目" class="headerlink" title="Leetcode 题目"></a>Leetcode 题目</h2><ul><li><a href="https://leetcode.cn/problems/smallest-string-with-swaps/description/">1202.交换字符串中的元素</a></li></ul><h2 id="对应题解"><a href="#对应题解" class="headerlink" title="对应题解"></a>对应题解</h2><ul><li>1202 [from Andy at Leetcode]<blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> father[<span class="hljs-number">100010</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//并查集find</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x==father[x]?x:(father[x] = <span class="hljs-built_in">find</span>(father[x]));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//并查集merge</span></span><br><span class="hljs-function">    </span>&#123;<br>        father[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">smallestStringWithSwaps</span><span class="hljs-params">(string s, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        string areastr[<span class="hljs-number">100010</span>]; <span class="hljs-comment">//areastr[x]含义为并查集里所有father==x的结点集合</span><br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">100010</span>] =&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//cnt[x]含义为areastr[x]内的第一个未分配元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) father[i] = i;<span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: pairs) <span class="hljs-built_in">merge</span>(i[<span class="hljs-number">1</span>], i[<span class="hljs-number">0</span>]);<span class="hljs-comment">//merge连通结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            areastr[<span class="hljs-built_in">find</span>(i)]+=s[i];<span class="hljs-comment">//将s[i]添加到连通结点集合内</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            <span class="hljs-built_in">sort</span>(areastr[i].<span class="hljs-built_in">begin</span>(),areastr[i].<span class="hljs-built_in">end</span>());<span class="hljs-comment">//对每个连通图内容排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            s[i] = areastr[father[i]][cnt[<span class="hljs-built_in">find</span>(i)]++];<span class="hljs-comment">//根据连通图内排序后结果还原字符串</span><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDS回环-吞吐量测试记录</title>
    <link href="/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LW-DDS"><a href="#LW-DDS" class="headerlink" title="LW DDS"></a>LW DDS</h2><ul><li>240607-可以用于毕业小实验数据采集</li><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="Cyclone-DDS"><a href="#Cyclone-DDS" class="headerlink" title="Cyclone DDS"></a>Cyclone DDS</h2><ul><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="RTI-DDS"><a href="#RTI-DDS" class="headerlink" title="RTI DDS"></a>RTI DDS</h2><p>- </p><h2 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h2><ul><li>Cyclone 和 Fast[2.12.0]都定义了0x8007这个PID，但是含义不一样，因此Fast在接收到Cyclone的data(p)报文，进行处理时出错，不会创建参与者代理，因此匹配不了</li><li>FastDDS调试时常用的断点：<ul><li>on_new_cache_change_added() [“Ignore announcement from own RTPSParticipant”] at file: PDPListener.cpp -&gt; 用于处理data(p)报文</li><li>EDPSimplePUBListener::on_new_cache_change_added() at file: EDPSimpleListeners.cpp -&gt; 用于处理data(w)报文</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回文串性质</title>
    <link href="/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/"/>
    <url>/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="参考题目"><a href="#参考题目" class="headerlink" title="参考题目"></a>参考题目</h2><ul><li><a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/">2663. 字典序最小的美丽字符串</a></li><li><a href="https://leetcode.cn/problems/find-palindrome-with-fixed-length/description/">2217. 找到指定长度的回文数</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>aa，aba，很明显，最小模式的回文串只有这两种模式</li><li>对于长度为 m (m &gt; 3) 的回文串，其必包含长度为 m-2 的回文串</li><li>因此，“不包含任何长度为2或更长的回文串” &lt;&#x3D;&#x3D;&gt; “不包含长度为2或3的回文串”</li><li>当用[0-9]的数字来组成回文串，则其长度为n的回文串按大小排序时，有明显的规律<ul><li>要注意：回文串是有<em><strong>对称性</strong></em>的，因此长度为n的回文串（由数字组成时），可以由其前(n+1)&#x2F;2个整数部分唯一确定，因为后续的数字与前面的数字成镜像对称</li></ul></li><li>回文串的<strong>中间部分</strong>一定是由连续且相同的字符串组成：<code>aba</code>, <code>abccba</code>, <code>tartattatrat</code></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>如果题目中“不包含任何长度为2或更长” 改为-&gt; “不包含任何长度为3&#x2F;4&#x2F;5&#x2F;m或更长”，该怎么做？</li></ul><h2 id="基础：回文串的判别"><a href="#基础：回文串的判别" class="headerlink" title="基础：回文串的判别"></a>基础：回文串的判别</h2><ul><li>可以根据对称性进行回文串的判断<ol><li>区分长度的奇偶性，找到双指针i，j<br>  2.<code> i--，j++</code>分别判断<code>s[i] == s[j]</code>是否成立</li><li>要注意：如果字串长度为奇数，则只能为<code>aba</code>类型；但是当字串长度为偶数是，可以为<code>aa</code>，也可以为<code>abaaba</code></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/22/hello-world/"/>
    <url>/2024/06/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
