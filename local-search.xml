<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux-aarch64-系统调用-2</title>
    <link href="/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-2/"/>
    <url>/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-2/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux系统调用的处理"><a href="#Linux系统调用的处理" class="headerlink" title="Linux系统调用的处理"></a>Linux系统调用的处理</h2><ul><li>注意本系列以Linux6.9为例</li><li>这里为aarch64</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>dup2() of POSIX interface: defined in glibc</p><ul><li>INLINE_SYSCALL_CALL() -&gt; __INLINE_SYSCALL2() -&gt; INLINE_SYSCALL(): 针对不同的UNIX实现，定义了不同的宏实现<ul><li>for Linux: INLINE_SYSCALL() -&gt; INTERNAL_SYSCALL(): 针对不同的架构，定义了不同的宏实现<ul><li>for aarch64: INTERNAL_SYSCALL_RAW()<ul><li>将系统调用号放在x8寄存器，将调用参数放到x0-x6寄存器中</li><li><code>svc0</code> 触发SVC异常，陷入内核</li></ul></li></ul></li></ul></li></ul></li><li><p>陷入内核后：（SVC异常属于同步异常）</p><ul><li>根据vectors，进入el0，64，sync处理流程<ul><li>执行部分汇编码 -&gt; b(无条件，不返回)跳转到 el0t_64_sync<ul><li>el0t_64_sync (由entry_handler宏定义，汇编标号) -&gt; el0t_64_sync_handler (c函数)<ul><li>el0t_64_sync_handler -&gt; el0_svc -&gt; do_el0_svc<ul><li>do_el0_svc(从x8获取系统调用号) -&gt; el0_svc_common<ul><li>el0_svc_common: 从调用表中拿到Linux定义的系统调用函数__arm64_sym_sys_dup2()<ul><li>进入执行 SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd): in file.c</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="分步梳理"><a href="#分步梳理" class="headerlink" title="分步梳理"></a>分步梳理</h3><ul><li><p>参考《vectors.md》可知，系统调用触发软件中断，为同步异常，因此会进入el0t_64_sync的处理流程</p></li><li><p>必要的汇编 -&gt; el0t_64_sync -&gt; el0t_64_sync_handler</p></li><li><p>el0t_64_sync_handler</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">asmlinkage <span class="hljs-type">void</span> noinstr <span class="hljs-title function_">el0t_64_sync_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esr = read_sysreg(esr_el1);<br><br>    <span class="hljs-keyword">switch</span> (ESR_ELx_EC(esr)) &#123;<br>    <span class="hljs-keyword">case</span> ESR_ELx_EC_SVC64:<br>        el0_svc(regs);          <span class="hljs-comment">// 这里处理 svc 同步异常</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ESR_ELx_EC_DABT_LOW:<br>        el0_da(regs, esr);<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>el0_svc -&gt; do_el0_svc</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> noinstr <span class="hljs-title function_">el0_svc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    enter_from_user_mode(regs);<br>    cortex_a76_erratum_1463225_svc_handler();<br>    fp_user_discard();<br>    local_daif_restore(DAIF_PROCCTX);<br>    do_el0_svc(regs);<br>    exit_to_user_mode(regs);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>do_el0_svc -&gt; el0_svc_common -&gt; invoke_syscall</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_el0_svc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-comment">// 这里从x8中获取调用号; sys_call_table为系统调用表</span><br>    el0_svc_common(regs, regs-&gt;regs[<span class="hljs-number">8</span>], __NR_syscalls, sys_call_table);<br>&#125;<br><br><span class="hljs-comment">// sys_call_table的“创建”, in file: arch\arm64\kernel\sys.c</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Wrappers to pass the pt_regs argument.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __arm64_sys_personality__arm64_sys_arm64_personality</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL(nr, sym)asmlinkage long __arm64_##sym(const struct pt_regs *);</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL(nr, sym)[nr] = __arm64_##sym,</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">syscall_fn_t</span> sys_call_table[__NR_syscalls] = &#123;<br>    [<span class="hljs-number">0</span> ... __NR_syscalls - <span class="hljs-number">1</span>] = __arm64_sys_ni_syscall,<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/unistd.h&gt;</span></span><br>    [<span class="hljs-number">23</span>] = __arm64_sym_sys_dup,     <span class="hljs-comment">// 在《syscall-1.md》的分析中，已经见到了该函数的定义</span><br>    [<span class="hljs-number">24</span>] = __arm64_sym_sys_dup3<br>&#125;;<br><br><span class="hljs-comment">// 上面两个#include &lt;asm/unistd.h&gt;，最终会包含linux\include\uapi\asm-generic\unistd.h 这个重要文件</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_dup 23</span><br>__SYSCALL(__NR_dup, sys_dup)<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_dup3 24</span><br>__SYSCALL(__NR_dup3, sys_dup3)<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR3264_fcntl 25</span><br>__SC_COMP_3264(__NR3264_fcntl, sys_fcntl64, sys_fcntl, compat_sys_fcntl64)<br>...<br></code></pre></td></tr></table></figure></li><li><p>invoke_syscall：从调用表中所引到某个表项，取得syscall_fn_t，调用即可</p><ul><li>对于POSIX标准规范的dup()<ul><li>调用到__arm64_sym_sys_dup()<ul><li>__se_sys_dup()<ul><li>__do_sys_dup()<ul><li>file.c 中 dup 的定义：<code>SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd)</code></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-系统调用-1</title>
    <link href="/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1/"/>
    <url>/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux系统调用定义相关"><a href="#Linux系统调用定义相关" class="headerlink" title="Linux系统调用定义相关"></a>Linux系统调用定义相关</h2><ul><li><p>相关代码： </p><ul><li>for general arch: sys_*name -&gt; aliased to _<em>se_sys</em>*name -&gt; call _<em>do_sys</em>*name to do actual work</li><li>for arm64 arch: _<em>arm64_sys</em>* -&gt; call  _<em>se_sys</em>* -&gt; call _<em>do_sys</em>*name to do actual work</li></ul></li><li><p>因此，实际的系统调用函数为__do_sys_*()</p></li><li><p>asmlinkage：声明函数传参不使用寄存器，而使用栈进行。后续为Linux源码中的系统调用</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">// in file : syscalls.h</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span><br><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span><br><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_METADATA(sname, nb, ...)</span><br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * __MAP - apply a macro to syscall arguments</span><br><span class="hljs-comment">   * __MAP(n, m, t1, a1, t2, a2, ..., tn, an) will expand to</span><br><span class="hljs-comment">   *    m(t1, a1), m(t2, a2), ..., m(tn, an)</span><br><span class="hljs-comment">   * The first argument must be equal to the amount of type/name</span><br><span class="hljs-comment">   * pairs given.  Note that this list of pairs (i.e. the arguments</span><br><span class="hljs-comment">   * of __MAP starting at the third one) is in the same format as</span><br><span class="hljs-comment">   * for SYSCALL_DEFINE&lt;n&gt;/COMPAT_SYSCALL_DEFINE&lt;n&gt;</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP0(m,...)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP1(m,t,a,...) m(t,a)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP(n,...) __MAP##n(__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __SC_DECL(t, a)t a</span><br><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)\</span><br><span class="hljs-meta">       SYSCALL_METADATA(sname, x, __VA_ARGS__)\</span><br><span class="hljs-meta">       __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br><br>   <span class="hljs-comment">// in file：arch\arm64\include\asm\syscall_wrapper.h</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)\   <span class="hljs-comment">// arm64定义了自己的__SYSCALL_DEFINEx宏</span></span><br>asmlinkage <span class="hljs-type">long</span> __arm64_sys#<span class="hljs-meta">#name(const struct pt_regs *regs);\</span><br><span class="hljs-meta">ALLOW_ERROR_INJECTION(__arm64_sys##name, ERRNO);\</span><br><span class="hljs-meta">static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\</span><br><span class="hljs-meta">static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span><br><span class="hljs-meta">asmlinkage long __arm64_sys##name(const struct pt_regs *regs)\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">return __se_sys##name(SC_ARM64_REGS_TO_ARGS(x,__VA_ARGS__));\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="hljs-meta">__MAP(x,__SC_TEST,__VA_ARGS__);\</span><br><span class="hljs-meta">__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\</span><br><span class="hljs-meta">return ret;\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       <span class="hljs-comment">// 这一行看着很奇怪，需要结合一个具体的系统调用定义才能看明白</span></span><br><br>   <span class="hljs-comment">// 这里提取x0-x6</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SC_ARM64_REGS_TO_ARGS(x, ...)\</span><br><span class="hljs-meta">__MAP(x,__SC_ARGS\</span><br><span class="hljs-meta">      ,,regs-&gt;regs[0],,regs-&gt;regs[1],,regs-&gt;regs[2]\</span><br><span class="hljs-meta">      ,,regs-&gt;regs[3],,regs-&gt;regs[4],,regs-&gt;regs[5])</span><br><br>   <span class="hljs-comment">// in file: file.c</span><br>   SYSCALL_DEFINE2(dup2, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, oldfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, newfd)<br>   &#123;<br>       <span class="hljs-keyword">if</span> (unlikely(newfd == oldfd)) &#123; <span class="hljs-comment">/* corner case */</span><br>           <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span> =</span> current-&gt;files;<br>           <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>           <span class="hljs-type">int</span> retval = oldfd;<br><br>           rcu_read_lock();<br>           f = __fget_files_rcu(files, oldfd, <span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">if</span> (!f)<br>               retval = -EBADF;<br>           rcu_read_unlock();<br>           <span class="hljs-keyword">if</span> (f)<br>               fput(f);<br>           <span class="hljs-keyword">return</span> retval;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ksys_dup3(oldfd, newfd, <span class="hljs-number">0</span>);<br>   &#125;<br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * The asmlinkage stub is aliased to a function named __se_sys_*() which</span><br><span class="hljs-comment">   * sign-extends 32-bit ints to longs whenever needed. The actual work is</span><br><span class="hljs-comment">   * done within __do_sys_*().</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __SYSCALL_DEFINEx       <span class="hljs-comment">// 不同架构可能定义了自己的__SYSCALL_DEFINEx宏</span></span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)\</span><br><span class="hljs-meta">       __diag_push();\</span><br><span class="hljs-meta">       __diag_ignore(GCC, 8, <span class="hljs-string">&quot;-Wattribute-alias&quot;</span>,\</span><br><span class="hljs-meta">               <span class="hljs-string">&quot;Type aliasing is used to sanitize syscall arguments&quot;</span>);\</span><br><span class="hljs-meta">       asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\</span><br><span class="hljs-meta">           __attribute__((alias(__stringify(__se_sys##name))));\</span><br><span class="hljs-meta">       ALLOW_ERROR_INJECTION(sys##name, ERRNO);\</span><br><span class="hljs-meta">       static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span><br><span class="hljs-meta">       asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\</span><br><span class="hljs-meta">       asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\</span><br><span class="hljs-meta">       &#123;\</span><br><span class="hljs-meta">           long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="hljs-meta">           __MAP(x,__SC_TEST,__VA_ARGS__);\</span><br><span class="hljs-meta">           __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\</span><br><span class="hljs-meta">           return ret;\</span><br><span class="hljs-meta">       &#125;\</span><br><span class="hljs-meta">       __diag_pop();\</span><br><span class="hljs-meta">       static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __SYSCALL_DEFINEx */</span></span><br></code></pre></td></tr></table></figure></li><li><p>实际使用中会直接调用dup2()，由其触发svc同步异常，最终调用Linux定义的系统调用“服务函数”。其函数原型在相应的头文件[unistd.h]中有声明，但其定义在哪里？</p><ul><li>显然，在Linux中，它直接使用GNU的C库，因此dup2()的定义在GNU的C库源文件中。下载glibc的源码后，可以看到dup2()的定义</li><li>可以看到，对于不同的标准&#x2F;UNIX实现，glibc中也定义了不同的dup2()实现  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: sysdeps/posix/dup2.c</span><br>    <span class="hljs-type">int</span><br>__dup2 (<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> fd2)<br>&#123;<br><span class="hljs-type">int</span> save;<br><br><span class="hljs-keyword">if</span> (fd2 &lt; <span class="hljs-number">0</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPEN_MAX</span><br>    || fd2 &gt;= OPEN_MAX<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>)<br>    &#123;<br>    __set_errno (EBADF);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-comment">/* Check if FD is kosher.  */</span><br><span class="hljs-keyword">if</span> (fcntl (fd, F_GETFL) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span> (fd == fd2)<br>    <span class="hljs-keyword">return</span> fd2;<br><br><span class="hljs-comment">/* This is not atomic.  */</span><br><br>save = errno;<br>(<span class="hljs-type">void</span>) close (fd2);<br>__set_errno (save);<br><br><span class="hljs-keyword">return</span> fcntl (fd, F_DUPFD, fd2);<br>&#125;<br>libc_hidden_def (__dup2)<br>weak_alias (__dup2, dup2)<br><br><span class="hljs-comment">// in file: sysdeps/unix/sysv/linux/dup2.c</span><br><span class="hljs-type">int</span><br>__dup2 (<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> fd2)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NR_dup2</span><br><span class="hljs-keyword">return</span> INLINE_SYSCALL_CALL (dup2, fd, fd2);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">/* For the degenerate case, check if the fd is valid (by trying to</span><br><span class="hljs-comment">    get the file status flags) and return it, or else return EBADF.  */</span><br><span class="hljs-keyword">if</span> (fd == fd2)<br>    <span class="hljs-keyword">return</span> __libc_fcntl (fd, F_GETFL, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : fd;<br><br><span class="hljs-keyword">return</span> INLINE_SYSCALL_CALL (dup3, fd, fd2, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br>libc_hidden_def (__dup2)<br>weak_alias (__dup2, dup2)<br></code></pre></td></tr></table></figure></li><li>INLINE_SYSCALL_CALL 宏展开  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: sysdeps/unix/sysdep.h</span><br><br><span class="hljs-comment">/* Issue a syscall defined by syscall number plus any other argument</span><br><span class="hljs-comment">required.  Any error will be handled using arch defined macros and errno</span><br><span class="hljs-comment">will be set accordingly.</span><br><span class="hljs-comment">It is similar to INLINE_SYSCALL macro, but without the need to pass the</span><br><span class="hljs-comment">expected argument number as second parameter.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INLINE_SYSCALL_CALL(...) \</span><br><span class="hljs-meta">__INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INTERNAL_SYSCALL_DISP(b,...) \</span><br><span class="hljs-meta">__SYSCALL_CONCAT (b,__INTERNAL_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_CONCAT_X(a,b)     a##b</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)</span><br><span class="hljs-comment">// 以上几个宏的作用就是：根据参数个数，展开为宏__INLINE_SYSCALLn()</span><br><br><span class="hljs-comment">// 接着将参数展开，如下所示</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL0(name) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL1(name, a1) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 1, a1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL2(name, a1, a2) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 2, a1, a2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL3(name, a1, a2, a3) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 3, a1, a2, a3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL4(name, a1, a2, a3, a4) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 4, a1, a2, a3, a4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL5(name, a1, a2, a3, a4, a5) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 5, a1, a2, a3, a4, a5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL6(name, a1, a2, a3, a4, a5, a6) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 6, a1, a2, a3, a4, a5, a6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL7(name, a1, a2, a3, a4, a5, a6, a7) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 7, a1, a2, a3, a4, a5, a6, a7)</span><br><br><span class="hljs-comment">// in file: sysdeps/unix/sysdep.h</span><br><span class="hljs-comment">/* Wrappers around system calls should normally inline the system call code.</span><br><span class="hljs-comment">But sometimes it is not possible or implemented and we use this code.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> INLINE_SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INLINE_SYSCALL(name, nr, args...) __syscall_##name (args)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// in file: sysdeps/unix/sysv/linux/sysdep.h</span><br><span class="hljs-comment">/* Define a macro which expands into the inline wrapper code for a system</span><br><span class="hljs-comment">call.  It sets the errno and returns -1 on a failure, or the syscall</span><br><span class="hljs-comment">return value otherwise.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> INLINE_SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INLINE_SYSCALL(name, nr, args...)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    long int sc_ret = INTERNAL_SYSCALL (name, nr, args);\</span><br><span class="hljs-meta">    __glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (sc_ret))\</span><br><span class="hljs-meta">    ? SYSCALL_ERROR_LABEL (INTERNAL_SYSCALL_ERRNO (sc_ret))\</span><br><span class="hljs-meta">    : sc_ret;\</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-comment">// 宏 INTERNAL_SYSCALL 是专属于**sysv/linux**实现的，而且不同的硬件架构，其具体定义不同</span><br><span class="hljs-comment">// for x86-64, in file: sysdeps/unix/sysv/linux/x86_64/sysdep.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> INTERNAL_SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERNAL_SYSCALL(name, nr, args...)\</span><br><span class="hljs-meta">    internal_syscall##nr (SYS_ify (name), args)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> internal_syscall0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> internal_syscall0(number, dummy...)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    unsigned long int resultvar;\</span><br><span class="hljs-meta">    asm volatile (\</span><br><span class="hljs-meta">    <span class="hljs-string">&quot;syscall\n\t&quot;</span>\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;=a&quot;</span> (resultvar)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;0&quot;</span> (number)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;memory&quot;</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="hljs-meta">    (long int) resultvar;\</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-comment">// 这里可以看到，x86_64使用 syscall触发软中断，调用号应该也是放到寄存器中：&quot;0&quot;(number);参数分别放在r9,r8,r10,rdx,rsi,rdi中</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> internal_syscall1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> internal_syscall1(number, arg1)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    unsigned long int resultvar;\</span><br><span class="hljs-meta">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="hljs-meta">    register TYPEFY (arg1, _a1) asm (<span class="hljs-string">&quot;rdi&quot;</span>) = __arg1;\</span><br><span class="hljs-meta">    asm volatile (\</span><br><span class="hljs-meta">    <span class="hljs-string">&quot;syscall\n\t&quot;</span>\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;=a&quot;</span> (resultvar)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;0&quot;</span> (number), <span class="hljs-string">&quot;r&quot;</span> (_a1)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;memory&quot;</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="hljs-meta">    (long int) resultvar;\</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-comment">// for aarch64, in file: sysdeps/unix/sysv/linux/aarch64/sysdep.h</span><br><span class="hljs-meta"># <span class="hljs-keyword">undef</span> INTERNAL_SYSCALL</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> INTERNAL_SYSCALL(name, nr, args...)\</span><br><span class="hljs-meta">    INTERNAL_SYSCALL_RAW(SYS_ify(name), nr, args)</span><br><br><span class="hljs-comment">// 这里，SYS_ify将系统调用名，扩展为具体的系统调用号</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> SYS_ify</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_ify(syscall_name)(__NR_##syscall_name)</span><br><br><span class="hljs-comment">// 这里可以看到使用 svc 0 触发软中断，陷入内核，并在x8寄存器中存储系统调用号</span><br><span class="hljs-meta"># <span class="hljs-keyword">undef</span> INTERNAL_SYSCALL_RAW</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> INTERNAL_SYSCALL_RAW(name, nr, args...)\</span><br><span class="hljs-meta">(&#123; long _sys_result;\</span><br><span class="hljs-meta">    &#123;\</span><br><span class="hljs-meta">    LOAD_ARGS_##nr (args)\</span><br><span class="hljs-meta">    register long _x8 asm (<span class="hljs-string">&quot;x8&quot;</span>) = (name);\</span><br><span class="hljs-meta">    asm volatile (<span class="hljs-string">&quot;svc0// syscall &quot;</span> # name     \</span><br><span class="hljs-meta">            : <span class="hljs-string">&quot;=r&quot;</span> (_x0) : <span class="hljs-string">&quot;r&quot;</span>(_x8) ASM_ARGS_##nr : <span class="hljs-string">&quot;memory&quot;</span>);\</span><br><span class="hljs-meta">    _sys_result = _x0;\</span><br><span class="hljs-meta">    &#125;\</span><br><span class="hljs-meta">    _sys_result; &#125;)</span><br><br><span class="hljs-comment">// 可以看到，系统调用使用x0-6这7个寄存器进行参数传递</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> LOAD_ARGS_0()\</span><br><span class="hljs-meta">register long _x0 asm (<span class="hljs-string">&quot;x0&quot;</span>);</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> LOAD_ARGS_1(x0)\</span><br><span class="hljs-meta">long _x0tmp = (long) (x0);\</span><br><span class="hljs-meta">LOAD_ARGS_0 ()\</span><br><span class="hljs-meta">_x0 = _x0tmp;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-中断处理流程</title>
    <link href="/2024/07/10/Linux-aarch64-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/07/10/Linux-aarch64-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="中断处理流程"><a href="#中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>*<br>    *<br>        * </p><h3 id="aarch64"><a href="#aarch64" class="headerlink" title="aarch64"></a>aarch64</h3><ul><li><p>参考《vectors.md》可知，中断响应时，执行部分汇编码[kernel_ventry宏]后，进入<code>el0t_64_irq</code>[in file entry.S，用entry_handler宏定义]，紧接着调用<br><code>el0t_64_irq_handler</code>[in file: entry-common.c]，进行后续的处理</p></li><li><p>el0t_64_irq_handler -&gt; __el0_irq_handler_common -&gt; el0_interrupt(regs, handle_arch_irq);</p><ul><li><p>这里要注意：<code>handle_arch_irq</code>是一个全局的变量，定义在&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;irq.c文件中</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*handle_arch_irq)(<span class="hljs-keyword">struct</span> pt_regs *) __ro_after_init = default_handle_irq;     <span class="hljs-comment">// __ro_after_init 是编译器提供的属性</span><br><span class="hljs-type">void</span> (*handle_arch_fiq)(<span class="hljs-keyword">struct</span> pt_regs *) __ro_after_init = default_handle_fiq;<br><br><span class="hljs-type">int</span> __init <span class="hljs-title function_">set_handle_irq</span><span class="hljs-params">(<span class="hljs-type">void</span> (*handle_irq)(<span class="hljs-keyword">struct</span> pt_regs *))</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (handle_arch_irq != default_handle_irq)<br>        <span class="hljs-keyword">return</span> -EBUSY;<br><br>    handle_arch_irq = handle_irq;<br>    pr_info(<span class="hljs-string">&quot;Root IRQ handler: %ps\n&quot;</span>, handle_irq);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结合<code>__init set_handle_irq</code>可知，在系统启动阶段，irqchip的驱动会调用set_handle_irq，根据使用的中断控制器，将handle_arch_irq设置为对应的处理函数</p></li><li><p>对应的中断处理函数有：gic_handel_irq -&gt; GIC控制器</p></li></ul></li><li><p>gic_handle_irq</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: drivers/irqchip/irq-gic-v3.c</span><br><span class="hljs-type">static</span> asmlinkage <span class="hljs-type">void</span> __exception_irq_entry <span class="hljs-title function_">gic_handle_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (unlikely(gic_supports_nmi() &amp;&amp; !interrupts_enabled(regs)))<br>        __gic_handle_irq_from_irqsoff(regs);<br>    <span class="hljs-keyword">else</span><br>        __gic_handle_irq_from_irqson(regs);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>如果不是NMI中断，则__gic_handle_irq_from_irqson -&gt; __gic_handle_irq -&gt; generic_handle_domain_irq. 注意这里的irqnr为从相应寄存器[iar]读出的硬件中断号</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __gic_handle_irq(u32 irqnr, <span class="hljs-keyword">struct</span> pt_regs *regs)<br>&#123;<br>    <span class="hljs-keyword">if</span> (gic_irqnr_is_special(irqnr))<br>        <span class="hljs-keyword">return</span>;<br><br>    gic_complete_ack(irqnr);<br><br>    <span class="hljs-keyword">if</span> (generic_handle_domain_irq(gic_data.domain, irqnr)) &#123;<br>        WARN_ONCE(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;Unexpected interrupt (irqnr %u)\n&quot;</span>, irqnr);<br>        gic_deactivate_unhandled(irqnr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>generic_handle_domain_irq : irqdomain 管理hwirq 到 Linux irqnr的映射，有四种映射类型[Documentation\translations\zh_CN\core-api\irq\irq-domain.rst]</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: /kernel/irq/irqdesc.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">generic_handle_domain_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_domain *domain, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hwirq)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> handle_irq_desc(irq_resolve_mapping(domain, hwirq));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>handle_irq_desc</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">handle_irq_desc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_desc *desc)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_data</span> *<span class="hljs-title">data</span>;</span><br><br>    <span class="hljs-keyword">if</span> (!desc)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    data = irq_desc_get_irq_data(desc);<br>    <span class="hljs-keyword">if</span> (WARN_ON_ONCE(!in_hardirq() &amp;&amp; handle_enforce_irqctx(data)))<br>        <span class="hljs-keyword">return</span> -EPERM;<br><br>    generic_handle_irq_desc(desc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>generic_handle_irq_desc：根据描述符中的内容，执行相应的回调</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">generic_handle_irq_desc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_desc *desc)</span><br>&#123;<br>    desc-&gt;handle_irq(desc);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-向量表</title>
    <link href="/2024/07/10/Linux-aarch64-%E5%90%91%E9%87%8F%E8%A1%A8/"/>
    <url>/2024/07/10/Linux-aarch64-%E5%90%91%E9%87%8F%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="arm64-aarch64-的中断入口"><a href="#arm64-aarch64-的中断入口" class="headerlink" title="arm64(aarch64)的中断入口"></a>arm64(aarch64)的中断入口</h1><ul><li><p>总结</p><ul><li>部分汇编码，由宏kernel_ventry定义</li><li>el0t_64_irq</li><li>el0t_64_irq_handler</li><li>ret_to_user&#x2F;kernel</li></ul></li><li><p>相关两个宏定义：下面 \el，对宏参数展开</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs asm">    .macro entry_handler el:req, ht:req, regsize:req, label:req<br>SYM_CODE_START_LOCAL(el\el\ht\()_\regsize\()_\label)<br>    kernel_entry \el, \regsize<br>    movx0, sp<br>    blel\el\ht\()_\regsize\()_\label\()_handler      // 这里先调用el0t_64_irq_handler[在entry-common.c中定义]，bl是带返回的跳转[lr存储返回地址]<br>    .if \el == 0<br>    bret_to_user                                    // 返回用户空间<br>    .else<br>    bret_to_kernel                                  // 返回内核空间<br>    .endif<br>SYM_CODE_END(el\el\ht\()_\regsize\()_\label)<br>    .endm<br><br>// 这里使用上面的宏，定义了不同等级的异常入口：例如，el0t_64_irq， el0t_32_sync<br>/*<br>* Early exception handlers<br>*/<br>    entry_handler1, t, 64, sync<br>    entry_handler1, t, 64, irq<br>    entry_handler1, t, 64, fiq<br>    entry_handler1, t, 64, error<br><br>    entry_handler1, h, 64, sync<br>    entry_handler1, h, 64, irq<br>    entry_handler1, h, 64, fiq<br>    entry_handler1, h, 64, error<br><br>    entry_handler0, t, 64, sync<br>    entry_handler0, t, 64, irq<br>    entry_handler0, t, 64, fiq<br>    entry_handler0, t, 64, error<br><br>    entry_handler0, t, 32, sync<br>    entry_handler0, t, 32, irq<br>    entry_handler0, t, 32, fiq<br>    entry_handler0, t, 32, error<br><br>// 下面的宏使用，定义了向量表<br><br>/*<br>* Exception vectors.<br>*/<br>    .pushsection &quot;.entry.text&quot;, &quot;ax&quot;<br><br>    .align11<br>SYM_CODE_START(vectors)<br>    kernel_ventry1, t, 64, sync// Synchronous EL1t<br>    kernel_ventry1, t, 64, irq// IRQ EL1t<br>    kernel_ventry1, t, 64, fiq// FIQ EL1t<br>    kernel_ventry1, t, 64, error// Error EL1t<br><br>    kernel_ventry1, h, 64, sync// Synchronous EL1h<br>    kernel_ventry1, h, 64, irq// IRQ EL1h<br>    kernel_ventry1, h, 64, fiq// FIQ EL1h<br>    kernel_ventry1, h, 64, error// Error EL1h<br><br>    kernel_ventry0, t, 64, sync// Synchronous 64-bit EL0<br>    kernel_ventry0, t, 64, irq// IRQ 64-bit EL0<br>    kernel_ventry0, t, 64, fiq// FIQ 64-bit EL0<br>    kernel_ventry0, t, 64, error// Error 64-bit EL0<br><br>    kernel_ventry0, t, 32, sync// Synchronous 32-bit EL0<br>    kernel_ventry0, t, 32, irq// IRQ 32-bit EL0<br>    kernel_ventry0, t, 32, fiq// FIQ 32-bit EL0<br>    kernel_ventry0, t, 32, error// Error 32-bit EL0<br>SYM_CODE_END(vectors)<br><br>    .macro kernel_ventry, el:req, ht:req, regsize:req, label:req<br>    .align 7<br>.Lventry_start\@:<br>    .if\el == 0<br>    /*<br>    * This must be the first instruction of the EL0 vector entries. It is<br>    * skipped by the trampoline vectors, to trigger the cleanup.<br>    */<br>    b.Lskip_tramp_vectors_cleanup\@<br>    .if\regsize == 64<br>    mrsx30, tpidrro_el0<br>    msrtpidrro_el0, xzr<br>    .else<br>    movx30, xzr<br>    .endif<br>.Lskip_tramp_vectors_cleanup\@:<br>    .endif<br><br>    subsp, sp, #PT_REGS_SIZE<br>#ifdef CONFIG_VMAP_STACK<br>    /*<br>    * Test whether the SP has overflowed, without corrupting a GPR.<br>    * Task and IRQ stacks are aligned so that SP &amp; (1 &lt;&lt; THREAD_SHIFT)<br>    * should always be zero.<br>    */<br>    addsp, sp, x0// sp&#x27; = sp + x0<br>    subx0, sp, x0// x0&#x27; = sp&#x27; - x0 = (sp + x0) - x0 = sp<br>    tbnzx0, #THREAD_SHIFT, 0f<br>    subx0, sp, x0// x0&#x27;&#x27; = sp&#x27; - x0&#x27; = (sp + x0) - sp = x0<br>    subsp, sp, x0// sp&#x27;&#x27; = sp&#x27; - x0 = (sp + x0) - x0 = sp<br>    bel\el\ht\()_\regsize\()_\label                                  // 前面如果成功的话，会跳转到相应的前面定义的elnt_size_name：el0t_64_irq<br><br>0:<br>    ......<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>APUE-Learning-1</title>
    <link href="/2024/07/10/APUE-Learning-1/"/>
    <url>/2024/07/10/APUE-Learning-1/</url>
    
    <content type="html"><![CDATA[<h1 id="UNIX基础知识"><a href="#UNIX基础知识" class="headerlink" title="UNIX基础知识"></a>UNIX基础知识</h1><p>主要介绍了基础的UNIX知识，帮助初学者在UNIX环境下“存活下来”</p><ul><li><p>标准系统函数的返回值，一般来解释如下</p><ul><li><code>&gt;= 0</code> -&gt; 表示程序正常执行</li><li><code>&lt; 0</code> -&gt; 表示程序出错，返回的负数可以表征具体的错误码</li></ul></li><li><p>三个标准“文件描述符”</p><ul><li><code>STDIN_FILENO = 0</code></li><li><code>STDOUT_FILENO = 1</code></li><li><code>STDERR_FILENO = 2</code></li></ul></li><li><p>&lt;unistd.h&gt; : unix std -&gt; 标准头文件，包含了很多UNIX系统服务的函数原型</p><ul><li>有很多<code>unistd.h</code>头文件，用户开发应该使用&lt;unistd.h&gt;，其具体指<code>/usr/inlcude/unistd.h</code></li></ul></li><li><p>不带缓冲的I&#x2F;O <code>VS</code> 标准I&#x2F;O (带缓冲)</p><ul><li>&lt;unistd.h&gt; -&gt; 提供不带缓冲I&#x2F;O的函数原型: read, write, lseek。使用时需要提供<code>缓冲区大小</code>参数</li><li>&lt;stdio.h&gt; -&gt; 提供标准I&#x2F;O的函数原型: scanf, printf。使用时无需担心最优缓冲区大小，因为开发人员无需提供缓冲区大小参数。此外，还定义了标准常量<code>stdin</code>，<code>stdout</code></li></ul></li><li><p>用于进程控制的三个主要函数</p><ul><li>fork：返回值为0，表示处于子进程中；返回值大于0，表示处于父进程中，且返回值为子进程的PID；返回值小于0，fork出错</li><li>exec：有7个变体，统称exec函数</li><li>waitpid：</li><li>fork -&gt; exec函数，创建新进程，执行新的程序</li></ul></li><li><p>头文件组织</p><ul><li>&#x2F;usr&#x2F;include&#x2F;linux, &#x2F;usr&#x2F;inlcude&#x2F;asm* 下的头文件是与Linux内核一起分发的</li><li>&#x2F;usr&#x2F;include&#x2F;sys&#x2F;*.h, &#x2F;usr&#x2F;include&#x2F;bits&#x2F;*.h 下的头文件是与C库一起分发的</li><li><code>LC_ALL=C gcc -v -xc -E /dev/null 2&gt;&amp;1 | sed -ne &#39;/search starts here/,/End of search list/p&#39;</code>用于输出gcc的头文件搜索路径</li></ul></li><li><p>时间相关</p><ul><li><strong>日历时间</strong>：UNIX系统的基本时间服务计算自世界协调时间[1970年1月1日00:00:00]以来经过的秒数，以<code>time_t</code>类型表示，可使用<code>time()</code>获取</li><li><strong>进程时间</strong>[CPU时间]：用以度量进程使用的中央处理器资源，以时钟滴答计算，每秒钟多少个滴答是一种系统配置，使用<code>clock_t</code>类型表示</li></ul><p>  UNIX系统为一个进程维护了3个时间值【进程时间】：</p><ul><li><p>时钟时间[real][墙上时间]，进程运行的时间总量，与系统中同时运行的进程数有关</p></li><li><p>用户CPU时间[user]：执行用户指令所用的时间总量</p></li><li><p>系统CPU时间[sys]：程序执行内核服务的时间总量</p></li><li><p>POSIX扩展规范增加了对多个<strong>系统</strong>时钟的支持，通过<code>clockid_t</code>类型标识不同的POSIX系统时钟</p><ul><li>CLOCK_REALTIME：类型于UNIX系统提供的[real]，但是在系统支持高精度时间值的情况下，可以获得更高精度的时间值</li><li>CLOCK_MONOTONIC：不带负跳数的CLOCK_REALTIME</li><li>CLOCK_PROCESS_CPUTIME_ID：调用函数获取该时间的进程的CPU时间<br>  使用<code>clock_gettime(clockid_t id, struct timespec *tsp)</code>获取不同的系统时钟时间，其中<code> struct timespec</code>采用秒+纳秒的方式来表示时间值</li></ul></li></ul></li></ul><h1 id="UNIX标准及实现"><a href="#UNIX标准及实现" class="headerlink" title="UNIX标准及实现"></a>UNIX标准及实现</h1><ul><li>相关的两个标准<ul><li>ISO C</li><li>IEEE POSIX -&gt; 不区分接口是系统调用还是库函数，统称为函数</li><li>这些标准规范了符号标准的UNIX操作系统必须提供的接口。当然，操作系统要发挥作用，还要有其一般的通用功能。因此可以说，<u>标准定义了任一实际系统的子集</u>。</li><li>有些属于UNIX系统必须，但在符合POSIX标准的系统中是可选的功能</li></ul></li><li>限制<ul><li>幻数、常量的值，在不同系统下的值究竟为多少？具体分为如下两种类型：<ul><li>编译时限制（例如，短整型的最大值是多少？）可在头文件中定义</li><li>运行时限制（例如，文件名最多能有多少个字符？），要求进程调用一个相关的函数获取具体的限制值</li><li>然而有些限制在一个给定的UNIX实现中可能是固定的，而在另一个UNIX实现中则可能是变动的</li></ul></li><li>为了解决这类问题，提供了以下三种限制：<ul><li>编译时限制（头文件）</li><li>与文件或目录无关的运行时限制（<code>sysconf</code>函数）</li><li>与文件或目录有关的运行时限制（<code>pathconf</code>和<code>fpathconf</code>函数）</li><li>如果一个运行时限制在一个给定的UNIX实现上并不改变，则可将其静态地定义在一个头文件中。如果没有将其定义在头文件中，应用程序就必须调用上述的三个<code>conf</code>函数之一以确定其运行时值</li></ul></li><li>ISO C 标准的所有限制都在&lt;limits.h&gt;文件中</li></ul></li></ul><h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><ul><li><p>Unbuffered I&#x2F;O: “不带缓冲”指每个read&#x2F;write都调用内核中的一个系统调用[实际还是会使用内核的缓冲区的]。它们不是ISO C标准，而是POSIX.I的组成部分</p><ul><li>open(), 除非指定<code>O_APPEND</code>flag，否则打开文件时的偏移量都为0，返回值为文件描述符</li><li>lseek(), 显式地为一个已经打开的文件设置偏移量。返回值为添加之后新的文件偏移量。它仅将当前的文件偏移量记录在内核，不会引起任何I&#x2F;O操作<ul><li>相对文件开始的偏移量，只能为+</li><li>相对当前值的偏移量，+-均可</li><li>相对文件结尾的偏移量，+-均可</li></ul></li><li>read(), 返回读到的字节数</li><li>write(), 返回实际写入的字节数</li></ul></li><li><p>多个进程间如何共享文件？【涉及到多进程间资源共享】</p><ul><li>文件描述符表，独属于某个进程，每个描述符表项，包含一个指向某文件表项的指针</li><li>打开文件表，由<strong>内核</strong>维护。每个文件表项包含: 文件状态，<strong>当前文件偏移量</strong>，指向i节点的指针。</li><li>文件系统的i节点表，由<strong>内核</strong>维护。每个打开文件都唯一对应一个i-node节点</li><li>如果有两个进程打开同一个文件：则该文件会有两个文件表项分别对应每个进程；该文件在这两个进程中分别有一个文件描述符；但是该文件只有一个i-node</li></ul></li><li><p>原子操作</p><ul><li>write() 是原子操作的吗？两个进程对该文件同时进行写，如果不加互斥，会出问题吗？</li><li>pwrite() 应该是原子的？</li></ul></li><li><p>文件高级操作</p><ul><li>dup(int fd), dup2(int fd, int fd2)<ul><li>dup() 返回的新描述符一定是当前可用描述符中最小的</li><li>dup2() 可由用户指定fd2为新的描述符；如果fd2已经打开，则先关闭fd2</li><li>这两个函数返回的新描述符与原描述符共享打开文件表项</li></ul></li><li>sync(), fsync(), fdatasync()<ul><li>UNIX系统内核中设有缓冲区，大多数磁盘I&#x2F;O都通过缓冲区进行。例如，当写文件时，内核通常先将数据复制到缓冲区，然后排入队列，晚些时候再写入磁盘，<br>  这种方式称为“延迟写”。</li><li>提供了上述3个函数以保证磁盘上实际文件内容与缓冲区中内容一致</li><li>sync()，将修改过的块缓冲区排入队列，返回。不等待磁盘写操作</li><li>fsync(int fd)，只对由fd指定的文件起作用，且等待实际磁盘I&#x2F;O操作完成</li><li>fdatasync(int fd)，与fsync类型，但是只影响文件数据部分</li></ul></li><li>fcntl(int fd, int cmd, &#x2F;* int arg *&#x2F;)<ul><li>根据cmd的不同，可以提供5大类的功能</li></ul></li><li>ioctl()</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言再学习</title>
    <link href="/2024/07/10/C%E8%AF%AD%E8%A8%80%E5%86%8D%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/10/C%E8%AF%AD%E8%A8%80%E5%86%8D%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="C语言再学习"><a href="#C语言再学习" class="headerlink" title="C语言再学习"></a>C语言再学习</h2><ul><li><p>#incude &lt;&gt; &#x2F; #include “”的区别</p><ul><li>有三个路径需要区分：<ul><li>系统库路径 -&gt; <strong>无需配置</strong>，这个路径已经<u>硬</u>写入了编译器的配置中</li><li>工程定义头文件搜索目录 -&gt; 需要使用编译器提供的参数选项进行配置，例如<code>gcc -I &lt;search_path&gt;</code></li><li>当前目录 -&gt; 无需配置，但是只有使用<code>#include &quot;xxx.h&quot;</code>格式的才会在当前路径下查找</li></ul></li><li>前两种路径都可以使用<code>#inlcude &lt;&gt;</code>进行包含</li></ul></li><li><p>数组与指针变量的区别</p><ul><li>char str[20]; char *ptr_s &#x3D; “abcdefg”;   -&gt; 索引操作：str[5] 与 pstr_s[5]</li><li>str[5]，[汇编层面理解：str表示数组所在的地址]，因此只需要将这个地址加上索引*size，再对新得到的地址进行取值操作即可</li><li>pstr_s[5]，[pstr_s是一个变量，要先取值得到地址值]，之后的操作同上</li><li><strong>作为函数形参</strong>：char *ptr 与 char ptr[]是一样的。这是由于出于性能的考虑，一般把数组传递给函数时，只会传递数组首元素的地址。因此，这两种形参，在函数内部都是得到一个指针。</li></ul></li><li><p>gcc相关编译参数</p><ul><li>-L ：链接时库搜索路径</li><li>-R ：运行时库搜索路径。这个信息会被写入到最终的可执行文件中，并被动态加载其解析使用</li><li>-l : 指定需要参与链接的库</li></ul></li><li><p>little trick -&gt; 静态链接</p><ul><li>gcc -c main.c -lmath -o main  -&gt; 这里源文件出现在库之前</li><li>gcc -lmath -c main.c -o main  -&gt; 库出现在main之前，此时还没有未定义的符号，因此不从库中提取任何符号；因此在链接时可能会报“符号未定义”的错误</li></ul></li><li><p>局部变量及初始化</p><ul><li>不会出现在最终的可执行文件中，运行时在栈上创建</li><li>有明确的代码进行栈空间的开辟，且<strong>初始值会作为指令的操作数</strong>出现在代码段中</li></ul></li><li><p>常见错误：</p><ul><li>总线错误：一般都是由于未对齐的读或写引起</li><li>段错误：通常是由于解引用一个未初始化或非法的地址值引起</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计规范</title>
    <link href="/2024/07/10/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <url>/2024/07/10/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a><a href="http://10.1.14.75/team/compass/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">设计规范</a></h2><ul><li><p>使用指定长度的数据类型，需编译器提供&lt;stdint.h&gt;头文件，或者已知硬件芯片字长的情况下自定义</p></li><li><p>在结构体中，人为添加pad以实现结构体内成员的<strong>自然对齐</strong>，不要依赖编译器进行</p></li><li><p>CPU间通信的数据结构中，不能包含enum类型的变量</p></li><li><p>静态数据表应使用const进行修饰</p><ul><li>一方面，const修饰的通常保存在flash中，节省RAM空间</li><li>其次，防止数据被篡改</li></ul></li><li><p>指针对齐考虑 【这个问题之前还真没有考虑过！！！】</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> buf[<span class="hljs-number">4</span>];             <span class="hljs-comment">// -&gt; 这里buf是1字节对齐的，即buf的值可能为0xc0080001</span><br><span class="hljs-type">uint32_t</span>* ptr_a = buf;      <span class="hljs-comment">// -&gt; 这里ptr_a指向变量类型为4字节对齐，因此ptr_a要求是4字节对齐的。因此，这样赋值可能会出现问题</span><br><br></code></pre></td></tr></table></figure><ul><li>当指针指向的内存地址不能满足指针数据类型的对齐要求时，一般情况下，指针会<strong>向下</strong>做对齐操作。例如指针要求4字节对齐，而指向的地址为0x80000002，指针会自动向下做对齐指向0x80000000地址。</li><li>因此，遇到将小数据类型的地址赋值给大数据类型的指针变量时，要意识到可能会有这种问题的存在</li><li>尤其在回调接口中，为了通用性，一般使用<code>uint8_t*</code>类型的指针，针对用户提供的该指针，后续进行类型强转时，需要先判断其是否符合类型指针对齐的要求，再进行强转操作</li></ul></li><li><p>函数调用时提供函数原型很重要，尤其对于函数返回值；某些情况下，函数形参也很重要，因为涉及到参数入栈</p></li><li><p>独立组件模块：为了提高组件的可移植性，不允许直接使用外部变量，调用外部函数；而是通过回调函数的形式 -&gt; 初始化时，需要向组件注册回调函数，当组件检测到相应场景时，调用相应之前注册的回调函数</p></li><li><p>分层设计：组件与硬件、操作系统等资源相关；将与 <strong>硬件</strong> 、 <strong>操作系统</strong> 等平台相关的代码独立出来，定义成<strong>驱动层</strong>，而与平台无关的代码定义成<strong>核心层</strong>。核心层与驱动层定义一套接口，__接口由核心层定义，驱动来实现__。通过上层应用将驱动层与核心层关联起来，一般采用 <strong>函数指针</strong> 的方式将驱动层与核心关联起来。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CI/CD相关基础</title>
    <link href="/2024/07/10/CI-CD%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/07/10/CI-CD%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="CI-CD相关"><a href="#CI-CD相关" class="headerlink" title="CI&#x2F;CD相关"></a>CI&#x2F;CD相关</h2><ul><li>CI -&gt; 自动化测试<strong>持续集成</strong>， <a href="https://wiki.hikvision.com.cn/pages/viewpage.action?pageId=100687349">参考</a></li><li>**持续集成(CI)**：借助工具对软件项目进行持续的自动化的编译、打包、构建、测试、发布，来检查软件交付质量的一种行为</li><li>**持续部署(CD)**：基于__持续交付__的优势自动将经过测试的代码推入生产环境的过程</li></ul><h3 id="CI各阶段"><a href="#CI各阶段" class="headerlink" title="CI各阶段"></a>CI各阶段</h3><ul><li><em><strong>代码提交阶段</strong></em>：会用到“版本控制工具”进行源代码的版本控制</li><li><em><strong>静态代码检查阶段</strong></em>：只能检查代码语法错误等问题；代码运行时错误需要在后续的流程中进行测试、检查</li><li><em><strong>构建阶段</strong></em>：即 __编译应用程序__；一般包含 __构建验证测试__（检查所有模块是否正确集成？关键功能是否正常？）、__单元测试__（验证开发人员编写的单个元件、组件是否按预期执行）；还要将经过前期验证的 <strong>构建产物存储</strong> 起来</li><li><em><strong>测试阶段</strong></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SVN简单学习</title>
    <link href="/2024/07/10/SVN%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/10/SVN%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="SVN-command"><a href="#SVN-command" class="headerlink" title="SVN command"></a>SVN command</h2><ul><li><p>“改名”操作需要使用SVN进行，不要使用Windows下面的重命名，因为这个操作不受 SVN 控制，SVN 会将其理解为删除原文件、增加一个新文件，从而导致文件改名后不能跟踪到改名前的状态</p></li><li><p>“受SVN控制”是个挺重要的概念，在本地新建文件后，需要使用<code>add</code>操作将该新建文件纳入SVN的控制中；因此<strong>所有的操作最好都使用SVN进行</strong>，包括</p><ul><li>创建新文件&#x2F;夹，创建后要使用<code>add</code>操作</li><li>移动文件&#x2F;夹</li><li>修改文件&#x2F;夹的名字</li><li>删除文件&#x2F;夹</li><li>尽量不要使用Windows&#x2F;Linux提供的文件&#x2F;夹修改功能</li></ul></li><li><p>“更新至版本（U）” -&gt; 用于取回某个历史版本到本地 【类似git里面的checkout？】</p></li><li><p>“还原（V）” -&gt; 只能在“提交”到远程服务器之前进行，用于放弃本地的某些操作【可选的】</p></li><li><p>“复原（显示日志，选择某个要还原的版本）”，在某历史版本上进行后续的操作，提交后此版本将作为远程版本库的最新版本</p></li><li><p>“branch” -&gt; 先在远程创建分支，<strong>再更新</strong>到本地 【与git操作不同】，分支的基点可以选择三种不同的方式：</p><ul><li>“最新版本”，以最先版本作为基点</li><li>“指定版本”</li><li>“工作副本”，以本地工作副本作为基点？【这个内容需要进一步确认】【这个代表什么意思？】【已确认：就是本地工作空间】</li></ul></li><li><p>“合并分支操作” -&gt; </p><ul><li>先将自己工作的分支cyokeo-r1，提交到远程服务器</li><li>拉取要合并到的<code>分支</code>到本地，在该分支的文件夹上点击进行<code>合并</code>操作</li><li>感觉SVN的合并，一般是<code>Leader</code>干的活？</li><li>合并，并解决完冲突后，进行提交操作</li></ul></li><li><p>“切分支”</p><ul><li>优先使用CI进行SVN路径切分支操作，方便CI进行代码目录的继承关系管理。【CI是？】</li><li>CI无法满足要求时，使用SVN客户端切分支，要使用SVN工具的branch&#x2F;tag功能，而不要先下载下来再人为上传到新的目录。如果采用SVN的branch&#x2F;tag功能，只是创建了一个”副本”，方便版本追溯</li></ul></li><li><p>提交颗粒度尽量小，以减小他人合并的难度</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>距离相关</title>
    <link href="/2024/07/09/%E8%B7%9D%E7%A6%BB%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/07/09/%E8%B7%9D%E7%A6%BB%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://oi-wiki.org/geometry/distance/">距离</a></li></ul><h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><ul><li>D(A, B) &#x3D; abs(x1 - x2) + abs(y1 - y2)</li><li>(x, y) -&gt; (x+y, y-x)后，新坐标系下的切比雪夫距离为原坐标系下的曼哈顿距离</li><li><a href="https://leetcode.cn/problems/minimize-manhattan-distances/description/">3102. 最小化曼哈顿距离</a></li><li></li></ul><h2 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h2><ul><li>D(A, B) &#x3D; max(|x1 - x2|, |y1 - y2|)</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动规题单</title>
    <link href="/2024/07/07/%E5%8A%A8%E8%A7%84%E9%A2%98%E5%8D%95/"/>
    <url>/2024/07/07/%E5%8A%A8%E8%A7%84%E9%A2%98%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="我的动态规划题单"><a href="#我的动态规划题单" class="headerlink" title="我的动态规划题单"></a>我的动态规划题单</h2><p>动态规划有两个难点：</p><ul><li>不知道是否应该使用动态规划</li><li>动态规划的递推推导不出来</li></ul><h2 id="递推关系不太难想的，一般都很难想到使用动态规划的方法"><a href="#递推关系不太难想的，一般都很难想到使用动态规划的方法" class="headerlink" title="递推关系不太难想的，一般都很难想到使用动态规划的方法"></a>递推关系不太难想的，一般都很难想到使用<u>动态规划</u>的方法</h2><ul><li><a href="https://leetcode.cn/problems/wildcard-matching/description/">44. 通配符匹配</a><ul><li>这个题目有个点：‘<em>’是万能的，连续的‘</em>’和一个‘*’是一样的</li></ul></li><li>[10. 正则表达式匹配]</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c/cpp小技巧</title>
    <link href="/2024/07/06/c-cpp%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/07/06/c-cpp%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="如何计算负数的补码"><a href="#如何计算负数的补码" class="headerlink" title="如何计算负数的补码"></a>如何计算负数的补码</h2><ul><li>负数一般以补码的形式存储</li><li>如果位数为(8), 则负数a的补码为<code>pow(2,n) - abs(a)</code></li><li>另外，负数a的补码也可根据：abs(a)的反码 + 1 得到</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2024/07/06/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/06/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/575568/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86">leetcode 宫水三叶</a></li><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/2600821/kan-bu-dong-ni-da-wo-kmp-suan-fa-chao-qi-z1y0">从next数组的求解解读KMP算法</a></li><li><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF">还是carl的好理解一些</a></li></ul><h2 id="解决场景"><a href="#解决场景" class="headerlink" title="解决场景"></a>解决场景</h2><ul><li>如何快速在「原字符串」中找到「匹配字符串」</li><li>时间复杂度：O(m + n)，其中m，n分别为原字符串，待匹配字符串的长度</li><li>其能在「非完全匹配」的过程中提取到有效信息进行复用，以减少「重复匹配」的消耗。</li></ul><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ul><li>next数组是模式串的相同最长前后缀长度表</li><li>next[j]表示模式串中，字串[0, j-1]的相同最长前后缀的长度</li><li>“a”，“”，“abc”的最长前后缀长度均为0；“aabcaa”的最长相同前后缀的长度为2</li><li>当主串的第i个位置和模式串的第j个位置不相同时，模式串的匹配只需<strong>回退</strong>到 j’ &#x3D; next[j]的下一个位置。因为可以保证：<code>模式串的前j&#39;个字符[0, j&#39;]与主串第i个位置前的j&#39;个字符是相同的</code></li></ul><h2 id="如何求模式串的next数组"><a href="#如何求模式串的next数组" class="headerlink" title="如何求模式串的next数组"></a>如何求模式串的next数组</h2><ul><li><p>“abcabd”</p></li><li><p>“abacabad”：</p>  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="language-ruby">&gt; <span class="hljs-symbol">b:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> 所在的位置与b不同；由于<span class="hljs-keyword">next</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>，所以<span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">2</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">c:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span> 所在的位置与c不同；<span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> 所在的位置与c不同；因此<span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">b:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span> 所在的位置与b相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] = <span class="hljs-number">2</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">3</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">d:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>] = <span class="hljs-number">3</span> 所在的位置与d不同；<span class="hljs-keyword">next</span>[<span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>]] = <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>；因此<span class="hljs-keyword">next</span>[<span class="hljs-number">7</span>] = <span class="hljs-number">0</span>;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="字符串哈希（https-leetcode-cn-problems-shortest-palindrome-solutions-1396220-by-flix-be4y"><a href="#字符串哈希（https-leetcode-cn-problems-shortest-palindrome-solutions-1396220-by-flix-be4y" class="headerlink" title="字符串哈希（https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y)"></a>字符串哈希（<a href="https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y">https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y</a>)</h2><ul><li>构造next数组的算法：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = tmp.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-type">int</span> k = i<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; tmp[next[k]] != tmp[i]) &#123;k = next[k]<span class="hljs-number">-1</span>;&#125;<br>    <span class="hljs-keyword">if</span> (k &gt;= <span class="hljs-number">0</span>) next[i] = next[k] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> next[i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h2><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></li><li><a href="https://leetcode.cn/problems/shortest-palindrome/solutions/392561/zui-duan-hui-wen-chuan-by-leetcode-solution/">214. 最短回文串</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题目复习</title>
    <link href="/2024/07/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/07/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li><p>904.水果成篮，结合<a href="https://leetcode.cn/problems/fruit-into-baskets/solutions/1437444/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr">题解</a>，深入理解：</p><ul><li>最大滑动窗口 - 模版  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(nums):<br>    // 判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> 不满足条件：<br>        i += <span class="hljs-number">1</span> //（最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）<br>    // 不断更新结果（注意在<span class="hljs-keyword">while</span>外更新！）<br>    j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>最小滑动窗口 - 模版  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(nums):<br>    // 判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> 满足条件：<br>        // 不断更新结果(注意在<span class="hljs-keyword">while</span>内更新！)<br>        i += <span class="hljs-number">1</span> //（最大程度的压缩i，使得滑窗尽可能的小）<br>    j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>确实，有了模版后，遇到滑窗问题，思路更加<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/submissions/544105543/">清晰了</a></li></ul></li><li><p>字符串哈希：使用hash映射，减小索引的存储消耗！！！<a href="https://leetcode.cn/problems/repeated-dna-sequences/solutions/1035568/zhong-fu-de-dnaxu-lie-by-leetcode-soluti-z8zn">参考</a></p><ul><li>选取一个大于字符集大小的质数作为base</li><li>将字符映射为小于base的数：map()</li><li>‘abccd’ -&gt; map(a)*base^0 + map(b)*base^1 + map(c)*base^2 + map(c)*base^3 + map(d)*base^4</li><li><a href="https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y">参考</a></li></ul></li><li><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solutions/2551432/liang-chong-fang-fa-ni-xiang-si-wei-zhen-e3gb">最大&#x2F;小子序和</a></p><ul><li>通过取相反数，将最小子序和转化为最大字序和问题</li><li>前缀和 法</li><li>贪心 + dp 法  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cardPoints)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> maxSubArray = [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>            <span class="hljs-comment">//实现1：前缀和</span><br>            <span class="hljs-comment">// int res = INT_MIN, pre_sum = 0, min_pre_sum = 0;</span><br>            <span class="hljs-comment">// for (auto&amp; x : nums) &#123;</span><br>            <span class="hljs-comment">//     pre_sum += x;</span><br>            <span class="hljs-comment">//     res = max(res, pre_sum - min_pre_sum);</span><br>            <span class="hljs-comment">//     min_pre_sum = min(min_pre_sum, pre_sum);</span><br>            <span class="hljs-comment">// &#125;</span><br>            <span class="hljs-comment">// return res;</span><br><br>            <span class="hljs-comment">//实现2：贪心 + dp</span><br>            <span class="hljs-comment">//s = 0考虑了k = 0时的情况</span><br>            <span class="hljs-type">int</span> res = INT_MIN, s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : nums) &#123;<br>                <span class="hljs-keyword">if</span> (s &lt;= <span class="hljs-number">0</span>) s = <span class="hljs-number">0</span>;<br>                s += x;<br>                res = <span class="hljs-built_in">max</span>(res, s);<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-comment">//累加总和为s</span><br>        <span class="hljs-type">int</span> s = <span class="hljs-built_in">accumulate</span>(cardPoints.<span class="hljs-built_in">begin</span>(), cardPoints.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//将数组的每个元素乘以-1, 用来求连续子数组的最大和</span><br>        <span class="hljs-built_in">transform</span>(cardPoints.<span class="hljs-built_in">begin</span>(), cardPoints.<span class="hljs-built_in">end</span>(), cardPoints.<span class="hljs-built_in">begin</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> -x; &#125;);<br>        <span class="hljs-comment">//答案 = 总和 - 连续子数组的最小和</span><br>        <span class="hljs-keyword">return</span> s - (-<span class="hljs-built_in">maxSubArray</span>(cardPoints));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/submissions/546160358/">1838.最高频元素的频数</a></p><ul><li>需要动脑思考一下，察觉为使用滑动窗口</li></ul></li></ul><h2 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h2><ul><li><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文字串</a><ul><li>加深理解：如果字串长度为奇数，则只能为<code>aba</code>类型；但是当字串长度为偶数是，可以为<code>aa</code>，也可以为<code>abaaba</code></li><li>自己想到了使用dp数组，记忆化遍历，以减小重复遍历。但是时间表现还是很差❗️❗️</li><li>注意到回文串的中间部分一定是由连续且相同的字符串组成，因此可以定位到中间字符，再左右扩展查询，<a href="https://leetcode.cn/problems/longest-palindromic-substring/description/comments/59461">参考</a>❗️  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><span class="hljs-comment">//         保存起始位置，测试了用数组似乎能比全局变量稍快一点</span><br>        <span class="hljs-type">int</span>[] range = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">char</span>[] str = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><span class="hljs-comment">//             把回文看成中间的部分全是同一字符，左右部分相对称</span><br><span class="hljs-comment">//             找到下一个与当前字符不同的字符</span><br>            i = findLongest(str, i, range);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(range[<span class="hljs-number">0</span>], range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLongest</span><span class="hljs-params">(<span class="hljs-type">char</span>[] str, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span>[] range)</span> &#123;<br><span class="hljs-comment">//         查找中间部分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">while</span> (high &lt; str.length - <span class="hljs-number">1</span> &amp;&amp; str[high + <span class="hljs-number">1</span>] == str[low]) &#123;<br>            high++;<br>        &#125;<br><span class="hljs-comment">//         定位中间部分的最后一个字符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> high;<br><span class="hljs-comment">//         从中间向左右扩散</span><br>        <span class="hljs-keyword">while</span> (low &gt; <span class="hljs-number">0</span> &amp;&amp; high &lt; str.length - <span class="hljs-number">1</span> &amp;&amp; str[low - <span class="hljs-number">1</span>] == str[high + <span class="hljs-number">1</span>]) &#123;<br>            low--;<br>            high++;<br>        &#125;<br><span class="hljs-comment">//         记录最大长度</span><br>        <span class="hljs-keyword">if</span> (high - low &gt; range[<span class="hljs-number">1</span>] - range[<span class="hljs-number">0</span>]) &#123;<br>            range[<span class="hljs-number">0</span>] = low;<br>            range[<span class="hljs-number">1</span>] = high;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a><ul><li>double, long long等数据类型的区别</li></ul></li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><p><a href="https://leetcode.cn/problems/task-scheduler/submissions/546146727/">621. 任务调度器</a></p><ul><li>需要动脑袋思考一下</li></ul></li><li><p><a href="https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-ii/description/">2972. 统计移除递增子数组的数目</a></p></li><li><p><a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/">1574. 删除最短的子数组使剩余数组有序</a></p><ul><li>与2972的思路一样</li></ul></li><li><p><a href="https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/description/">1712. 将数组分成三个子数组的方案数</a></p><ul><li>前缀和，需要动笔简单算一下</li></ul></li><li><p><a href="https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/description/">2106. 摘水果</a></p><ul><li>需要思考想到为前缀和</li><li>简单计算区间公式</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>提问记录</title>
    <link href="/2024/06/28/%E6%8F%90%E9%97%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/28/%E6%8F%90%E9%97%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="24-06-27"><a href="#24-06-27" class="headerlink" title="24-06-27"></a>24-06-27</h2><ol><li><p>DDS可靠性相关 -&gt; 如何保证可靠性？接收端来不及处理时，如何保证？</p><ul><li>DDS可以理解为是一种传输协议，它的可靠性可以保证：发端发送一条消息后，可以到达接收端的DDS协议栈中，并驻留在接收端的History中。如果接收端的应用层来不及处理新收到的消息，那就不立即处理，后续可以使用read接口从协议栈中获取之前接收到的数据。</li><li>上述可能会出现接收端缓存满，而尚有消息未处理的情况：此时，就需要扩大History的消息缓存数目。这里就是History QoS 与 Resource QoS这两种不同服务质量要求之间的trade了。</li></ul></li><li><p>MCU上做开发与Linux用户态开发有什么不同？分别有哪些需要注意的内容？</p><ul><li>MCU上直接看到真实物理内存，Linux用户态多了一层虚拟地址转换。因此在MCU上做开发时，更要注意对指针的使用。</li><li>MCU上有时Linker，链接脚本，程序、变量存放位置；Linux用户态不用考虑这些问题。</li><li>调试时，MCU上遇到TRAP等问题，要去翻具体的芯片架构手册进行排查；Linux用户态有一套标准的exception机制。</li><li>MCU上做开发更类似于Linux内核态驱动开发。</li><li>MCU上有时需要考虑boot的问题，Linux用户态不用考虑。</li><li>MCU上开发一般只会用到静态库，而Linux上还会有动态库。</li></ul></li><li><p>(之前软硬件结合提到了对指针的“恍然大悟”)那你现在是如何理解指针的？</p><ul><li>指针就是一个普通的变量，对它进行加减乘除，函数参数，就像普通变量那样使用</li><li>重点在于如何使用指针变量，如何解释指针 -&gt; 这里就得说一下指针类型转换</li><li>使用时，相比于普通变量，要多考虑一层：它指向了某块内存区域！内存区域的大小与指针指向的对象类型有关</li><li>指针使用：大部分都会取成员 -&gt; 指针指向的对象类型是什么？这个问题也要时刻注意</li><li>c++中，class C 继承于 class B , class A。<code>C v_c; B* p_b = &amp;v_c; A* p_a = &amp;v_c</code>，这三行语句，p_b的值与p_a的值是不一样的！</li><li>在c语言中，常把指针和数组进行比较。</li></ul></li><li><p>用一个词形容操作系统</p><ul><li>管理者</li><li>根据管理的内容不同，OS又可以分为宏内核&#x2F;微内核</li><li>MCU上的OS一般只有CPU管理的功能</li><li>SoC上使用基于Linux的操作系统，还会有内存管理，进程通信，文件系统等功能</li></ul></li></ol><h2 id="24-07-04"><a href="#24-07-04" class="headerlink" title="24-07-04"></a>24-07-04</h2><ol><li><p>如何在不使用额外变量的情况下，交换两个整形变量的值</p><ul><li>方法一：采用数学运算 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = x + y<span class="hljs-comment">;  // -&gt; 虽然这里可能会有溢出的情况，但**由于**负数采用补码的方式表示，后续运算后，也能实现交换的目的</span><br><span class="hljs-attr">y</span> = x - y<span class="hljs-comment">;</span><br><span class="hljs-attr">x</span> = x - y<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>方法二： 采用异或运算 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = x ^ y<span class="hljs-comment">;</span><br><span class="hljs-attr">y</span> = x ^ y<span class="hljs-comment">;</span><br><span class="hljs-attr">x</span> = x ^ y<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>叠砖块问题</p><ul><li>要保证第二块及以上所有砖的“重心和”落在第一块砖内<br> 这题要分情况讨论：</li><li>如果每块砖伸出的长度可以自由调整， <a href="https://max.book118.com/html/2018/0103/147107237.shtm">参考</a>，可以证明：以1&#x2F;2n的规律无限延伸</li><li>如果每块砖伸出的长度为固定大小，可以证明：最远可伸出1&#x2F;2n</li></ul></li><li><p>“叠砖块问题”的启发</p><ul><li>面试时要大胆的说出自己的直觉，并且额外补充说明：需要进一步的分析与证明</li></ul></li><li><p>有符号数溢出问题</p><ul><li>要注意负数以补码的形式存储：绝对值的反码+1</li><li>unsigned char 和 signed char表示的数据范围是不一样的</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aarch64-linux-内存管理（二）</title>
    <link href="/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://blog.csdn.net/yhb1047818384/article/details/109169979">Linux内存管理(四)：paging_init分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>aarch64-linux-内存管理（一）</title>
    <link href="/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ol><li><a href="https://blog.csdn.net/yhb1047818384/category_10345494.html">Linux内存管理-专栏</a></li><li><a href="http://www.wowotech.net/memory_management/memory_model.html">Linux内存模型</a></li><li><a href="https://www.cnblogs.com/liuhailong0112/p/14465697.html">arm64架构linux内核地址转换__pa(x)与__va(x)分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3Mjg2NDQ0NA==&mid=2247485533&idx=1&sn=bf4dc798fc2cbbe0b55dcd0f5360d933&chksm=cee9878ef99e0e98628bd41f0a733f47d955e470d26840d0f07cc5aa7c9f789e746133c39c82&scene=178&cur_album_id=2707075920913924097#rd">底层开发必知的三个内存结构概念</a></li></ol><h2 id="内存硬件结构"><a href="#内存硬件结构" class="headerlink" title="内存硬件结构"></a>内存硬件结构</h2><p>Linux 把物理内存划分为三个层次来管理: 存储节点(Node)、内存管理区(Zone)和页面(Page)</p><ul><li>Node -&gt; struct pglist_data，包含的重要信息有<ul><li>该 Node 包含的Zone数目</li><li>该node中内存的起始页帧号</li><li>该node地址范围内的实际管理的页面数量</li><li>该node地址范围内的所有页面数量，包括空洞的页面</li><li>ZONE_PADDING宏：让前后的成员分布在不同的cache line中, 以空间换取时间</li></ul></li><li>Zone -&gt; struct Zone<ul><li>将node拆分成zone主要还是出于Linux为了兼容各种架构和平台，对不同区域的内存需要采用不同的管理方式和映射方式；32位系统中，内核和用户地址空间按1:3划分，内核地址空间只有1GB，所以不能把1GB以上的内存直接映射到内核地址空间，因此就把不能直接映射的内存划分到了高端内存区</li><li>ZONE_DMA: 只适用于Intel x86架构，ARM架构没有这个区域，用于ISA设备的DMA操作，物理地址范围为0-16MB</li><li>ZONE_DMA32: 在64位的系统上使用32位地址寻址的适合DMA操作的内存区。例如在AMD64系统上，该区域为低4GB的空间。在32位系统上，本区域通常是空的</li><li>ZONE_NORMAL: 指的是<u>可以直接映射到内核空间的内存</u>。也常称为“普通区域”“直接映射区域”“线性映射区域”。所谓线性映射就是物理地址和映射后的虚拟地址存在一种简单的关系，即虚拟地址&#x3D;物理地址+固定偏移。在32位系统上，内核空间和用户空间按1:3划分，那么这个固定偏移就是：<code>0xC0000000</code> - 物理内存起始地址。因此可以看到：在32位系统中，将物理内存地址的低1G[物理内存起始地址(start): start+1G]映射到内核空间[0xc0000000:0xffffffff]</li><li>ZONE_HIGHMEM: 高端内存区，32位时代的产物。在32位系统上，指的是高于<code>896M</code>的物理内存。32位系统中，内核和用户地址空间按1:3划分，内核地址空间只有1GB，所以不能把1GB以上的内存直接映射到内核地址空间，因此就把不能直接映射的内存划分到了高端内存区。要将高于896MB的物理内存映射在内核空间的话，需要通过单独的映射来完成，并且这类映射不能保证物理地址和虚拟地址之间存在固定的对应关系（例如ZONE_NORMAL的固定偏移）<blockquote><p>64位系统中没有这个区域，即没有高端内存。因为64系统的内核虚拟地址空间非常大，不再需要高端内存区域</p></blockquote></li><li>指向所属的Node节点</li><li>空闲内存链表，用于实现伙伴系统</li></ul></li><li>Page -&gt; struct page<ul><li>Linux内核使用page结构体来描述一个物理页面，每一个page frame有一个一一对应的page数据结构，系统中定义了page_to_pfn和pfn_to_page的宏用来在page frame number和page数据结构之间进行转换，具体如何转换是和<a href="http://www.wowotech.net/memory_management/memory_model.html">memory modle</a>相关</li><li>PFN是page frame number的缩写，所谓page frame，就是针对物理内存而言的，把物理内存分成一个个的page size的区域，并且给每一个page 编号，这个号码就是PFN。假设物理内存从0地址开始，那么PFN等于0的那个页帧就是0地址（物理地址）开始的那个page。假设物理内存从x地址开始，那么第一个页帧号码就是（x&gt;&gt;PAGE_SHIFT）</li></ul></li><li>区分系统物理地址空间 VS 内存占据的物理地址空间<ul><li>整个系统的物理地址空间并不是都用于内存，有些也属于I&#x2F;O空间（当然，有些cpu arch有自己独立的io address space）。因此，内存所占据的物理地址空间应该是一个有限的区间，不可能覆盖整个物理地址空间</li></ul></li></ul><ol><li>UMA 与 NUMA<ul><li>UMA: Uniform Memory Access，统一内存访问，每个CPU共享相同的内存地址空间</li><li>NUMA: Non-Uniform Memory Access，非统一内存访问。系统中会有很多的内存节点和多个CPU簇， 所有节点中的CPU可以访问全部的物理内存，但是CPU访问本地的节点速度远快于访问远端的内存节点的速度</li></ul></li></ol><h2 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h2><p>主要问题有：</p><ol><li><p>内核如何知道系统的物理内存信息？</p><ul><li>DTB 方式，物理内存信息会写到DTB image中，内核在启动初期对DTB进行解析，得到物理内存信息</li><li>ACPI 方式，会在BIOS中写入物理内存信息</li></ul></li><li><p>内核启动初期有一部分汇编编写的位置无关码，它们主要做了什么事情？</p><ul><li>内核绝大部分的代码都不是位置无关码，且其运行时地址基本为虚拟地址，因此在执行到内核主体部分代码时，需要开启MMU，启动虚拟化。开启虚拟化就需要提供页表</li><li>因此，在进入start_kernel()之前的初始阶段汇编代码会进行两个页表映射：<ul><li><code>identity mapping</code>：VA和PA相等的一段映射，主要目的就是为了打开MMU。<u>在打开mmu之前，cpu访问的都是物理地址，打开mmu访问的就是虚拟地址</u>，其实真正打开mmu的操作就是往某个system register的某个bit写1， 如果在开启mmu之前已经下发了某一个数据的操作指令，本来它是想访问物理地址的，结果mmu打开导致访问了虚拟地址，这样会造成混乱。 所以为了解决这一个情况，引入了identity mapping。VA &#x3D; PA， 打开mmu前后，无论访问物理地址还是虚拟地址，都是对应同一段物理内存</li><li><code>kernel image mapping</code>：内核镜像映射，主要目的是为了执行内核代码。打开了MMU后，内核需要运行起来，就需要将kernel运行需要的地址（kernel txt、rodata、data、bss等等）进行映射。映射到的虚拟地址为：内核编译时指定（计算出）的虚拟地址（<em><strong>存疑❓</strong></em>）</li></ul></li></ul></li></ol><p><code>idmap_pg_dir</code>是identity mapping用到的页表，<code>init_pg_dir</code>是kernel_image_mapping用到的页表。这两个页表定义在arch&#x2F;arm64&#x2F;kernel&#x2F;vmlinux.lds.S中，同样定义在该文件中的还有另外三个页表<code>reserved_ttbr0</code>，<code>tramp_pg_dir</code>， <code>swapper_pg_dir</code>。</p><ul><li>reserved_ttbr0：是内核访问用户空间需要用的页表。</li><li>tramp_pg_dir：适用于映射kaslr的内核区域</li><li><u>swapper_pg_dir</u>：在内核启动期间进行常规映射后，用作内核页表。（在4.20的内核之前其实是没有init_pg_dir这个概念的，arm64&#x2F;mm: Separate boot-time page tables from swapper_pg_dir添加了启动时pgd的init_pg_dir）这几个页表的位置、大小在内核链接文件中都有定义。</li><li>使用init_pg_dir，是因为处理FDT的内核代码，后续的内核代码比较大；但是物理内存还没有扫描完成，进行不了最终swapper页表的建立</li></ul><ol start="3"><li><p>初期的kernel image mapping （init_pg_dir）是如何进行（初始化这个页表）的？</p><ul><li>Linux代码如下 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Map the kernel image (starting with PHYS_OFFSET).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x0</span>, init_pg_dir<br><span class="hljs-symbol">mov_q</span>   <span class="hljs-built_in">x5</span>, KIMAGE_VADDR + TEXT_OFFSET   <span class="hljs-comment">// compile time __va(_text)</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x23</span>           <span class="hljs-comment">// add KASLR displacement</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">x4</span>, PTRS_PER_PGD<br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x6</span>, _<span class="hljs-meta">end</span>           <span class="hljs-comment">// runtime __pa(_end)</span><br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x3</span>, _text          <span class="hljs-comment">// runtime __pa(_text)</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x3</span>            <span class="hljs-comment">// _end - _text</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x5</span>            <span class="hljs-comment">// runtime __va(_end)</span><br> <br><span class="hljs-symbol">map_memory</span> <span class="hljs-built_in">x0</span>, <span class="hljs-built_in">x1</span>, <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x7</span>, <span class="hljs-built_in">x3</span>, <span class="hljs-built_in">x4</span>, <span class="hljs-built_in">x10</span>, <span class="hljs-built_in">x11</span>, <span class="hljs-built_in">x12</span>, <span class="hljs-built_in">x13</span>, <span class="hljs-built_in">x14</span><br></code></pre></td></tr></table></figure> ❗️ KIMAGE_VARDDR 即为内核映像的虚拟空间开始地址。这个值也是在编译时指定的【或者可以计算出的】<br> ❗️ TEXT_OFFSET 即为内核代码段相对于内核虚拟地址起始位置的偏移<br> ❗️ <font color=#DC143C>adrp 指令用于获取标号的运行时物理地址【借助运行当前指令时的PC值】</font></li><li><a href="https://stackoverflow.com/questions/51763634/why-physical-address-of-aarch64-kernel-image-is-nonnegative">TEXT_OFFSET</a> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-keyword">in</span> file <span class="hljs-regexp">/arch/</span>arm64<span class="hljs-regexp">/kernel/</span>vmlinux.lds.S<br>. = KIMAGE_VADDR + TEXT_OFFSET; <br>.head.text : &#123;                          <br>_text = .;<br>HEAD_TEXT<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p> 这里，TEXT_OFFSET是一个随机值，因此每次编译时，内核代码的偏移都不是固定的（出于安全的考虑）。最新Linux代码中已经不使用TEXT_OFFSET了。虚拟地址随机化完全依赖于kaslr_offset。init_pg_dir页表的初始化过程也稍有变化：__primary_switch -&gt; __pi_early_map_kernel()[这个函数似乎就是：early_map_kerne()]<br> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs armasm">   . = KIMAGE_VADDR<span class="hljs-comment">;</span><br><br><span class="hljs-symbol">.head.text</span> : &#123;<br>_text = .<span class="hljs-comment">;</span><br>HEAD_TEXT<br>&#125;<br><span class="hljs-symbol">.text</span> : <span class="hljs-meta">ALIGN</span>(SEGMENT_ALIGN) &#123;<span class="hljs-comment">/* Real text segment*/</span><br>_stext = .<span class="hljs-comment">;  </span><br>       ......<br>   &#125;<br>   <br>   <span class="hljs-comment">// in /arch/arm64/kernel/head.S  </span><br><br>   SYM_FUNC_START_LOCAL(__primary_switch)<br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x1</span>, reserved_pg_dir<br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x2</span>, init_idmap_pg_dir<br><span class="hljs-keyword">bl</span>__enable_mmu<br><br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x1</span>, early_init_stack<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">sp</span>, <span class="hljs-built_in">x1</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x29</span>, xzr<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x0</span>, <span class="hljs-built_in">x20</span><span class="hljs-comment">// pass the full boot status</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x1</span>, <span class="hljs-built_in">x21</span><span class="hljs-comment">// pass the FDT</span><br><span class="hljs-keyword">bl</span>__pi_early_map_kernel<span class="hljs-comment">// Map and relocate the kernel</span><br><br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">x8</span>, <span class="hljs-symbol">=__primary_switched</span><br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x0</span>, KERNEL_START<span class="hljs-comment">// __pa(KERNEL_START)</span><br><span class="hljs-keyword">br</span><span class="hljs-built_in">x8</span><br>   SYM_FUNC_END(__primary_switch)<br></code></pre></td></tr></table></figure></p><p> 可以看到，在初始化init_pg_dir时，mmu已经开启了。需要注意：</p><ul><li>❗️<code>bl __pi_early_map_kernel</code>: BL: Branch with Link branches to a PC-relative offset</li><li>❗️<code>br x8</code>: “Adding an L to the B or BR instructions turns them into a branch with link. This means that a<br> return address is written into LR (X30) as part of the branch.” 可以看出B，BR是两个不同的指令。</li><li>❗️ 因此，<code>br x8</code>将__primary_switched标号的虚拟地址赋给PC，从前面的链接文件可以看到，其虚拟地址处于KIMAGE_VADDR开始之后的位置。因此，之后Linux内核将运行于高地址的虚拟内存空间。</li></ul><blockquote><p>[from 《Armv8-A Instruction Set Architecture》]： The unconditional branch instruction B <label> performs a direct, PC-relative, branch to <label>. The offset from the current PC to the destination is encoded within the instruction. The range is limited by the space available within the instruction to record the offset and is +&#x2F;- 128MB. When you use BR <Xn>, BR performs an indirect, or absolute, branch to the address specified in Xn.</p></blockquote> <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// in file /arch/arm64/kernel/pi/map_kernel.c<br><br>asmlinkage void __init early_map_kernel(u64 boot_status, void *fdt)<br>&#123;<br>    u64 v<span class="hljs-built_in">a_base</span>, p<span class="hljs-built_in">a_base</span> = (u64)&amp;_text<span class="hljs-comment">;</span><br>    u64 kaslr_offset = p<span class="hljs-built_in">a_base</span> % MIN_KIMG_ALIGN<span class="hljs-comment">;</span><br><br>    map_fdt((u64)fdt)<span class="hljs-comment">;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * The virtual KASLR displacement modulo 2MiB is decided by the</span><br><span class="hljs-comment">    * physical placement of the image, as otherwise, we might not be able</span><br><span class="hljs-comment">    * to create the early kernel mapping using 2 MiB block descriptors. So</span><br><span class="hljs-comment">    * take the low bits of the KASLR offset from the physical address, and</span><br><span class="hljs-comment">    * fill in the high bits from the seed.</span><br><span class="hljs-comment">    */</span><br>    if (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) &#123;<br>        u64 kaslr_seed = kaslr_early_init(fdt, chosen)<span class="hljs-comment">;</span><br><br>        if (kaslr_seed &amp;&amp; kaslr_requires_kpti())<br>            arm64_use_ng_mappings = <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br><br>        kaslr_offset |= kaslr_seed &amp; ~(MIN_KIMG_ALIGN - <span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>    &#125;<br><br>    if (IS_ENABLED(CONFIG_ARM64_LPA2) &amp;&amp; v<span class="hljs-built_in">a_bits</span> &gt; V<span class="hljs-built_in">A_BITS</span>_MIN)<br>        remap_idmap_for_lpa2()<span class="hljs-comment">;</span><br><br>    v<span class="hljs-built_in">a_base</span> = KIMAGE_VADDR + kaslr_offset<span class="hljs-comment">;</span><br>    map_kernel(kaslr_offset, v<span class="hljs-built_in">a_base</span> - p<span class="hljs-built_in">a_base</span>, root_level)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>kaslr_offset:<br> 这里相当于给内核运行时虚拟地址加了一个随机的偏移，因此后续在map_kernel中需要对内核进行重定位。<u>物理地址随机化比较好处理，虚拟地址随机化之后，内核大部分代码都需要重定位</u>。</li></ul></li><li><p>内核如何去解析这些配置信息？</p><ul><li>现在虽然MMU已经打开，kernel image的页表已经建立，但是内核还没有为DTB这段内存创建映射，现在内核还不知道内存的布局，所以内存管理模块还没能初始化。这个时候就需要用到fixmap。即将DTB的物理地址映射到Fixed map中的区域，然后访问该区域中的虚拟地址即可。</li><li>解析DTB获取系统的物理内存信息，并保存到 <em><strong>memblock</strong></em> 结构中，这是一个全局的变量，用于管理内核早期启动阶段过程中的所有物理内存。</li></ul></li></ol><h2 id="顺序记录"><a href="#顺序记录" class="headerlink" title="顺序记录"></a>顺序记录</h2><h3 id="aarch64-内核内存布局"><a href="#aarch64-内核内存布局" class="headerlink" title="aarch64-内核内存布局"></a>aarch64-内核内存布局</h3><ul><li>0-256T -&gt; 用户空间；256-512T -&gt; 内核空间</li></ul><h4 id="fixed-mappings-4124KB"><a href="#fixed-mappings-4124KB" class="headerlink" title="fixed mappings[4124KB]"></a><a href="https://www.cnblogs.com/alantu2018/p/8447570.html">fixed mappings[4124KB]</a></h4><p>固定映射区，这部分的虚拟地址在编译阶段就已经确定。 在内核的启动过程中，有些模块需要使用虚拟内存并mapping到指定的物理地址上。而且，这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，linux kernel固定分配了一些fixmap的虚拟地址，这些地址有固定的用途。使用该地址的模块在初始化的时候，将这些固定分配的地址mapping到指定的物理地址上去，进而可以通过虚拟化访问到需要访问的特定物理内存。<a href="https://www.cnblogs.com/alantu2018/p/8447570.html">参考</a></p><p><em><strong>个人理解</strong></em>：例如在处理DTB时，内核初始部分代码将启动参数给出的DTB物理地址映射到fixed mappings虚拟空间区域，进而在开启虚拟化之后，实现对DTB的解析</p><p><em><strong>fixed address</strong></em>的具体位置，对于aarch64架构，当前内核中这部分对应的虚拟地址范围为<code>[fffffdfffe5f9000, fffffdfffe9fffff]</code>，总共4124KB大小</p><p><em><strong>fixed address</strong></em>又分为两大类：永久映射 &amp; 临时映射</p><ol><li>永久映射：用于具体的某个内核模块，使用关系是永久的。涉及到的模块主要有：</li></ol><ul><li>DTB解析模块：</li><li>early Console 模块：kernel启动阶段初期可以使用的consol，可以用于输出各种调试信息</li><li>动态打补丁的模块：使用fixed address映射具有RW属性的代码段，进而动态修改这部分代码段的部分内容</li></ul><ol start="2"><li>临时映射：各个内核模块都可以使用，用完之后就释放。主要用于early ioremap模块</li></ol><h3 id="aarch64虚拟地址-物理地址"><a href="#aarch64虚拟地址-物理地址" class="headerlink" title="aarch64虚拟地址-&gt;物理地址"></a>aarch64虚拟地址-&gt;物理地址</h3><p>aarch64有两个页表基地址寄存器：</p><ul><li>ttbr0：用户空间页表基地址。启动初期，idmap_pg_dir填入ttbr0。这里将内核代码映射到低虚拟地址空间。</li><li>ttbr1：内核空间页表基地址。启动初期，init_pg_dir填入ttbr1。这个页表将内核代码映射到高虚拟地址空间。</li></ul><p>64bit的虚拟地址并不是所有bit都被用上的。目前有效的VA_BITS的配置是：36, 39, 42, 47。假设我现在使用64K的页和42bit的虚拟地址空间， 使用三级页表。地址转换过程<a href="https://blog.csdn.net/yhb1047818384/article/details/108210044">举例</a>：</p><ol><li>如果VA[63：42] &#x3D; 1, 那么就会使用ttbr1的地址作为一级页表的基地址；如果VA[63:42] &#x3D; 0, 那么就会使用ttbr0的地址作为一级页表的基地址，那么就会使用ttbr0的地址作为一级页表的基地址；</li><li>VA[41:29]放置Level 1页表中的索引，从而找到对应的描述符地址并获取描述符内容，<u>根据描述符中的内容获取Level 2页表基地址</u></li><li>VA[28:16]放置Level 2页表中的索引，从而找到对应的描述符地址并获取描述符内容，根据描述符中的内容获取<u>物理地址的高36位</u>，以4K地址对齐</li><li>VA[15: 0]放置的是物理地址的偏移，结合获取的物理地址高位，最终得到物理地址</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态库vs静态库</title>
    <link href="/2024/06/26/%E5%8A%A8%E6%80%81%E5%BA%93vs%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/2024/06/26/%E5%8A%A8%E6%80%81%E5%BA%93vs%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加减乘除与mod</title>
    <link href="/2024/06/25/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%B8%8Emod/"/>
    <url>/2024/06/25/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%B8%8Emod/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://leetcode.cn/circle/discuss/mDfnkW/">力扣</a></li></ul><h2 id="记录要点"><a href="#记录要点" class="headerlink" title="记录要点"></a>记录要点</h2><h3 id="两个恒等式"><a href="#两个恒等式" class="headerlink" title="两个恒等式"></a>两个恒等式</h3><ul><li><code>(a + b) mod m = [(a mod m) + (b mod m)] mod m</code></li><li><code>(a b) mod m = [(a mod m) (b mod m)] mod m</code></li></ul><h3 id="幂运算与mod"><a href="#幂运算与mod" class="headerlink" title="幂运算与mod"></a>幂运算与mod</h3><ul><li><font color=DC143C>指数不能随便取余</font>，如果指数在 64 位整数的范围内，可以使用<a href="https://leetcode.cn/problems/powx-n/description/">快速幂</a>计算方法<blockquote><p>注：如果指数超出 64 位整数的范围，需要用「欧拉降幂」处理。</p></blockquote></li></ul><h3 id="负数与mod"><a href="#负数与mod" class="headerlink" title="负数与mod"></a>负数与mod</h3><ul><li>如果<code>x</code>是负数，要采用<code>(x mod m + m) mod m</code>的形式，这样不用判断<code>x</code>是否为负数</li></ul><h3 id="除法与mod"><a href="#除法与mod" class="headerlink" title="除法与mod"></a>除法与mod</h3><ul><li>参考上述链接</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码实现时，上面的加减乘除通常这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MOD = <span class="hljs-number">1</span>_000_000_007<br><br><span class="hljs-comment">// 加</span><br>(a + b) % MOD<br><br><span class="hljs-comment">// 减</span><br>(a - b + MOD) % MOD<br><br><span class="hljs-comment">// 取模到 [0,MOD-1] 中，无论正负</span><br>(a % MOD + MOD) % MOD<br><br><span class="hljs-comment">// 乘</span><br>a * b % MOD<br><br><span class="hljs-comment">// 多个数相乘，要步步取模，防止溢出</span><br>a * b % MOD * c % MOD<br><br><span class="hljs-comment">// 除（MOD 是质数且 b 不是 MOD 的倍数）</span><br>a * <span class="hljs-built_in">qpow</span>(b, MOD - <span class="hljs-number">2</span>, MOD) % MOD<br></code></pre></td></tr></table></figure><p>其中 <code>qpow</code> 为快速幂函数。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子数组相关</title>
    <link href="/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">209. 长度最小的子数组</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></p></li></ul><h2 id="对应解答及注意事项"><a href="#对应解答及注意事项" class="headerlink" title="对应解答及注意事项"></a>对应解答及注意事项</h2><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">长度最小的子数组</a></h3><blockquote><ul><li>这个题是滑动窗口的最佳实践！窗口有左右两个边界索引，有点类似于<em><strong>双指针</strong></em>的方法</li><li>官方题解有一个前缀和的做法：<strong>提前算出[0, i]的和，并保存到一个额外的数组中</strong>，接着将题目转化为：<strong>找到两个前缀和，[0, i)，[0, j)<strong>使得这两个前缀和的差 <strong>&gt;&#x3D;</strong> target，记录此时的子数组长度为：</strong>j-i+1</strong>。后续的操作全都转化为了对<em><strong>前缀和数组</strong></em>的查询操作。</li><li></li></ul></blockquote><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h3><blockquote><ul><li>这题可以用<strong>动态规划</strong>的方法</li><li>评论区有提到<strong>前缀和数组</strong>的方法：也是提前算出前缀和，<strong>子数组的和可以转化为两个前缀和的差</strong>。对于前缀和数组来说，题目转化为了<strong>股票购买&#x2F;卖出最佳时机（可以多次持有股票，但手上最多只能有一支股票）</strong></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题心得</title>
    <link href="/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    <url>/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="读题关键字"><a href="#读题关键字" class="headerlink" title="读题关键字"></a>读题关键字</h2><ul><li>注意总结解题模版！！！</li><li>满足条件的最<em><strong>小</strong></em>整数</li><li>涉及到存储长度类似的：[如果最小的不是32位整数，也返回-1]</li></ul><h2 id="常用编程技巧"><a href="#常用编程技巧" class="headerlink" title="常用编程技巧"></a>常用编程技巧</h2><ul><li><p>(long long)(m-1) * (m-2) -&gt; 强制类型转换的优先级高于加减乘除</p></li><li><p>使用程序块为变量赋值，要注意函数块需要使用<font color=#DC143C>()</font>包裹起来：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> sum = (&#123;<br>        <span class="hljs-type">double</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) tmp += nums[j];<br>        tmp;<br>    &#125;);<br></code></pre></td></tr></table></figure></li><li><p>代码行压缩时，如果有多条语句，必须用{}包围起来，如果只有一条语句不用</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;y = <span class="hljs-number">10</span>; z = <span class="hljs-number">100</span>;&#125;<br><span class="hljs-keyword">while</span> (s[i] != <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; i &lt; m) &#123;s[i] -= <span class="hljs-number">1</span>; flag = <span class="hljs-literal">true</span>; i++;&#125;<br><span class="hljs-keyword">while</span>(s[i] == <span class="hljs-string">&#x27;a&#x27;</span>) s[i] -= <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure></li><li><p>在<code>while</code>循环里写额外的for&#x2F;while循环时，一定要记得在内层循环判断越界问题</p></li><li><p>两字符串字典序比较时要注意：循环判断，相等的才会继续，小于或者大于时都会结束判断！！！复习一下这个<a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf">题目</a>，注意提交错误的几个。<strong>可以直接使用string类的&lt;&#x2F;&gt;&#x2F;&gt;&#x3D;运算符，或者compare成员函数进行字典序号的比较</strong></p></li><li><p>体会如何写二叉树的递归：先转化为局部问题，考虑局部root, root-&gt;left, root-&gt;right的递归问题；先不用纠结于前&#x2F;中&#x2F;后的递归顺序，结合这个题目[114.二叉树展开为链表]。</p></li><li><p>判断一个数是否为质数</p><ul><li>daiding</li></ul></li><li><p>计算整数各个位上数字之和：可以先从个位数加起：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfTheDigitsOfHarshadNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = x; v; v /= <span class="hljs-number">10</span>) &#123;<br>        s += v % <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>double, long, int, long long等类型表示的数据范围</p><ul><li>double是双精度浮点型，可以表示小数，在64位系统上占8Bytes。采用的数据表示方法和另外几种数据类型不同，能表示的数据范围是最大的。此外还有float[单精度浮点型], long double[精确度更高]</li><li>其余都是整数类型</li><li>浮点型，牺牲了表示精度，但是增大了数据表示范围</li><li>参考题目：<a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a></li></ul></li></ul><h2 id="个别题目复习"><a href="#个别题目复习" class="headerlink" title="个别题目复习"></a>个别题目复习</h2><ul><li><p>数的前&#x2F;中&#x2F;后遍历的迭代方法要熟悉</p></li><li><p>找数字规律的题目，先找到“主干规律”，再找次要规律，结合题目[6. Z字型变换]</p></li><li><p><em><strong>二叉树层序遍历</strong></em>不一定非得用queue，也可以用vector实现一些重复遍历的操作，结合[2641.]</p></li></ul><h2 id="常用数据结构及其方法"><a href="#常用数据结构及其方法" class="headerlink" title="常用数据结构及其方法"></a>常用数据结构及其方法</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul><li>erase()</li><li>rbegin() -&gt; 最右侧的那个节点</li><li>rend() -&gt; 第一个节点前面，不在vector中</li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>&lt;string&gt;</li><li>substr(start, len) ❗️ 注意这个方法的第二个参数为<u>长度</u></li><li>operator &gt; &#x2F; &lt;   -&gt;  string 类重载了这两个运算符，可以直接用于字典序的比较</li><li>compare(const string&amp; str)，返回值如下：<ul><li>0, equal</li><li>-1, lf &lt; rf</li><li>1, lf &gt; rf</li></ul></li><li>erase(start_idx, len)   -&gt; 利用索引和长度删除指定范围的字符</li><li>erase(iterator start, iterator end)  -&gt; 利用迭代器删除指定范围内的字符，[start, end)</li></ul><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><ul><li>&lt;stcak&gt;</li><li>push()</li><li>pop() -&gt; 注意返回值为 void，因此取元素只能用top()方法 ❗️</li><li>top()</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><ul><li>&lt;queue&gt;</li><li>push()</li><li>pop() ❗️ -&gt; 注意返回值为 void，因此取元素只能用front()方法</li><li>top() ❌ -&gt; 没有这个方法，要使用front()</li><li>front() -&gt; 查看队列头部的元素[先插入的]</li><li>back() -&gt; 查看队列尾部的元素[后插入的]</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li>&lt;mao&gt;</li><li>erase() -&gt; 参数可以为 <strong>iterator</strong>，<strong>key</strong>；也可以为范围参数’[first it, last it)’</li><li>大 -&gt; 小排列 <code>map&lt;int, multiset&lt;int&gt;, std::greater&lt;int&gt;&gt;</code></li><li>定义map型对象时，如何自定义key比较函数：注意只能定义key的比较函数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp_key</span><br>&#123;<br>    <span class="hljs-comment">// 注意，函数的参数需要于map的key的参数类型相同</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">key_t</span> &amp;k1, <span class="hljs-type">const</span> <span class="hljs-type">key_t</span> &amp;k2)</span><span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(k1.dwBussID != k2.dwBussID)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwBussID &lt; k2.dwBussID;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(k1.dwVersion != k2.dwVersion)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwVersion &lt; k2.dwVersion;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k1.dwHashUrl != k2.dwHashUrl)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwHashUrl &lt; k2.dwHashUrl;<br>        &#125;<br>　　　　　　　　  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用库函数运算"><a href="#常用库函数运算" class="headerlink" title="常用库函数运算"></a>常用库函数运算</h2><h3 id="lower-bound-iterator-start-iterator-end-value"><a href="#lower-bound-iterator-start-iterator-end-value" class="headerlink" title="lower_bound(iterator_start, iterator_end, value) -&gt;"></a>lower_bound(iterator_start, iterator_end, value) -&gt;</h3><ul><li>返回第一个迭代器it，其值<strong>不满足</strong> <code>(*it) &lt; value</code></li><li>即找到第一个迭代器，其值<strong>满足</strong> <code>value &lt;= (*it)</code></li><li>参数可以为&amp;arr[i]，返回值也为该类型，<a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/submissions/545900287/">参考</a></li></ul><h3 id="upper-bound-start-end-value"><a href="#upper-bound-start-end-value" class="headerlink" title="upper_bound(start, end, value) -&gt;"></a>upper_bound(start, end, value) -&gt;</h3><ul><li>返回第一个迭代器，其值<strong>满足</strong> <code>value &lt; (*it)</code></li></ul><h3 id="atan2-double"><a href="#atan2-double" class="headerlink" title="atan2() -&gt; double"></a>atan2() -&gt; double</h3><ul><li>求坐标(x, y)到x轴的极角，范围为[-pi, pi]。这里要注意坐标上的点在-x轴上时，其极角可能为-pi，也可能为pi，但只能为一个值<ul><li><a href="https://leetcode.cn/problems/maximum-number-of-visible-points/description/">1610. 可见点的最大数目</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/monotonous-stack/">单调栈</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>弹出时只能从栈顶[st.top()]弹出</li><li>从栈顶到栈底，元素大小呈某种单调趋势</li><li>当欲压入栈的元素不满足这个单调性时，就要把不满足单调性的所有[栈顶]元素弹出 -&gt; 这个性质用到的比较多</li><li>配合数组使用时，栈内可以存储对应元素的下标，而不是元素值</li></ul><h2 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h2><ul><li>使用时要注意考虑单调顺序：1️⃣递增，2️⃣递减</li><li>要搞清楚单调栈中记录元素的意义：例如题—[503]，单调栈中记录的是还没有找到下一个更大值的<em><strong>下标</strong></em>, 只要遍历到比栈顶元素值更大的数，就意味着栈顶元素找到了答案，记录答案，然后从栈顶弹出</li><li>一定要注意单调栈里存储的是<em><strong>索引</strong></em>还是<em><strong>元素值</strong></em></li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素2</a></li><li><a href="https://leetcode.cn/problems/next-greater-element-iii/description/">556.下一个更大元素3</a>: 变形题，比较有意思！！！</li></ul><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><ul><li>[556] 一定要注意题目的条件 -&gt; <ul><li>满足条件的最小整数</li><li>如果最小的不是32位整数，也返回-1</li></ul></li></ul><h2 id="扩展-循环数组"><a href="#扩展-循环数组" class="headerlink" title="扩展-循环数组"></a>扩展-循环数组</h2><ul><li>处理方式1：将[0:n-1]个个数顺序拷贝到第n个数后面，构成一个普通数组</li><li>处理方式2：遍历[0:2n-1)次，取元素时对下标取模</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li><li><a href="https://writings.sh/post/union-find">并查集简记</a></li></ul><h2 id="Leetcode-题目"><a href="#Leetcode-题目" class="headerlink" title="Leetcode 题目"></a>Leetcode 题目</h2><ul><li><a href="https://leetcode.cn/problems/smallest-string-with-swaps/description/">1202.交换字符串中的元素</a></li></ul><h2 id="对应题解"><a href="#对应题解" class="headerlink" title="对应题解"></a>对应题解</h2><ul><li>1202 [from Andy at Leetcode]<blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> father[<span class="hljs-number">100010</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//并查集find</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x==father[x]?x:(father[x] = <span class="hljs-built_in">find</span>(father[x]));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//并查集merge</span></span><br><span class="hljs-function">    </span>&#123;<br>        father[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">smallestStringWithSwaps</span><span class="hljs-params">(string s, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        string areastr[<span class="hljs-number">100010</span>]; <span class="hljs-comment">//areastr[x]含义为并查集里所有father==x的结点集合</span><br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">100010</span>] =&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//cnt[x]含义为areastr[x]内的第一个未分配元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) father[i] = i;<span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: pairs) <span class="hljs-built_in">merge</span>(i[<span class="hljs-number">1</span>], i[<span class="hljs-number">0</span>]);<span class="hljs-comment">//merge连通结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            areastr[<span class="hljs-built_in">find</span>(i)]+=s[i];<span class="hljs-comment">//将s[i]添加到连通结点集合内</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            <span class="hljs-built_in">sort</span>(areastr[i].<span class="hljs-built_in">begin</span>(),areastr[i].<span class="hljs-built_in">end</span>());<span class="hljs-comment">//对每个连通图内容排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            s[i] = areastr[father[i]][cnt[<span class="hljs-built_in">find</span>(i)]++];<span class="hljs-comment">//根据连通图内排序后结果还原字符串</span><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDS回环-吞吐量测试记录</title>
    <link href="/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LW-DDS"><a href="#LW-DDS" class="headerlink" title="LW DDS"></a>LW DDS</h2><ul><li>240607-可以用于毕业小实验数据采集</li><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="Cyclone-DDS"><a href="#Cyclone-DDS" class="headerlink" title="Cyclone DDS"></a>Cyclone DDS</h2><ul><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="RTI-DDS"><a href="#RTI-DDS" class="headerlink" title="RTI DDS"></a>RTI DDS</h2><p>- </p><h2 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h2><ul><li>Cyclone 和 Fast[2.12.0]都定义了0x8007这个PID，但是含义不一样，因此Fast在接收到Cyclone的data(p)报文，进行处理时出错，不会创建参与者代理，因此匹配不了</li><li>FastDDS调试时常用的断点：<ul><li>on_new_cache_change_added() [“Ignore announcement from own RTPSParticipant”] at file: PDPListener.cpp -&gt; 用于处理data(p)报文</li><li>EDPSimplePUBListener::on_new_cache_change_added() at file: EDPSimpleListeners.cpp -&gt; 用于处理data(w)报文</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回文串性质</title>
    <link href="/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/"/>
    <url>/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="参考题目"><a href="#参考题目" class="headerlink" title="参考题目"></a>参考题目</h2><ul><li><a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/">2663. 字典序最小的美丽字符串</a></li><li><a href="https://leetcode.cn/problems/find-palindrome-with-fixed-length/description/">2217. 找到指定长度的回文数</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>aa，aba，很明显，最小模式的回文串只有这两种模式</li><li>对于长度为 m (m &gt; 3) 的回文串，其必包含长度为 m-2 的回文串</li><li>因此，“不包含任何长度为2或更长的回文串” &lt;&#x3D;&#x3D;&gt; “不包含长度为2或3的回文串”</li><li>当用[0-9]的数字来组成回文串，则其长度为n的回文串按大小排序时，有明显的规律</li><li>要注意：回文串是有<em><strong>对称性</strong></em>的，因此长度为n的回文串（由数字组成时），可以由其前(n+1)&#x2F;2个整数部分唯一确定，因为后续的数字与前面的数字成镜像对称</li><li>回文串的<strong>中间部分</strong>一定是由连续且相同的字符串组成：<code>aba</code>, <code>abccba</code>, <code>tartattatrat</code></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>如果题目中“不包含任何长度为2或更长” 改为-&gt; “不包含任何长度为3&#x2F;4&#x2F;5&#x2F;m或更长”，该怎么做？</li></ul><h2 id="基础：回文串的判别"><a href="#基础：回文串的判别" class="headerlink" title="基础：回文串的判别"></a>基础：回文串的判别</h2><ul><li>可以根据对称性进行回文串的判断<ol><li>区分长度的奇偶性，找到双指针i，j</li><li>i–，j++分别判断s[i] &#x3D;&#x3D; s[j]是否成立</li><li>要注意：如果字串长度为奇数，则只能为<code>aba</code>类型；但是当字串长度为偶数是，可以为<code>aa</code>，也可以为<code>abaaba</code></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/22/hello-world/"/>
    <url>/2024/06/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
