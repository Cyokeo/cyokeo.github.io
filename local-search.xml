<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动规题单</title>
    <link href="/2024/07/07/%E5%8A%A8%E8%A7%84%E9%A2%98%E5%8D%95/"/>
    <url>/2024/07/07/%E5%8A%A8%E8%A7%84%E9%A2%98%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="我的动态规划题单"><a href="#我的动态规划题单" class="headerlink" title="我的动态规划题单"></a>我的动态规划题单</h2><p>动态规划有两个难点：</p><ul><li>不知道是否应该使用动态规划</li><li>动态规划的递推推导不出来</li></ul><h2 id="递推关系不太难想的，一般都很难想到使用动态规划的方法"><a href="#递推关系不太难想的，一般都很难想到使用动态规划的方法" class="headerlink" title="递推关系不太难想的，一般都很难想到使用动态规划的方法"></a>递推关系不太难想的，一般都很难想到使用<u>动态规划</u>的方法</h2><ul><li><a href="https://leetcode.cn/problems/wildcard-matching/description/">44. 通配符匹配</a><ul><li>这个题目有个点：‘<em>’是万能的，连续的‘</em>’和一个‘*’是一样的</li></ul></li><li>[10. 正则表达式匹配]</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c/cpp小技巧</title>
    <link href="/2024/07/06/c-cpp%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/07/06/c-cpp%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="如何计算负数的补码"><a href="#如何计算负数的补码" class="headerlink" title="如何计算负数的补码"></a>如何计算负数的补码</h2><ul><li>负数一般以补码的形式存储</li><li>如果位数为(8), 则负数a的补码为<code>pow(2,n) - abs(a)</code></li><li>另外，负数a的补码也可根据：abs(a)的反码 + 1 得到</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2024/07/06/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/06/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/575568/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86">leetcode 宫水三叶</a></li><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/2600821/kan-bu-dong-ni-da-wo-kmp-suan-fa-chao-qi-z1y0">从next数组的求解解读KMP算法</a></li><li><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF">还是carl的好理解一些</a></li></ul><h2 id="解决场景"><a href="#解决场景" class="headerlink" title="解决场景"></a>解决场景</h2><ul><li>如何快速在「原字符串」中找到「匹配字符串」</li><li>时间复杂度：O(m + n)，其中m，n分别为原字符串，待匹配字符串的长度</li><li>其能在「非完全匹配」的过程中提取到有效信息进行复用，以减少「重复匹配」的消耗。</li></ul><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ul><li>next数组是模式串的相同最长前后缀长度表</li><li>next[j]表示模式串中，字串[0, j-1]的相同最长前后缀的长度</li><li>“a”，“”，“abc”的最长前后缀长度均为0；“aabcaa”的最长相同前后缀的长度为2</li><li>当主串的第i个位置和模式串的第j个位置不相同时，模式串的匹配只需<strong>回退</strong>到 j’ &#x3D; next[j]的下一个位置。因为可以保证：<code>模式串的前j&#39;个字符[0, j&#39;]与主串第i个位置前的j&#39;个字符是相同的</code></li></ul><h2 id="如何求模式串的next数组"><a href="#如何求模式串的next数组" class="headerlink" title="如何求模式串的next数组"></a>如何求模式串的next数组</h2><ul><li><p>“abcabd”</p></li><li><p>“abacabad”：</p>  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="language-ruby">&gt; <span class="hljs-symbol">b:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> 所在的位置与b不同；由于<span class="hljs-keyword">next</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>，所以<span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">2</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">c:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span> 所在的位置与c不同；<span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> 所在的位置与c不同；因此<span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">b:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span> 所在的位置与b相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] = <span class="hljs-number">2</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">3</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">d:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>] = <span class="hljs-number">3</span> 所在的位置与d不同；<span class="hljs-keyword">next</span>[<span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>]] = <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>；因此<span class="hljs-keyword">next</span>[<span class="hljs-number">7</span>] = <span class="hljs-number">0</span>;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="字符串哈希（https-leetcode-cn-problems-shortest-palindrome-solutions-1396220-by-flix-be4y"><a href="#字符串哈希（https-leetcode-cn-problems-shortest-palindrome-solutions-1396220-by-flix-be4y" class="headerlink" title="字符串哈希（https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y)"></a>字符串哈希（<a href="https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y">https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y</a>)</h2><ul><li>构造next数组的算法：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = tmp.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-type">int</span> k = i<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; tmp[next[k]] != tmp[i]) &#123;k = next[k]<span class="hljs-number">-1</span>;&#125;<br>    <span class="hljs-keyword">if</span> (k &gt;= <span class="hljs-number">0</span>) next[i] = next[k] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> next[i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h2><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></li><li><a href="https://leetcode.cn/problems/shortest-palindrome/solutions/392561/zui-duan-hui-wen-chuan-by-leetcode-solution/">214. 最短回文串</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题目复习</title>
    <link href="/2024/07/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/07/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li><p>904.水果成篮，结合<a href="https://leetcode.cn/problems/fruit-into-baskets/solutions/1437444/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr">题解</a>，深入理解：</p><ul><li>最大滑动窗口 - 模版  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(nums):<br>    // 判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> 不满足条件：<br>        i += <span class="hljs-number">1</span> //（最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）<br>    // 不断更新结果（注意在<span class="hljs-keyword">while</span>外更新！）<br>    j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>最小滑动窗口 - 模版  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(nums):<br>    // 判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> 满足条件：<br>        // 不断更新结果(注意在<span class="hljs-keyword">while</span>内更新！)<br>        i += <span class="hljs-number">1</span> //（最大程度的压缩i，使得滑窗尽可能的小）<br>    j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>确实，有了模版后，遇到滑窗问题，思路更加<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/submissions/544105543/">清晰了</a></li></ul></li><li><p>字符串哈希：使用hash映射，减小索引的存储消耗！！！<a href="https://leetcode.cn/problems/repeated-dna-sequences/solutions/1035568/zhong-fu-de-dnaxu-lie-by-leetcode-soluti-z8zn">参考</a></p><ul><li>选取一个大于字符集大小的质数作为base</li><li>将字符映射为小于base的数：map()</li><li>‘abccd’ -&gt; map(a)*base^0 + map(b)*base^1 + map(c)*base^2 + map(c)*base^3 + map(d)*base^4</li><li><a href="https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y">参考</a></li></ul></li><li><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solutions/2551432/liang-chong-fang-fa-ni-xiang-si-wei-zhen-e3gb">最大&#x2F;小子序和</a></p><ul><li>通过取相反数，将最小子序和转化为最大字序和问题</li><li>前缀和 法</li><li>贪心 + dp 法  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cardPoints)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> maxSubArray = [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>            <span class="hljs-comment">//实现1：前缀和</span><br>            <span class="hljs-comment">// int res = INT_MIN, pre_sum = 0, min_pre_sum = 0;</span><br>            <span class="hljs-comment">// for (auto&amp; x : nums) &#123;</span><br>            <span class="hljs-comment">//     pre_sum += x;</span><br>            <span class="hljs-comment">//     res = max(res, pre_sum - min_pre_sum);</span><br>            <span class="hljs-comment">//     min_pre_sum = min(min_pre_sum, pre_sum);</span><br>            <span class="hljs-comment">// &#125;</span><br>            <span class="hljs-comment">// return res;</span><br><br>            <span class="hljs-comment">//实现2：贪心 + dp</span><br>            <span class="hljs-comment">//s = 0考虑了k = 0时的情况</span><br>            <span class="hljs-type">int</span> res = INT_MIN, s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : nums) &#123;<br>                <span class="hljs-keyword">if</span> (s &lt;= <span class="hljs-number">0</span>) s = <span class="hljs-number">0</span>;<br>                s += x;<br>                res = <span class="hljs-built_in">max</span>(res, s);<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-comment">//累加总和为s</span><br>        <span class="hljs-type">int</span> s = <span class="hljs-built_in">accumulate</span>(cardPoints.<span class="hljs-built_in">begin</span>(), cardPoints.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//将数组的每个元素乘以-1, 用来求连续子数组的最大和</span><br>        <span class="hljs-built_in">transform</span>(cardPoints.<span class="hljs-built_in">begin</span>(), cardPoints.<span class="hljs-built_in">end</span>(), cardPoints.<span class="hljs-built_in">begin</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> -x; &#125;);<br>        <span class="hljs-comment">//答案 = 总和 - 连续子数组的最小和</span><br>        <span class="hljs-keyword">return</span> s - (-<span class="hljs-built_in">maxSubArray</span>(cardPoints));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h2><ul><li><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文字串</a><ul><li>加深理解：如果字串长度为奇数，则只能为<code>aba</code>类型；但是当字串长度为偶数是，可以为<code>aa</code>，也可以为<code>abaaba</code></li><li>自己想到了使用dp数组，记忆化遍历，以减小重复遍历。但是时间表现还是很差❗️❗️</li><li>注意到回文串的中间部分一定是由连续且相同的字符串组成，因此可以定位到中间字符，再左右扩展查询，<a href="https://leetcode.cn/problems/longest-palindromic-substring/description/comments/59461">参考</a>❗️  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><span class="hljs-comment">//         保存起始位置，测试了用数组似乎能比全局变量稍快一点</span><br>        <span class="hljs-type">int</span>[] range = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">char</span>[] str = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><span class="hljs-comment">//             把回文看成中间的部分全是同一字符，左右部分相对称</span><br><span class="hljs-comment">//             找到下一个与当前字符不同的字符</span><br>            i = findLongest(str, i, range);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(range[<span class="hljs-number">0</span>], range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLongest</span><span class="hljs-params">(<span class="hljs-type">char</span>[] str, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span>[] range)</span> &#123;<br><span class="hljs-comment">//         查找中间部分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">while</span> (high &lt; str.length - <span class="hljs-number">1</span> &amp;&amp; str[high + <span class="hljs-number">1</span>] == str[low]) &#123;<br>            high++;<br>        &#125;<br><span class="hljs-comment">//         定位中间部分的最后一个字符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> high;<br><span class="hljs-comment">//         从中间向左右扩散</span><br>        <span class="hljs-keyword">while</span> (low &gt; <span class="hljs-number">0</span> &amp;&amp; high &lt; str.length - <span class="hljs-number">1</span> &amp;&amp; str[low - <span class="hljs-number">1</span>] == str[high + <span class="hljs-number">1</span>]) &#123;<br>            low--;<br>            high++;<br>        &#125;<br><span class="hljs-comment">//         记录最大长度</span><br>        <span class="hljs-keyword">if</span> (high - low &gt; range[<span class="hljs-number">1</span>] - range[<span class="hljs-number">0</span>]) &#123;<br>            range[<span class="hljs-number">0</span>] = low;<br>            range[<span class="hljs-number">1</span>] = high;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a><ul><li>double, long long等数据类型的区别</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>提问记录</title>
    <link href="/2024/06/28/%E6%8F%90%E9%97%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/28/%E6%8F%90%E9%97%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="24-06-27"><a href="#24-06-27" class="headerlink" title="24-06-27"></a>24-06-27</h2><ol><li><p>DDS可靠性相关 -&gt; 如何保证可靠性？接收端来不及处理时，如何保证？</p><ul><li>DDS可以理解为是一种传输协议，它的可靠性可以保证：发端发送一条消息后，可以到达接收端的DDS协议栈中，并驻留在接收端的History中。如果接收端的应用层来不及处理新收到的消息，那就不立即处理，后续可以使用read接口从协议栈中获取之前接收到的数据。</li><li>上述可能会出现接收端缓存满，而尚有消息未处理的情况：此时，就需要扩大History的消息缓存数目。这里就是History QoS 与 Resource QoS这两种不同服务质量要求之间的trade了。</li></ul></li><li><p>MCU上做开发与Linux用户态开发有什么不同？分别有哪些需要注意的内容？</p><ul><li>MCU上直接看到真实物理内存，Linux用户态多了一层虚拟地址转换。因此在MCU上做开发时，更要注意对指针的使用。</li><li>MCU上有时Linker，链接脚本，程序、变量存放位置；Linux用户态不用考虑这些问题。</li><li>调试时，MCU上遇到TRAP等问题，要去翻具体的芯片架构手册进行排查；Linux用户态有一套标准的exception机制。</li><li>MCU上做开发更类似于Linux内核态驱动开发。</li><li>MCU上有时需要考虑boot的问题，Linux用户态不用考虑。</li><li>MCU上开发一般只会用到静态库，而Linux上还会有动态库。</li></ul></li><li><p>(之前软硬件结合提到了对指针的“恍然大悟”)那你现在是如何理解指针的？</p><ul><li>指针就是一个普通的变量，对它进行加减乘除，函数参数，就像普通变量那样使用</li><li>重点在于如何使用指针变量，如何解释指针 -&gt; 这里就得说一下指针类型转换</li><li>使用时，相比于普通变量，要多考虑一层：它指向了某块内存区域！内存区域的大小与指针指向的对象类型有关</li><li>指针使用：大部分都会取成员 -&gt; 指针指向的对象类型是什么？这个问题也要时刻注意</li><li>c++中，class C 继承于 class B , class A。<code>C v_c; B* p_b = &amp;v_c; A* p_a = &amp;v_c</code>，这三行语句，p_b的值与p_a的值是不一样的！</li><li>在c语言中，常把指针和数组进行比较。</li></ul></li><li><p>用一个词形容操作系统</p><ul><li>管理者</li><li>根据管理的内容不同，OS又可以分为宏内核&#x2F;微内核</li><li>MCU上的OS一般只有CPU管理的功能</li><li>SoC上使用基于Linux的操作系统，还会有内存管理，进程通信，文件系统等功能</li></ul></li></ol><h2 id="24-07-04"><a href="#24-07-04" class="headerlink" title="24-07-04"></a>24-07-04</h2><ol><li><p>如何在不使用额外变量的情况下，交换两个整形变量的值</p><ul><li>方法一：采用数学运算 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = x + y<span class="hljs-comment">;  // -&gt; 虽然这里可能会有溢出的情况，但**由于**负数采用补码的方式表示，后续运算后，也能实现交换的目的</span><br><span class="hljs-attr">y</span> = x - y<span class="hljs-comment">;</span><br><span class="hljs-attr">x</span> = x - y<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>方法二： 采用异或运算 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = x ^ y<span class="hljs-comment">;</span><br><span class="hljs-attr">y</span> = x ^ y<span class="hljs-comment">;</span><br><span class="hljs-attr">x</span> = x ^ y<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>叠砖块问题</p><ul><li>要保证第二块及以上所有砖的“重心和”落在第一块砖内<br> 这题要分情况讨论：</li><li>如果每块砖伸出的长度可以自由调整， <a href="https://max.book118.com/html/2018/0103/147107237.shtm">参考</a>，可以证明：以1&#x2F;2n的规律无限延伸</li><li>如果每块砖伸出的长度为固定大小，可以证明：最远可伸出1&#x2F;2n</li></ul></li><li><p>“叠砖块问题”的启发</p><ul><li>面试时要大胆的说出自己的直觉，并且额外补充说明：需要进一步的分析与证明</li></ul></li><li><p>有符号数溢出问题</p><ul><li>要注意负数以补码的形式存储：绝对值的反码+1</li><li>unsigned char 和 signed char表示的数据范围是不一样的</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aarch64-linux-内存管理（二）</title>
    <link href="/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://blog.csdn.net/yhb1047818384/article/details/109169979">Linux内存管理(四)：paging_init分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>aarch64-linux-内存管理（一）</title>
    <link href="/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ol><li><a href="https://blog.csdn.net/yhb1047818384/category_10345494.html">Linux内存管理-专栏</a></li><li><a href="http://www.wowotech.net/memory_management/memory_model.html">Linux内存模型</a></li><li><a href="https://www.cnblogs.com/liuhailong0112/p/14465697.html">arm64架构linux内核地址转换__pa(x)与__va(x)分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3Mjg2NDQ0NA==&mid=2247485533&idx=1&sn=bf4dc798fc2cbbe0b55dcd0f5360d933&chksm=cee9878ef99e0e98628bd41f0a733f47d955e470d26840d0f07cc5aa7c9f789e746133c39c82&scene=178&cur_album_id=2707075920913924097#rd">底层开发必知的三个内存结构概念</a></li></ol><h2 id="内存硬件结构"><a href="#内存硬件结构" class="headerlink" title="内存硬件结构"></a>内存硬件结构</h2><p>Linux 把物理内存划分为三个层次来管理: 存储节点(Node)、内存管理区(Zone)和页面(Page)</p><ul><li>Node -&gt; struct pglist_data，包含的重要信息有<ul><li>该 Node 包含的Zone数目</li><li>该node中内存的起始页帧号</li><li>该node地址范围内的实际管理的页面数量</li><li>该node地址范围内的所有页面数量，包括空洞的页面</li><li>ZONE_PADDING宏：让前后的成员分布在不同的cache line中, 以空间换取时间</li></ul></li><li>Zone -&gt; struct Zone<ul><li>将node拆分成zone主要还是出于Linux为了兼容各种架构和平台，对不同区域的内存需要采用不同的管理方式和映射方式；32位系统中，内核和用户地址空间按1:3划分，内核地址空间只有1GB，所以不能把1GB以上的内存直接映射到内核地址空间，因此就把不能直接映射的内存划分到了高端内存区</li><li>ZONE_DMA: 只适用于Intel x86架构，ARM架构没有这个区域，用于ISA设备的DMA操作，物理地址范围为0-16MB</li><li>ZONE_DMA32: 在64位的系统上使用32位地址寻址的适合DMA操作的内存区。例如在AMD64系统上，该区域为低4GB的空间。在32位系统上，本区域通常是空的</li><li>ZONE_NORMAL: 指的是<u>可以直接映射到内核空间的内存</u>。也常称为“普通区域”“直接映射区域”“线性映射区域”。所谓线性映射就是物理地址和映射后的虚拟地址存在一种简单的关系，即虚拟地址&#x3D;物理地址+固定偏移。在32位系统上，内核空间和用户空间按1:3划分，那么这个固定偏移就是：<code>0xC0000000</code> - 物理内存起始地址。因此可以看到：在32位系统中，将物理内存地址的低1G[物理内存起始地址(start): start+1G]映射到内核空间[0xc0000000:0xffffffff]</li><li>ZONE_HIGHMEM: 高端内存区，32位时代的产物。在32位系统上，指的是高于<code>896M</code>的物理内存。32位系统中，内核和用户地址空间按1:3划分，内核地址空间只有1GB，所以不能把1GB以上的内存直接映射到内核地址空间，因此就把不能直接映射的内存划分到了高端内存区。要将高于896MB的物理内存映射在内核空间的话，需要通过单独的映射来完成，并且这类映射不能保证物理地址和虚拟地址之间存在固定的对应关系（例如ZONE_NORMAL的固定偏移）<blockquote><p>64位系统中没有这个区域，即没有高端内存。因为64系统的内核虚拟地址空间非常大，不再需要高端内存区域</p></blockquote></li><li>指向所属的Node节点</li><li>空闲内存链表，用于实现伙伴系统</li></ul></li><li>Page -&gt; struct page<ul><li>Linux内核使用page结构体来描述一个物理页面，每一个page frame有一个一一对应的page数据结构，系统中定义了page_to_pfn和pfn_to_page的宏用来在page frame number和page数据结构之间进行转换，具体如何转换是和<a href="http://www.wowotech.net/memory_management/memory_model.html">memory modle</a>相关</li><li>PFN是page frame number的缩写，所谓page frame，就是针对物理内存而言的，把物理内存分成一个个的page size的区域，并且给每一个page 编号，这个号码就是PFN。假设物理内存从0地址开始，那么PFN等于0的那个页帧就是0地址（物理地址）开始的那个page。假设物理内存从x地址开始，那么第一个页帧号码就是（x&gt;&gt;PAGE_SHIFT）</li></ul></li><li>区分系统物理地址空间 VS 内存占据的物理地址空间<ul><li>整个系统的物理地址空间并不是都用于内存，有些也属于I&#x2F;O空间（当然，有些cpu arch有自己独立的io address space）。因此，内存所占据的物理地址空间应该是一个有限的区间，不可能覆盖整个物理地址空间</li></ul></li></ul><ol><li>UMA 与 NUMA<ul><li>UMA: Uniform Memory Access，统一内存访问，每个CPU共享相同的内存地址空间</li><li>NUMA: Non-Uniform Memory Access，非统一内存访问。系统中会有很多的内存节点和多个CPU簇， 所有节点中的CPU可以访问全部的物理内存，但是CPU访问本地的节点速度远快于访问远端的内存节点的速度</li></ul></li></ol><h2 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h2><p>主要问题有：</p><ol><li><p>内核如何知道系统的物理内存信息？</p><ul><li>DTB 方式，物理内存信息会写到DTB image中，内核在启动初期对DTB进行解析，得到物理内存信息</li><li>ACPI 方式，会在BIOS中写入物理内存信息</li></ul></li><li><p>内核启动初期有一部分汇编编写的位置无关码，它们主要做了什么事情？</p><ul><li>内核绝大部分的代码都不是位置无关码，且其运行时地址基本为虚拟地址，因此在执行到内核主体部分代码时，需要开启MMU，启动虚拟化。开启虚拟化就需要提供页表</li><li>因此，在进入start_kernel()之前的初始阶段汇编代码会进行两个页表映射：<ul><li><code>identity mapping</code>：VA和PA相等的一段映射，主要目的就是为了打开MMU。<u>在打开mmu之前，cpu访问的都是物理地址，打开mmu访问的就是虚拟地址</u>，其实真正打开mmu的操作就是往某个system register的某个bit写1， 如果在开启mmu之前已经下发了某一个数据的操作指令，本来它是想访问物理地址的，结果mmu打开导致访问了虚拟地址，这样会造成混乱。 所以为了解决这一个情况，引入了identity mapping。VA &#x3D; PA， 打开mmu前后，无论访问物理地址还是虚拟地址，都是对应同一段物理内存</li><li><code>kernel image mapping</code>：内核镜像映射，主要目的是为了执行内核代码。打开了MMU后，内核需要运行起来，就需要将kernel运行需要的地址（kernel txt、rodata、data、bss等等）进行映射。映射到的虚拟地址为：内核编译时指定（计算出）的虚拟地址（<em><strong>存疑❓</strong></em>）</li></ul></li></ul></li></ol><p><code>idmap_pg_dir</code>是identity mapping用到的页表，<code>init_pg_dir</code>是kernel_image_mapping用到的页表。这两个页表定义在arch&#x2F;arm64&#x2F;kernel&#x2F;vmlinux.lds.S中，同样定义在该文件中的还有另外三个页表<code>reserved_ttbr0</code>，<code>tramp_pg_dir</code>， <code>swapper_pg_dir</code>。</p><ul><li>reserved_ttbr0：是内核访问用户空间需要用的页表。</li><li>tramp_pg_dir：适用于映射kaslr的内核区域</li><li><u>swapper_pg_dir</u>：在内核启动期间进行常规映射后，用作内核页表。（在4.20的内核之前其实是没有init_pg_dir这个概念的，arm64&#x2F;mm: Separate boot-time page tables from swapper_pg_dir添加了启动时pgd的init_pg_dir）这几个页表的位置、大小在内核链接文件中都有定义。</li><li>使用init_pg_dir，是因为处理FDT的内核代码，后续的内核代码比较大；但是物理内存还没有扫描完成，进行不了最终swapper页表的建立</li></ul><ol start="3"><li><p>初期的kernel image mapping （init_pg_dir）是如何进行（初始化这个页表）的？</p><ul><li>Linux代码如下 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Map the kernel image (starting with PHYS_OFFSET).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x0</span>, init_pg_dir<br><span class="hljs-symbol">mov_q</span>   <span class="hljs-built_in">x5</span>, KIMAGE_VADDR + TEXT_OFFSET   <span class="hljs-comment">// compile time __va(_text)</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x23</span>           <span class="hljs-comment">// add KASLR displacement</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">x4</span>, PTRS_PER_PGD<br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x6</span>, _<span class="hljs-meta">end</span>           <span class="hljs-comment">// runtime __pa(_end)</span><br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x3</span>, _text          <span class="hljs-comment">// runtime __pa(_text)</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x3</span>            <span class="hljs-comment">// _end - _text</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x5</span>            <span class="hljs-comment">// runtime __va(_end)</span><br> <br><span class="hljs-symbol">map_memory</span> <span class="hljs-built_in">x0</span>, <span class="hljs-built_in">x1</span>, <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x7</span>, <span class="hljs-built_in">x3</span>, <span class="hljs-built_in">x4</span>, <span class="hljs-built_in">x10</span>, <span class="hljs-built_in">x11</span>, <span class="hljs-built_in">x12</span>, <span class="hljs-built_in">x13</span>, <span class="hljs-built_in">x14</span><br></code></pre></td></tr></table></figure> ❗️ KIMAGE_VARDDR 即为内核映像的虚拟空间开始地址。这个值也是在编译时指定的【或者可以计算出的】<br> ❗️ TEXT_OFFSET 即为内核代码段相对于内核虚拟地址起始位置的偏移<br> ❗️ <font color=#DC143C>adrp 指令用于获取标号的运行时物理地址【借助运行当前指令时的PC值】</font></li><li><a href="https://stackoverflow.com/questions/51763634/why-physical-address-of-aarch64-kernel-image-is-nonnegative">TEXT_OFFSET</a> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-keyword">in</span> file <span class="hljs-regexp">/arch/</span>arm64<span class="hljs-regexp">/kernel/</span>vmlinux.lds.S<br>. = KIMAGE_VADDR + TEXT_OFFSET; <br>.head.text : &#123;                          <br>_text = .;<br>HEAD_TEXT<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p> 这里，TEXT_OFFSET是一个随机值，因此每次编译时，内核代码的偏移都不是固定的（出于安全的考虑）。最新Linux代码中已经不使用TEXT_OFFSET了。虚拟地址随机化完全依赖于kaslr_offset。init_pg_dir页表的初始化过程也稍有变化：__primary_switch -&gt; __pi_early_map_kernel()[这个函数似乎就是：early_map_kerne()]<br> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs armasm">   . = KIMAGE_VADDR<span class="hljs-comment">;</span><br><br><span class="hljs-symbol">.head.text</span> : &#123;<br>_text = .<span class="hljs-comment">;</span><br>HEAD_TEXT<br>&#125;<br><span class="hljs-symbol">.text</span> : <span class="hljs-meta">ALIGN</span>(SEGMENT_ALIGN) &#123;<span class="hljs-comment">/* Real text segment*/</span><br>_stext = .<span class="hljs-comment">;  </span><br>       ......<br>   &#125;<br>   <br>   <span class="hljs-comment">// in /arch/arm64/kernel/head.S  </span><br><br>   SYM_FUNC_START_LOCAL(__primary_switch)<br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x1</span>, reserved_pg_dir<br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x2</span>, init_idmap_pg_dir<br><span class="hljs-keyword">bl</span>__enable_mmu<br><br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x1</span>, early_init_stack<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">sp</span>, <span class="hljs-built_in">x1</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x29</span>, xzr<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x0</span>, <span class="hljs-built_in">x20</span><span class="hljs-comment">// pass the full boot status</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x1</span>, <span class="hljs-built_in">x21</span><span class="hljs-comment">// pass the FDT</span><br><span class="hljs-keyword">bl</span>__pi_early_map_kernel<span class="hljs-comment">// Map and relocate the kernel</span><br><br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">x8</span>, <span class="hljs-symbol">=__primary_switched</span><br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x0</span>, KERNEL_START<span class="hljs-comment">// __pa(KERNEL_START)</span><br><span class="hljs-keyword">br</span><span class="hljs-built_in">x8</span><br>   SYM_FUNC_END(__primary_switch)<br></code></pre></td></tr></table></figure></p><p> 可以看到，在初始化init_pg_dir时，mmu已经开启了。需要注意：</p><ul><li>❗️<code>bl __pi_early_map_kernel</code>: BL: Branch with Link branches to a PC-relative offset</li><li>❗️<code>br x8</code>: “Adding an L to the B or BR instructions turns them into a branch with link. This means that a<br> return address is written into LR (X30) as part of the branch.” 可以看出B，BR是两个不同的指令。</li><li>❗️ 因此，<code>br x8</code>将__primary_switched标号的虚拟地址赋给PC，从前面的链接文件可以看到，其虚拟地址处于KIMAGE_VADDR开始之后的位置。因此，之后Linux内核将运行于高地址的虚拟内存空间。</li></ul><blockquote><p>[from 《Armv8-A Instruction Set Architecture》]： The unconditional branch instruction B <label> performs a direct, PC-relative, branch to <label>. The offset from the current PC to the destination is encoded within the instruction. The range is limited by the space available within the instruction to record the offset and is +&#x2F;- 128MB. When you use BR <Xn>, BR performs an indirect, or absolute, branch to the address specified in Xn.</p></blockquote> <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// in file /arch/arm64/kernel/pi/map_kernel.c<br><br>asmlinkage void __init early_map_kernel(u64 boot_status, void *fdt)<br>&#123;<br>    u64 v<span class="hljs-built_in">a_base</span>, p<span class="hljs-built_in">a_base</span> = (u64)&amp;_text<span class="hljs-comment">;</span><br>    u64 kaslr_offset = p<span class="hljs-built_in">a_base</span> % MIN_KIMG_ALIGN<span class="hljs-comment">;</span><br><br>    map_fdt((u64)fdt)<span class="hljs-comment">;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * The virtual KASLR displacement modulo 2MiB is decided by the</span><br><span class="hljs-comment">    * physical placement of the image, as otherwise, we might not be able</span><br><span class="hljs-comment">    * to create the early kernel mapping using 2 MiB block descriptors. So</span><br><span class="hljs-comment">    * take the low bits of the KASLR offset from the physical address, and</span><br><span class="hljs-comment">    * fill in the high bits from the seed.</span><br><span class="hljs-comment">    */</span><br>    if (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) &#123;<br>        u64 kaslr_seed = kaslr_early_init(fdt, chosen)<span class="hljs-comment">;</span><br><br>        if (kaslr_seed &amp;&amp; kaslr_requires_kpti())<br>            arm64_use_ng_mappings = <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br><br>        kaslr_offset |= kaslr_seed &amp; ~(MIN_KIMG_ALIGN - <span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>    &#125;<br><br>    if (IS_ENABLED(CONFIG_ARM64_LPA2) &amp;&amp; v<span class="hljs-built_in">a_bits</span> &gt; V<span class="hljs-built_in">A_BITS</span>_MIN)<br>        remap_idmap_for_lpa2()<span class="hljs-comment">;</span><br><br>    v<span class="hljs-built_in">a_base</span> = KIMAGE_VADDR + kaslr_offset<span class="hljs-comment">;</span><br>    map_kernel(kaslr_offset, v<span class="hljs-built_in">a_base</span> - p<span class="hljs-built_in">a_base</span>, root_level)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>kaslr_offset:<br> 这里相当于给内核运行时虚拟地址加了一个随机的偏移，因此后续在map_kernel中需要对内核进行重定位。<u>物理地址随机化比较好处理，虚拟地址随机化之后，内核大部分代码都需要重定位</u>。</li></ul></li><li><p>内核如何去解析这些配置信息？</p><ul><li>现在虽然MMU已经打开，kernel image的页表已经建立，但是内核还没有为DTB这段内存创建映射，现在内核还不知道内存的布局，所以内存管理模块还没能初始化。这个时候就需要用到fixmap。即将DTB的物理地址映射到Fixed map中的区域，然后访问该区域中的虚拟地址即可。</li><li>解析DTB获取系统的物理内存信息，并保存到 <em><strong>memblock</strong></em> 结构中，这是一个全局的变量，用于管理内核早期启动阶段过程中的所有物理内存。</li></ul></li></ol><h2 id="顺序记录"><a href="#顺序记录" class="headerlink" title="顺序记录"></a>顺序记录</h2><h3 id="aarch64-内核内存布局"><a href="#aarch64-内核内存布局" class="headerlink" title="aarch64-内核内存布局"></a>aarch64-内核内存布局</h3><ul><li>0-256T -&gt; 用户空间；256-512T -&gt; 内核空间</li></ul><h4 id="fixed-mappings-4124KB"><a href="#fixed-mappings-4124KB" class="headerlink" title="fixed mappings[4124KB]"></a><a href="https://www.cnblogs.com/alantu2018/p/8447570.html">fixed mappings[4124KB]</a></h4><p>固定映射区，这部分的虚拟地址在编译阶段就已经确定。 在内核的启动过程中，有些模块需要使用虚拟内存并mapping到指定的物理地址上。而且，这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，linux kernel固定分配了一些fixmap的虚拟地址，这些地址有固定的用途。使用该地址的模块在初始化的时候，将这些固定分配的地址mapping到指定的物理地址上去，进而可以通过虚拟化访问到需要访问的特定物理内存。<a href="https://www.cnblogs.com/alantu2018/p/8447570.html">参考</a></p><p><em><strong>个人理解</strong></em>：例如在处理DTB时，内核初始部分代码将启动参数给出的DTB物理地址映射到fixed mappings虚拟空间区域，进而在开启虚拟化之后，实现对DTB的解析</p><p><em><strong>fixed address</strong></em>的具体位置，对于aarch64架构，当前内核中这部分对应的虚拟地址范围为<code>[fffffdfffe5f9000, fffffdfffe9fffff]</code>，总共4124KB大小</p><p><em><strong>fixed address</strong></em>又分为两大类：永久映射 &amp; 临时映射</p><ol><li>永久映射：用于具体的某个内核模块，使用关系是永久的。涉及到的模块主要有：</li></ol><ul><li>DTB解析模块：</li><li>early Console 模块：kernel启动阶段初期可以使用的consol，可以用于输出各种调试信息</li><li>动态打补丁的模块：使用fixed address映射具有RW属性的代码段，进而动态修改这部分代码段的部分内容</li></ul><ol start="2"><li>临时映射：各个内核模块都可以使用，用完之后就释放。主要用于early ioremap模块</li></ol><h3 id="aarch64虚拟地址-物理地址"><a href="#aarch64虚拟地址-物理地址" class="headerlink" title="aarch64虚拟地址-&gt;物理地址"></a>aarch64虚拟地址-&gt;物理地址</h3><p>aarch64有两个页表基地址寄存器：</p><ul><li>ttbr0：用户空间页表基地址。启动初期，idmap_pg_dir填入ttbr0。这里将内核代码映射到低虚拟地址空间。</li><li>ttbr1：内核空间页表基地址。启动初期，init_pg_dir填入ttbr1。这个页表将内核代码映射到高虚拟地址空间。</li></ul><p>64bit的虚拟地址并不是所有bit都被用上的。目前有效的VA_BITS的配置是：36, 39, 42, 47。假设我现在使用64K的页和42bit的虚拟地址空间， 使用三级页表。地址转换过程<a href="https://blog.csdn.net/yhb1047818384/article/details/108210044">举例</a>：</p><ol><li>如果VA[63：42] &#x3D; 1, 那么就会使用ttbr1的地址作为一级页表的基地址；如果VA[63:42] &#x3D; 0, 那么就会使用ttbr0的地址作为一级页表的基地址，那么就会使用ttbr0的地址作为一级页表的基地址；</li><li>VA[41:29]放置Level 1页表中的索引，从而找到对应的描述符地址并获取描述符内容，<u>根据描述符中的内容获取Level 2页表基地址</u></li><li>VA[28:16]放置Level 2页表中的索引，从而找到对应的描述符地址并获取描述符内容，根据描述符中的内容获取<u>物理地址的高36位</u>，以4K地址对齐</li><li>VA[15: 0]放置的是物理地址的偏移，结合获取的物理地址高位，最终得到物理地址</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态库vs静态库</title>
    <link href="/2024/06/26/%E5%8A%A8%E6%80%81%E5%BA%93vs%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/2024/06/26/%E5%8A%A8%E6%80%81%E5%BA%93vs%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加减乘除与mod</title>
    <link href="/2024/06/25/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%B8%8Emod/"/>
    <url>/2024/06/25/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%B8%8Emod/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://leetcode.cn/circle/discuss/mDfnkW/">力扣</a></li></ul><h2 id="记录要点"><a href="#记录要点" class="headerlink" title="记录要点"></a>记录要点</h2><h3 id="两个恒等式"><a href="#两个恒等式" class="headerlink" title="两个恒等式"></a>两个恒等式</h3><ul><li><code>(a + b) mod m = [(a mod m) + (b mod m)] mod m</code></li><li><code>(a b) mod m = [(a mod m) (b mod m)] mod m</code></li></ul><h3 id="幂运算与mod"><a href="#幂运算与mod" class="headerlink" title="幂运算与mod"></a>幂运算与mod</h3><ul><li><font color=DC143C>指数不能随便取余</font>，如果指数在 64 位整数的范围内，可以使用<a href="https://leetcode.cn/problems/powx-n/description/">快速幂</a>计算方法<blockquote><p>注：如果指数超出 64 位整数的范围，需要用「欧拉降幂」处理。</p></blockquote></li></ul><h3 id="负数与mod"><a href="#负数与mod" class="headerlink" title="负数与mod"></a>负数与mod</h3><ul><li>如果<code>x</code>是负数，要采用<code>(x mod m + m) mod m</code>的形式，这样不用判断<code>x</code>是否为负数</li></ul><h3 id="除法与mod"><a href="#除法与mod" class="headerlink" title="除法与mod"></a>除法与mod</h3><ul><li>参考上述链接</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码实现时，上面的加减乘除通常这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MOD = <span class="hljs-number">1</span>_000_000_007<br><br><span class="hljs-comment">// 加</span><br>(a + b) % MOD<br><br><span class="hljs-comment">// 减</span><br>(a - b + MOD) % MOD<br><br><span class="hljs-comment">// 取模到 [0,MOD-1] 中，无论正负</span><br>(a % MOD + MOD) % MOD<br><br><span class="hljs-comment">// 乘</span><br>a * b % MOD<br><br><span class="hljs-comment">// 多个数相乘，要步步取模，防止溢出</span><br>a * b % MOD * c % MOD<br><br><span class="hljs-comment">// 除（MOD 是质数且 b 不是 MOD 的倍数）</span><br>a * <span class="hljs-built_in">qpow</span>(b, MOD - <span class="hljs-number">2</span>, MOD) % MOD<br></code></pre></td></tr></table></figure><p>其中 <code>qpow</code> 为快速幂函数。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子数组相关</title>
    <link href="/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">209. 长度最小的子数组</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></p></li></ul><h2 id="对应解答及注意事项"><a href="#对应解答及注意事项" class="headerlink" title="对应解答及注意事项"></a>对应解答及注意事项</h2><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">长度最小的子数组</a></h3><blockquote><ul><li>这个题是滑动窗口的最佳实践！窗口有左右两个边界索引，有点类似于<em><strong>双指针</strong></em>的方法</li><li>官方题解有一个前缀和的做法：<strong>提前算出[0, i]的和，并保存到一个额外的数组中</strong>，接着将题目转化为：<strong>找到两个前缀和，[0, i)，[0, j)<strong>使得这两个前缀和的差 <strong>&gt;&#x3D;</strong> target，记录此时的子数组长度为：</strong>j-i+1</strong>。后续的操作全都转化为了对<em><strong>前缀和数组</strong></em>的查询操作。</li><li></li></ul></blockquote><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h3><blockquote><ul><li>这题可以用<strong>动态规划</strong>的方法</li><li>评论区有提到<strong>前缀和数组</strong>的方法：也是提前算出前缀和，<strong>子数组的和可以转化为两个前缀和的差</strong>。对于前缀和数组来说，题目转化为了<strong>股票购买&#x2F;卖出最佳时机（可以多次持有股票，但手上最多只能有一支股票）</strong></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题心得</title>
    <link href="/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    <url>/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="读题关键字"><a href="#读题关键字" class="headerlink" title="读题关键字"></a>读题关键字</h2><ul><li>注意总结解题模版！！！</li><li>满足条件的最<em><strong>小</strong></em>整数</li><li>涉及到存储长度类似的：[如果最小的不是32位整数，也返回-1]</li></ul><h2 id="常用编程技巧"><a href="#常用编程技巧" class="headerlink" title="常用编程技巧"></a>常用编程技巧</h2><ul><li><p>(long long)(m-1) * (m-2) -&gt; 强制类型转换的优先级高于加减乘除</p></li><li><p>使用程序块为变量赋值，要注意函数块需要使用<font color=#DC143C>()</font>包裹起来：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> sum = (&#123;<br>        <span class="hljs-type">double</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) tmp += nums[j];<br>        tmp;<br>    &#125;);<br></code></pre></td></tr></table></figure></li><li><p>代码行压缩时，如果有多条语句，必须用{}包围起来，如果只有一条语句不用</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;y = <span class="hljs-number">10</span>; z = <span class="hljs-number">100</span>;&#125;<br><span class="hljs-keyword">while</span> (s[i] != <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; i &lt; m) &#123;s[i] -= <span class="hljs-number">1</span>; flag = <span class="hljs-literal">true</span>; i++;&#125;<br><span class="hljs-keyword">while</span>(s[i] == <span class="hljs-string">&#x27;a&#x27;</span>) s[i] -= <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure></li><li><p>在<code>while</code>循环里写额外的for&#x2F;while循环时，一定要记得在内层循环判断越界问题</p></li><li><p>两字符串字典序比较时要注意：循环判断，相等的才会继续，小于或者大于时都会结束判断！！！复习一下这个<a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf">题目</a>，注意提交错误的几个。<strong>可以直接使用string类的&lt;&#x2F;&gt;&#x2F;&gt;&#x3D;运算符，或者compare成员函数进行字典序号的比较</strong></p></li><li><p>体会如何写二叉树的递归：先转化为局部问题，考虑局部root, root-&gt;left, root-&gt;right的递归问题；先不用纠结于前&#x2F;中&#x2F;后的递归顺序，结合这个题目[114.二叉树展开为链表]。</p></li><li><p>判断一个数是否为质数</p><ul><li>daiding</li></ul></li><li><p>计算整数各个位上数字之和：可以先从个位数加起：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfTheDigitsOfHarshadNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = x; v; v /= <span class="hljs-number">10</span>) &#123;<br>        s += v % <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>double, long, int, long long等类型表示的数据范围</p><ul><li>double是双精度浮点型，可以表示小数，在64位系统上占8Bytes。采用的数据表示方法和另外几种数据类型不同，能表示的数据范围是最大的。此外还有float[单精度浮点型], long double[精确度更高]</li><li>其余都是整数类型</li><li>浮点型，牺牲了表示精度，但是增大了数据表示范围</li><li>参考题目：<a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a></li></ul></li></ul><h2 id="个别题目复习"><a href="#个别题目复习" class="headerlink" title="个别题目复习"></a>个别题目复习</h2><ul><li><p>数的前&#x2F;中&#x2F;后遍历的迭代方法要熟悉</p></li><li><p>找数字规律的题目，先找到“主干规律”，再找次要规律，结合题目[6. Z字型变换]</p></li><li><p><em><strong>二叉树层序遍历</strong></em>不一定非得用queue，也可以用vector实现一些重复遍历的操作，结合[2641.]</p></li></ul><h2 id="常用数据结构及其方法"><a href="#常用数据结构及其方法" class="headerlink" title="常用数据结构及其方法"></a>常用数据结构及其方法</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul><li>erase()</li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>&lt;string&gt;</li><li>substr(start, len) ❗️ 注意这个方法的第二个参数为<u>长度</u></li><li>operator &gt; &#x2F; &lt;   -&gt;  string 类重载了这两个运算符，可以直接用于字典序的比较</li><li>compare(const string&amp; str)，返回值如下：<ul><li>0, equal</li><li>-1, lf &lt; rf</li><li>1, lf &gt; rf</li></ul></li><li>erase(start_idx, len)   -&gt; 利用索引和长度删除指定范围的字符</li><li>erase(iterator start, iterator end)  -&gt; 利用迭代器删除指定范围内的字符，[start, end)</li></ul><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><ul><li>&lt;stcak&gt;</li><li>push()</li><li>pop() -&gt; 注意返回值为 void，因此取元素只能用top()方法 ❗️</li><li>top()</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><ul><li>&lt;queue&gt;</li><li>push()</li><li>pop() ❗️ -&gt; 注意返回值为 void，因此取元素只能用front()方法</li><li>top() ❌ -&gt; 没有这个方法，要使用front()</li><li>front() -&gt; 查看队列头部的元素[先插入的]</li><li>back() -&gt; 查看队列尾部的元素[后插入的]</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li>&lt;mao&gt;</li><li>erase() -&gt; 参数可以为 <strong>iterator</strong>，<strong>key</strong>；也可以为范围参数’[first it, last it)’</li><li>定义map型对象时，如何自定义key比较函数：注意只能定义key的比较函数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp_key</span><br>&#123;<br>    <span class="hljs-comment">// 注意，函数的参数需要于map的key的参数类型相同</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">key_t</span> &amp;k1, <span class="hljs-type">const</span> <span class="hljs-type">key_t</span> &amp;k2)</span><span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(k1.dwBussID != k2.dwBussID)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwBussID &lt; k2.dwBussID;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(k1.dwVersion != k2.dwVersion)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwVersion &lt; k2.dwVersion;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k1.dwHashUrl != k2.dwHashUrl)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwHashUrl &lt; k2.dwHashUrl;<br>        &#125;<br>　　　　　　　　  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用库函数运算"><a href="#常用库函数运算" class="headerlink" title="常用库函数运算"></a>常用库函数运算</h2><ul><li><p>lower_bound(iterator_start, iterator_end, value) -&gt; 返回第一个迭代器it，其值<strong>不满足</strong> <code>(*it) &lt; value</code></p><ul><li>即找到第一个迭代器，其值<strong>满足</strong> <code>value &lt;= (*it)</code></li></ul></li><li><p>upper_bound(start, end, value) -&gt; 返回第一个迭代器，其值<strong>满足</strong> <code>value &lt; (*it)</code></p></li><li><p>upper_bound()</p></li><li><p>atan2() -&gt; double，求坐标(x, y)到x轴的极角，范围为[-pi, pi]。这里要注意坐标上的点在-x轴上时，其极角可能为-pi，也可能为pi，但只能为一个值</p><ul><li><a href="https://leetcode.cn/problems/maximum-number-of-visible-points/description/">1610. 可见点的最大数目</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/monotonous-stack/">单调栈</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>弹出时只能从栈顶[st.top()]弹出</li><li>从栈顶到栈底，元素大小呈某种单调趋势</li><li>当欲压入栈的元素不满足这个单调性时，就要把不满足单调性的所有[栈顶]元素弹出 -&gt; 这个性质用到的比较多</li><li>配合数组使用时，栈内可以存储对应元素的下标，而不是元素值</li></ul><h2 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h2><ul><li>使用时要注意考虑单调顺序：1️⃣递增，2️⃣递减</li><li>要搞清楚单调栈中记录元素的意义：例如题—[503]，单调栈中记录的是还没有找到下一个更大值的<em><strong>下标</strong></em>, 只要遍历到比栈顶元素值更大的数，就意味着栈顶元素找到了答案，记录答案，然后从栈顶弹出</li><li>一定要注意单调栈里存储的是<em><strong>索引</strong></em>还是<em><strong>元素值</strong></em></li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素2</a></li><li><a href="https://leetcode.cn/problems/next-greater-element-iii/description/">556.下一个更大元素3</a>: 变形题，比较有意思！！！</li></ul><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><ul><li>[556] 一定要注意题目的条件 -&gt; <ul><li>满足条件的最小整数</li><li>如果最小的不是32位整数，也返回-1</li></ul></li></ul><h2 id="扩展-循环数组"><a href="#扩展-循环数组" class="headerlink" title="扩展-循环数组"></a>扩展-循环数组</h2><ul><li>处理方式1：将[0:n-1]个个数顺序拷贝到第n个数后面，构成一个普通数组</li><li>处理方式2：遍历[0:2n-1)次，取元素时对下标取模</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li><li><a href="https://writings.sh/post/union-find">并查集简记</a></li></ul><h2 id="Leetcode-题目"><a href="#Leetcode-题目" class="headerlink" title="Leetcode 题目"></a>Leetcode 题目</h2><ul><li><a href="https://leetcode.cn/problems/smallest-string-with-swaps/description/">1202.交换字符串中的元素</a></li></ul><h2 id="对应题解"><a href="#对应题解" class="headerlink" title="对应题解"></a>对应题解</h2><ul><li>1202 [from Andy at Leetcode]<blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> father[<span class="hljs-number">100010</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//并查集find</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x==father[x]?x:(father[x] = <span class="hljs-built_in">find</span>(father[x]));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//并查集merge</span></span><br><span class="hljs-function">    </span>&#123;<br>        father[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">smallestStringWithSwaps</span><span class="hljs-params">(string s, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        string areastr[<span class="hljs-number">100010</span>]; <span class="hljs-comment">//areastr[x]含义为并查集里所有father==x的结点集合</span><br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">100010</span>] =&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//cnt[x]含义为areastr[x]内的第一个未分配元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) father[i] = i;<span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: pairs) <span class="hljs-built_in">merge</span>(i[<span class="hljs-number">1</span>], i[<span class="hljs-number">0</span>]);<span class="hljs-comment">//merge连通结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            areastr[<span class="hljs-built_in">find</span>(i)]+=s[i];<span class="hljs-comment">//将s[i]添加到连通结点集合内</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            <span class="hljs-built_in">sort</span>(areastr[i].<span class="hljs-built_in">begin</span>(),areastr[i].<span class="hljs-built_in">end</span>());<span class="hljs-comment">//对每个连通图内容排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            s[i] = areastr[father[i]][cnt[<span class="hljs-built_in">find</span>(i)]++];<span class="hljs-comment">//根据连通图内排序后结果还原字符串</span><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDS回环-吞吐量测试记录</title>
    <link href="/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LW-DDS"><a href="#LW-DDS" class="headerlink" title="LW DDS"></a>LW DDS</h2><ul><li>240607-可以用于毕业小实验数据采集</li><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="Cyclone-DDS"><a href="#Cyclone-DDS" class="headerlink" title="Cyclone DDS"></a>Cyclone DDS</h2><ul><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="RTI-DDS"><a href="#RTI-DDS" class="headerlink" title="RTI DDS"></a>RTI DDS</h2><p>- </p><h2 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h2><ul><li>Cyclone 和 Fast[2.12.0]都定义了0x8007这个PID，但是含义不一样，因此Fast在接收到Cyclone的data(p)报文，进行处理时出错，不会创建参与者代理，因此匹配不了</li><li>FastDDS调试时常用的断点：<ul><li>on_new_cache_change_added() [“Ignore announcement from own RTPSParticipant”] at file: PDPListener.cpp -&gt; 用于处理data(p)报文</li><li>EDPSimplePUBListener::on_new_cache_change_added() at file: EDPSimpleListeners.cpp -&gt; 用于处理data(w)报文</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回文串性质</title>
    <link href="/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/"/>
    <url>/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="参考题目"><a href="#参考题目" class="headerlink" title="参考题目"></a>参考题目</h2><ul><li><a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/">2663. 字典序最小的美丽字符串</a></li><li><a href="https://leetcode.cn/problems/find-palindrome-with-fixed-length/description/">2217. 找到指定长度的回文数</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>aa，aba，很明显，最小模式的回文串只有这两种模式</li><li>对于长度为 m (m &gt; 3) 的回文串，其必包含长度为 m-2 的回文串</li><li>因此，“不包含任何长度为2或更长的回文串” &lt;&#x3D;&#x3D;&gt; “不包含长度为2或3的回文串”</li><li>当用[0-9]的数字来组成回文串，则其长度为n的回文串按大小排序时，有明显的规律</li><li>要注意：回文串是有<em><strong>对称性</strong></em>的，因此长度为n的回文串（由数字组成时），可以由其前(n+1)&#x2F;2个整数部分唯一确定，因为后续的数字与前面的数字成镜像对称</li><li>回文串的<strong>中间部分</strong>一定是由连续且相同的字符串组成：<code>aba</code>, <code>abccba</code>, <code>tartattatrat</code></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>如果题目中“不包含任何长度为2或更长” 改为-&gt; “不包含任何长度为3&#x2F;4&#x2F;5&#x2F;m或更长”，该怎么做？</li></ul><h2 id="基础：回文串的判别"><a href="#基础：回文串的判别" class="headerlink" title="基础：回文串的判别"></a>基础：回文串的判别</h2><ul><li>可以根据对称性进行回文串的判断<ol><li>区分长度的奇偶性，找到双指针i，j</li><li>i–，j++分别判断s[i] &#x3D;&#x3D; s[j]是否成立</li><li>要注意：如果字串长度为奇数，则只能为<code>aba</code>类型；但是当字串长度为偶数是，可以为<code>aa</code>，也可以为<code>abaaba</code></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/22/hello-world/"/>
    <url>/2024/06/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
