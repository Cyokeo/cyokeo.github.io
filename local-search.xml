<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP学习-超时与重传</title>
    <link href="/2024/07/24/TCP%E5%AD%A6%E4%B9%A0-%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/"/>
    <url>/2024/07/24/TCP%E5%AD%A6%E4%B9%A0-%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP超时与重传"><a href="#TCP超时与重传" class="headerlink" title="TCP超时与重传"></a>TCP超时与重传</h1><h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><ul><li>发送时设置一个定时器来解决<strong>数据</strong>和<strong>确认</strong>可能丢失的问题</li><li>如何确定超时判断间隔？</li><li>如何确定重传的频率？<ul><li>1，2，4，8， 16，32，64……</li></ul></li></ul><h2 id="典型实现"><a href="#典型实现" class="headerlink" title="典型实现"></a>典型实现</h2><ul><li>测量TCP报文段的往返时间<ul><li>这样才能比较好的确定超时时间</li><li>发出数据 -&gt; 收到ACK的时间间隔？</li></ul></li><li>使用测量结果对下一个将要传输的报文段建立重传超时时间</li></ul><h2 id="四个定时器"><a href="#四个定时器" class="headerlink" title="四个定时器"></a>四个定时器</h2><ul><li>对每个连接，TCP管理四个不同的定时器<ul><li><strong>重传定时器</strong>使用于当希望收到<u>另一端的确认</u></li><li><strong>坚持(persist)定时器</strong>使<u>窗口大小信息</u>保持不断流动，即使另一端关闭了其接收窗口</li><li><strong>保活(keepalive)定时器</strong>可检测到一个<u>空闲连接的另一端何时崩溃或重启</u></li><li><strong>2MSL定时器</strong>测量一个连接处于TIMEWAIT状态的时间</li></ul></li></ul><h2 id="往返-RTT-时间测量"><a href="#往返-RTT-时间测量" class="headerlink" title="往返(RTT)时间测量"></a>往返(RTT)时间测量</h2><ul><li>该时间在民用网络中可能是会经常变化的，因此TCP需要跟踪这些变化并相应地调整其超时时间</li></ul><h3 id="测量演进"><a href="#测量演进" class="headerlink" title="测量演进"></a>测量演进</h3><ul><li>测量某报文段和其响应之间地时间差<code>M</code>，并动态更新其RTT值；<code>RTT = k*RTT + (1-k)*M</code></li><li>超时间隔设置为<code>RTO = b*RTT</code>，b地推荐值为2</li><li><code>缺陷</code>：在RTT变化很大地场景下，无法跟踪变化，因此会引起不必要的重传</li><li><code>改进</code>：跟踪RTT的方差并进行平滑，放到RTT估计值中去</li><li><code>Karn算法</code>：当一个分组重传发生时，在重传数据的确认最后到达之前，不能更新RTT的值；这是因为不知道收到的确认不知道对应于哪一次重传</li></ul><h2 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h2><ul><li>应对达到中间路由器转发极限的算法</li><li>假设：分组丢失意味着在源主机和目的主机之间的某处网络上发生了拥塞</li><li>两种<strong>分组丢失的指示</strong><ul><li>发生超时</li><li>接收到重复的确认</li></ul></li><li><strong>慢启动算法</strong>可以降低分组进入网络中的速率，当拥塞发生时可以使用慢启动来做这一动作以减少网络拥塞。实际中，这两个算法通产一起实现：<ul><li>拥塞避免相关参数：cwnd（本地拥塞窗口大小）</li><li>慢启动相关参数：ssthresh（慢启动门限）</li></ul></li></ul><h3 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h3><ul><li>未发生分组丢失时，cwnd逐渐增加，增加的速率取决于cwnd和ssthresh的关系<ul><li>如果cwnd &lt;&#x3D; ssthresh，说明此时处于慢启动阶段，cwnd以指数速率增长</li><li>如果cwnd &gt; ssthresh，说明此时处于拥塞避免阶段，cwnd以固定速率增长【且一个往返时间内cwnd最多增加1】</li></ul></li><li>如果某一时刻发生了分组丢失<ul><li>ssthresh被设置为当前窗口的一半: <code>min(2, min(cwnd, 通告窗口大小))/2</code></li><li>cwnd的设置与分组丢失的原因有关：<ul><li>如果是超时引起，则cwnd &#x3D; 1</li><li>否则，被设置为？？？ -&gt; <strong>快速恢复</strong>，设置为新的ssthresh值+3个报文段大小</li></ul></li></ul></li></ul><h2 id="快速重传与快速恢复"><a href="#快速重传与快速恢复" class="headerlink" title="快速重传与快速恢复"></a>快速重传与快速恢复</h2><ul><li>承接上面最后的问题，当收到<strong>3个及以上</strong>重复的确认，就非常有可能发生了报文丢失，因此重传丢失的数据报文段，无需等待超时器溢出 -&gt; <strong>快速重传</strong><ul><li>进入拥塞避免阶段，而不是慢启动  -&gt; <strong>快速恢复</strong></li></ul></li><li>收到重复的确认时，接收方一定收到了大于该确认号的数据段；否则接收方不会有任何响应，只能等待发送方超时器超时进行重传</li></ul><h3 id="流程细节【这里需要进一步的思考，记忆】"><a href="#流程细节【这里需要进一步的思考，记忆】" class="headerlink" title="流程细节【这里需要进一步的思考，记忆】"></a>流程细节【这里需要进一步的思考，记忆】</h3><ul><li>当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半。重传丢失的报文段。设置cwnd为ssthresh加上3倍的报文段大小</li><li>每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）</li><li>当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该<br>是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半</li></ul><h2 id="坚持-persist-定时器"><a href="#坚持-persist-定时器" class="headerlink" title="坚持(persist)定时器"></a>坚持(persist)定时器</h2><ul><li>当接收方通告窗口为0时，发送方将不再发送数据，直到接收方通告窗口大于0；<ul><li>但是后续接收方通告窗口大小是通过ACK进行的，然而TCP不对未带数据的ACK进行确认</li><li>如果这个ACK丢包了怎么办？-&gt; 可能会进入“死锁”</li></ul></li><li>为了解决前述提到的问题，TCP在发送端维护一个<strong>坚持(persist)定时器</strong>以周期性地向接收端查询通告窗口的大小</li></ul><h2 id="保活定时器"><a href="#保活定时器" class="headerlink" title="保活定时器"></a>保活定时器</h2><ul><li><p>保活不是TCP规范中的一部分，但是许多实现提供了保活定时器</p><ul><li>保活功能主要为服务器程序提供的；但客户机也可以开启这个功能</li><li>用于主动关闭服务器上存在的半连接【客户机非正常宕机引起】</li></ul></li><li><p>服务器端保活探测的结果</p><ul><li>如果客户机正常，则保活正常，应用程序无感</li><li>如果客户机崩溃，服务器将收不到对探查的响应，服务器应用程序将收到read接口返回的差错信息</li><li>如果客户机关闭后重启，这时客户机会给服务器发回探查响应，但是该响应为RST，使得服务器终止该连接</li><li>如果客户机对于服务器来说不可达，类似于第二种情况</li></ul></li><li><p>这里注意到：</p><ul><li>客户机程序被终止，并且发出了一个FIN，如果该FIN丢包，会重传</li><li>但是整个时间可能会比较长，而客户宿主机上对客户机程序的关闭就导致TCP连接终止异常</li><li>进而可能导致服务器上存在半连接</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-任务切换与内核栈</title>
    <link href="/2024/07/24/Linux-aarch64-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88/"/>
    <url>/2024/07/24/Linux-aarch64-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h1><ul><li><p>task_struct-&gt;stack成员指向的内存空间就是内核栈</p></li><li><p>陷入内核时，用户任务上下文保存在其内核栈上：<strong>且保存的位置也是固定的，就在内核栈空间最上方预留的的pt_regs区域</strong></p><ul><li>参考《vectors.md》种entry_handler的定义：<code>movx0, sp; blel\el\ht\()_\regsize\()_\label\()_handler</code></li><li>参考 <code>kernel_entry</code>宏的定义中，用户上下文的保存 <code>...; stpx2, x3, [sp, #16 * 1]; ...</code></li><li>综合可知，用户任务上下文保存在<strong>当前内核栈指针的上方</strong></li><li>因此，进程工作在用户态时，其内核栈指针应始终指向内核栈空间最高处-sizeof(pt_regs)处？<strong>这里可能会有些问题</strong><ul><li>刚创建该任务，而且还没有被调度运行时，应该是这样的</li></ul></li><li><strong>但是当该任务被调度运行后</strong>：<ol><li>首先在内核态切换到该任务的内核栈：首次切换到内核栈初期【汇编码范围内】sp确实指向了<code>内核栈空间最高处-sizeof(pt_regs)</code></li><li>接着执行部分内核态代码，此时会有入&#x2F;出栈操作<ul><li>这里要注意：首次进入内核态后，之后会向普通函数调用那样，借助<code>lr</code>寄存器进行函数返回</li><li>注意到任务创建时，任务结构体中固定位置处【保存内核态上下文的结构】将<strong>pc &#x3D; ret_from_fork</strong>，因此任务首次被调度执行 -&gt; 首次进入内核态时执行的第一个比较重要的函数就是<code>ret_from_fork</code></li></ul></li><li>如果任务在内核态被抢占 -&gt; 仍然要把内核态上下文保存到任务结构体的固定位置处？</li><li>之后该任务恢复后，依然继续之前内核态的执行</li><li>再之后需要从内核态返回用户空间：<code>ret_to_user/ret_to_fork</code>: 这里面需要把内核栈上保存的用户空间上下文恢复</li><li>需要区分对待第一次返回到用户空间&#x2F;第二次返回到用户空间：因为第一次返回时内核栈上没有保存的用户上下文？<ul><li>这里还需要再深入看一下创建任务时，有没有为内核栈模拟保存的用户空间上下文！！！？？？❗️❗️</li><li>深入看一下<code>ret_from_fork</code></li></ul></li></ol></li></ul></li><li><p>任务切换时，内核态上下文保存在任务结构体的固定位置处：THREAD_CPU_CONTEXT</p><ul><li>新建任务时，要把其内核栈地址放在其任务结构体成员cpu_context.sp处；-&gt; 再去看一下新建任务时，sp的赋值情况，就可以探索出内核栈的初始内存分配情况；</li><li>根据上面的叙述：<code>要把用户上下文保存在内核栈上方【高地址】位置处</code>，因此在初始创建内核栈时，要注意这一点！！！</li><li>要注意：创建任务时，其tsk-&gt;thread.cpu_context.sp要向内核栈空间最高地址 - 足够的空间容纳pt_regs：<em><strong>与后面的代码走读匹配了</strong></em>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">DEFINE(THREAD_CPU_CONTEXT,offsetof(<span class="hljs-keyword">struct</span> task_struct, thread.cpu_context));<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ......<br>    <span class="hljs-type">void</span>   *<span class="hljs-built_in">stack</span>;      <span class="hljs-comment">// 通过查找，明确了这里为task的内核栈?栈顶（往下增长）</span><br><br>    <span class="hljs-comment">/* CPU-specific state of this task: */</span><br>    <span class="hljs-comment">// 这是一个架构相关的结构体</span><br>    <span class="hljs-comment">// 这个成员位于任务结构体的末尾</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span><span class="hljs-title">thread</span>;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * WARNING: on x86, &#x27;thread_struct&#x27; contains a variable-sized</span><br><span class="hljs-comment">    * structure.  It *MUST* be at the end of &#x27;task_struct&#x27;.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * Do not put anything below here!</span><br><span class="hljs-comment">    */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu_context</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x19;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x20;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x21;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x22;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x23;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x24;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x25;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x26;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x27;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x28;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pc;<br>&#125;; <br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="最终的寄存器、栈切换"><a href="#最终的寄存器、栈切换" class="headerlink" title="最终的寄存器、栈切换"></a>最终的寄存器、栈切换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// in file: arch\arm64\kernel\entry.S</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Register switch for AArch64. The callee-saved registers need to be saved</span><br><span class="hljs-comment">* and restored. On entry:</span><br><span class="hljs-comment">*   x0 = previous task_struct (must be preserved across the switch)</span><br><span class="hljs-comment">*   x1 = next task_struct</span><br><span class="hljs-comment">* Previous and next are guaranteed not to be the same.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br>SYM_FUNC_START(cpu_switch_to)<br>    movx10, #THREAD_CPU_CONTEXT<br>    addx8, x0, x10<br>    movx9, sp                  <span class="hljs-comment">// 这里将prev的内核栈地址保存到x9寄存器</span><br>    stpx19, x20, [x8], #<span class="hljs-number">16</span><span class="hljs-comment">// store callee-saved registers</span><br>    stpx21, x22, [x8], #<span class="hljs-number">16</span><br>    stpx23, x24, [x8], #<span class="hljs-number">16</span><br>    stpx25, x26, [x8], #<span class="hljs-number">16</span><br>    stpx27, x28, [x8], #<span class="hljs-number">16</span><br>    stpx29, x9, [x8], #<span class="hljs-number">16</span>      <span class="hljs-comment">// 这里将内核栈当前指针保存到x8寄存器的值指示的地址处</span><br>    strlr, [x8]                <span class="hljs-comment">// 这里将lr寄存器的值保存到...</span><br>    addx8, x1, x10<br>    ldpx19, x20, [x8], #<span class="hljs-number">16</span><span class="hljs-comment">// restore callee-saved registers</span><br>    ldpx21, x22, [x8], #<span class="hljs-number">16</span><br>    ldpx23, x24, [x8], #<span class="hljs-number">16</span><br>    ldpx25, x26, [x8], #<span class="hljs-number">16</span><br>    ldpx27, x28, [x8], #<span class="hljs-number">16</span><br>    ldpx29, x9, [x8], #<span class="hljs-number">16</span>      <span class="hljs-comment">// 从这里可以看出，新建任务时，要把其内核栈地址放在其任务结构体成员cpu_context.sp处</span><br>    ldrlr, [x8]                <span class="hljs-comment">// -&gt; 再去看一下新建任务时，sp的赋值情况，就可以探索出内核栈的初始内存分配情况；</span><br>    movsp, x9                  <span class="hljs-comment">// 这里将sp的值更新为待切换任务的内核栈</span><br>    msrsp_el0, x1              <span class="hljs-comment">// 这里将sp_el0的值更新为待切换任务的任务结构体，供后续current()使用</span><br>    ptrauth_keys_install_kernel x1, x8, x9, x10<br>    scs_save x0<br>    scs_load_current<br>    ret                         <span class="hljs-comment">// 这里ret执行正常的借助lr的返回，因此返回到调用cpu_switch_to()的下一条指令</span><br>SYM_FUNC_END(cpu_switch_to)<br>NOKPROBE(cpu_switch_to)<br><br><br><span class="hljs-comment">// in file: arch\arm64\kernel\process.c</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Thread switching.</span><br><span class="hljs-comment">*/</span><br>__notrace_funcgraph __sched<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *__<span class="hljs-title">switch_to</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">prev</span>,</span><br><span class="hljs-class">                <span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">next</span>)</span><br><span class="hljs-class">&#123;</span><br>    ......<br>    <span class="hljs-comment">/* the actual thread switch */</span><br>    last = cpu_switch_to(prev, next);<br><br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="内核栈构建"><a href="#内核栈构建" class="headerlink" title="内核栈构建"></a>内核栈构建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: kernel\fork.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alloc_thread_stack_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-type">int</span> node)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *<span class="hljs-built_in">stack</span>;<br><span class="hljs-built_in">stack</span> = kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);<br><span class="hljs-built_in">stack</span> = kasan_reset_tag(<span class="hljs-built_in">stack</span>);<br>tsk-&gt;<span class="hljs-built_in">stack</span> = <span class="hljs-built_in">stack</span>;                 <span class="hljs-comment">// 这里申请内核栈，并将地址赋给任务结构体的stack指针</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span> ? <span class="hljs-number">0</span> : -ENOMEM;<br>&#125;<br><br><span class="hljs-comment">// in file: arch\arm64\include\asm\processor.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> task_pt_regs(p) \</span><br><span class="hljs-meta">((struct pt_regs *)(THREAD_SIZE + task_stack_page(p)) - 1)</span><br><br><span class="hljs-comment">// in file: include\linux\sched\task_stack.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> task_stack_page(task)((void *)(task)-&gt;stack)</span><br><br><span class="hljs-comment">// in file: arch\arm64\kernel\process.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">copy_thread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *p, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> kernel_clone_args *args)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span> *<span class="hljs-title">childregs</span> =</span> task_pt_regs(p);<br>    <span class="hljs-built_in">memset</span>(&amp;p-&gt;thread.cpu_context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> cpu_context));<br><br>    ...<br><br>p-&gt;thread.cpu_context.pc = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ret_from_fork;<br>p-&gt;thread.cpu_context.sp = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)childregs;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>仅考虑栈向低地址增长</strong>；结合前面两个宏可以知道：<ul><li>tsk-&gt;stack 指向申请的内核栈空间的起始地址【低地址】</li><li>childregs 指向该内核栈空间的最高地址 - sizeof(struct pt_regs)</li><li><code>p-&gt;thread.cpu_context.sp = (unsigned long)childregs</code>这一行就使得新创建任务的内核栈地址处在内核栈空间的高位，且其上方有一个(struct pt_regs)空间，用于存储用户上下文</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-中断处理初期汇编</title>
    <link href="/2024/07/23/Linux-aarch64-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%88%9D%E6%9C%9F%E6%B1%87%E7%BC%96/"/>
    <url>/2024/07/23/Linux-aarch64-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%88%9D%E6%9C%9F%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h2 id="中断处理初期汇编码-dup2分析"><a href="#中断处理初期汇编码-dup2分析" class="headerlink" title="中断处理初期汇编码&amp;dup2分析"></a>中断处理初期汇编码&amp;dup2分析</h2><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul><li><a href="https://www.cnblogs.com/niezhongle/p/11088658.html">ARM-GNU常用汇编伪指令</a></li><li><a href="https://blog.csdn.net/jasonactions/article/details/115689462">ARM64底层中断处理</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>kernel_ventry : el 0 64 sync<ul><li>el0t_64_sync<ul><li>kernel_entry \el -&gt; 保存异常处理的现场[x0-29, lr, sp(sp_el0&#x2F;1), pc(elr_el1), pstate(spsr_el1)]到当前sp<code>sp_el1，即当前task的内核栈</code>指向的地址处。因此，可以知道 -&gt; 在进行任务切换时，内核应该会把sp_el0的值设置为待切换到的task的内核栈地址。此外，这里还会使用sp_el0存储当前用户态任务的task_struct数据的地址，供get_current()使用<ul><li>el0t_64_sync_handler(struct pt_regs* regs), 这里的参数就使用当前的sp+sizeof(pt_regs)了</li></ul></li></ul></li></ul></li></ul><h3 id="Linux-dup2-的实现中，current返回的为什么是task-struct"><a href="#Linux-dup2-的实现中，current返回的为什么是task-struct" class="headerlink" title="Linux dup2()的实现中，current返回的为什么是task_struct?"></a>Linux dup2()的实现中，current返回的为什么是task_struct?</h3><ul><li>根据下面的分析可知<ul><li><p>异常发生时，在第一阶段的处理<code>macro: kernel_entry</code>中，将当前用户态任务结构体的地址保存到了sp_el0寄存器中</p></li><li><p>根据之后的分析可知：dup2的作用为：把当前进程文件描述符表中oldfd的文件表项指针复制到newfd所在的文件描述符表项</p></li></ul></li></ul><ul><li>相关代码  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE2(dup2, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, oldfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, newfd)<br>&#123;<br>    <span class="hljs-keyword">if</span> (unlikely(newfd == oldfd)) &#123; <span class="hljs-comment">/* corner case */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span> =</span> current-&gt;files;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>        <span class="hljs-type">int</span> retval = oldfd;<br><br>        rcu_read_lock();<br>        f = __fget_files_rcu(files, oldfd, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (!f)<br>            retval = -EBADF;<br>        rcu_read_unlock();<br>        <span class="hljs-keyword">if</span> (f)<br>            fput(f);<br>        <span class="hljs-keyword">return</span> retval;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ksys_dup3(oldfd, newfd, <span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* We don&#x27;t use read_sysreg() as we want the compiler to cache the value where</span><br><span class="hljs-comment">* possible.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-keyword">struct</span> task_struct *<span class="hljs-title function_">get_current</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sp_el0;<br>    <span class="hljs-comment">// 这里使用mrs寄存器读sp_el0，它的当前值为什么指向了被中断的task?</span><br>    <span class="hljs-comment">// 按照目前的理解：sp_el0为用户态的栈指针，是在变化的；而对应的task_struct的地址应该是一个确定的值！</span><br>    <span class="hljs-comment">// 两者是怎么对应起来的？</span><br>    <span class="hljs-keyword">asm</span> (<span class="hljs-string">&quot;mrs %0, sp_el0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (sp_el0));<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> task_struct *)sp_el0;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> current get_current()</span><br></code></pre></td></tr></table></figure></li><li>疑惑探索<ul><li><p>.req 汇编伪指令</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">/* GPRs used by entry code */<br>tsk.reqx28// current thread_info<br>// 伪汇编：name .req register_name -&gt; 为寄存器定义一个别名<br></code></pre></td></tr></table></figure></li><li><p>stp指令：stp reg1, reg2, ptr_: 将寄存器reg1, reg2的值存储到ptr_指示的地址中</p></li><li><p>ldr_this_cpu 汇编宏: \arch\arm64\include\asm\assembler.h<br>  作用为加载percpu的变量值到dst</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">/*<br>* @dst: Result of READ_ONCE(per_cpu(sym, smp_processor_id()))<br>* @sym: The name of the per-cpu variable<br>* @tmp: scratch register<br>*/<br>.macro ldr_this_cpu dst, sym, tmp<br>adr_l\dst, \sym<br>get_this_cpu_offset \tmp<br>ldr\dst, [\dst, \tmp]<br>.endm<br></code></pre></td></tr></table></figure></li><li><p>__entry_task: percpu变量，用于记录当前执行的用户task_struct</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* We store our current task in sp_el0, which is clobbered by userspace. Keep a</span><br><span class="hljs-comment">* shadow copy so that we can restore this upon entry from userspace.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* This is *only* for exception entry from EL0, and is not valid until we</span><br><span class="hljs-comment">* __switch_to() a user task.</span><br><span class="hljs-comment">*/</span><br>DEFINE_PER_CPU(<span class="hljs-keyword">struct</span> task_struct *, __entry_task);<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">entry_task_switch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *next)</span><br>&#123;<br>    <span class="hljs-comment">// 这里可以看到，每次切换任务时，都会将该percpu变量的值更新为待切换任务的task_struct地址</span><br>    __this_cpu_write(__entry_task, next);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>pt_regs：软件保护的异常现场结构：arch\arm64\include\asm\ptrace.h</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* This struct defines the way the registers are stored on the stack during an</span><br><span class="hljs-comment">* exception. Note that sizeof(struct pt_regs) has to be a multiple of 16 (for</span><br><span class="hljs-comment">* stack alignment). struct user_pt_regs must form a prefix of struct pt_regs.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_pt_regs</span> <span class="hljs-title">user_regs</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            u64 regs[<span class="hljs-number">31</span>];<br>            u64 sp;<br>            u64 pc;<br>            u64 pstate;<br>        &#125;;<br>    &#125;;<br>    u64 orig_x0;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __AARCH64EB__</span><br>    u32 unused2;<br>    s32 syscallno;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    s32 syscallno;<br>    u32 unused2;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    u64 sdei_ttbr1;<br>    <span class="hljs-comment">/* Only valid when ARM64_HAS_GIC_PRIO_MASKING is enabled. */</span><br>    u64 pmr_save;<br>    u64 stackframe[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">/* Only valid for some EL1 exceptions. */</span><br>    u64 lockdep_hardirqs;<br>    u64 exit_rcu;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>kernel_entry宏解析: 位于el0&#x2F;1t_64_sync&#x2F;irq中</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs asm">.macrokernel_entry, el, regsize = 64<br>.if\el == 0<br>alternative_insn nop, SET_PSTATE_DIT(1), ARM64_HAS_DIT<br>.endif<br>.if\regsize == 32<br>movw0, w0// zero upper 32 bits of x0<br>.endif<br>stpx0, x1, [sp, #16 * 0]   // 从用户态陷入内核时触发el0t_sync/irq，因此当前的sp已经指向了sp_el1<br>stpx2, x3, [sp, #16 * 1]   // 接上，此时sp_el1应该指向当前任务的内核栈：应该有一种机制在任务切换时，将sp_el1设置为待切换任务的内核栈<br>stpx4, x5, [sp, #16 * 2]<br>stpx6, x7, [sp, #16 * 3]<br>stpx8, x9, [sp, #16 * 4]<br>stpx10, x11, [sp, #16 * 5]<br>stpx12, x13, [sp, #16 * 6]<br>stpx14, x15, [sp, #16 * 7]<br>stpx16, x17, [sp, #16 * 8]<br>stpx18, x19, [sp, #16 * 9]<br>stpx20, x21, [sp, #16 * 10]<br>stpx22, x23, [sp, #16 * 11]<br>stpx24, x25, [sp, #16 * 12]<br>stpx26, x27, [sp, #16 * 13]<br>stpx28, x29, [sp, #16 * 14]<br><br>.if\el == 0<br>clear_gp_regs<br>mrsx21, sp_el0                             // 这里获取用户态的栈指针<br>ldr_this_cputsk, __entry_task, x20      // 加载percpu变量，用于记录当前执行的用户task_struct<br>msrsp_el0, tsk                             // 将tsk的值加载到sp_el0，供后续get_current()使用<br>...<br>scs_load_current<br>.else                       // 注意这里.else处理异常发生在内核态的情况<br>addx21, sp, #PT_REGS_SIZE  // 栈没有发生切换，因此栈底直接+保存的pt_regs的大小即可<br>get_current_task tsk        // 获取当前正在执行的任务；直接取sp_el0获取，因为之前一定发生过用户态陷入内核态的操作<br>.endif /* \el == 0 */<br>mrsx22, elr_el1            // 异常发生时，硬件将异常返回地址保存到了elr_elx寄存器中。同步异常：当前地址；异步：next<br>mrsx23, spsr_el1           // 异常发生时，硬件将PSTATE值保存到spsr_elx，用于异常返回时，恢复PE的状态<br>stplr, x21, [sp, #S_LR]    // 对于用户态陷入内核的情况，此时x21保存的是sp_el0，即用户态栈地址。lr保存到x[30], x21保存到sp<br>...<br>stpx22, x23, [sp, #S_PC]   // 保存elr_el1, spsr_el1到内核栈的相应栈帧位置处<br>...<br>/*<br>* Registers that may be useful after this macro is invoked:<br>*<br>* x20 - ICC_PMR_EL1<br>* x21 - aborted SP<br>* x22 - aborted PC<br>* x23 - aborted PSTATE<br>*/<br>.endm<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP学习-MISC</title>
    <link href="/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-MISC/"/>
    <url>/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-MISC/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP学习（misc）"><a href="#TCP学习（misc）" class="headerlink" title="TCP学习（misc）"></a>TCP学习（misc）</h1><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul><li>《TCPIP详解：卷1》</li></ul><h2 id="TCP概览-可靠性"><a href="#TCP概览-可靠性" class="headerlink" title="TCP概览 - 可靠性"></a>TCP概览 - 可靠性</h2><h3 id="应用数据被分割成TCP认为最适合发送的数据块；如何确定合适的数据块长度？【18-4】"><a href="#应用数据被分割成TCP认为最适合发送的数据块；如何确定合适的数据块长度？【18-4】" class="headerlink" title="应用数据被分割成TCP认为最适合发送的数据块；如何确定合适的数据块长度？【18.4】"></a>应用数据被分割成TCP认为最适合发送的数据块；如何确定合适的数据块长度？【18.4】</h3><h3 id="TCP发出一个段后启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；【21章：自适应超时及重传机制】"><a href="#TCP发出一个段后启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；【21章：自适应超时及重传机制】" class="headerlink" title="TCP发出一个段后启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；【21章：自适应超时及重传机制】"></a>TCP<strong>发出一个段后启动一个定时器</strong>，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；【21章：自适应超时及重传机制】</h3><h3 id="延迟确认：收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒【19-3】"><a href="#延迟确认：收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒【19-3】" class="headerlink" title="延迟确认：收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒【19.3】"></a><strong>延迟确认</strong>：收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒【19.3】</h3><ul><li>用处<ul><li>主要为了将该ACK与后续可能需要的数据传送放到一起，减小网络负载【数据捎带ACK】</li><li>绝大多数实现采用的时延为200ms：但是这里的定时器并不是从接收到数据开始定时，而是<code>连接建立之后创建的200ms周期定时器</code></li></ul></li></ul><h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><ul><li>该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去</li><li>可以使用<code>TCPNODELAY</code>选项来关闭Nagle算法</li></ul><h3 id="报文重排【根据TCP中的序列号】"><a href="#报文重排【根据TCP中的序列号】" class="headerlink" title="报文重排【根据TCP中的序列号】"></a>报文重排【根据TCP中的序列号】</h3><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul><li>接收端有接收缓冲区【大小有限】：如果发端发的太快，接收端来不及处理，缓冲区剩余可用空间就会一直减小，直至接收缓冲区满；满了之后，接收端不能再接收新的报文，因为旧的报文还没有处理完，不能进行换出操作；因此需要进行流量控制，以调节发端的发送速度</li><li>窗口大小为字节数；起始于接收端发送报文的确认序号：因为确认序号之前的字节流已经确认收到，可以从接收端的接收缓存中换出</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP学习-3</title>
    <link href="/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-3/"/>
    <url>/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-3/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP学习（三）"><a href="#TCP学习（三）" class="headerlink" title="TCP学习（三）"></a>TCP学习（三）</h1><ul><li>滑动窗口是相对于确认号开始的</li></ul><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><ul><li>核心点：新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作</li><li>拥塞窗口【给发送方使用，cwnd】</li><li>发送方使用拥塞窗口与<strong>通告</strong>窗口的最小值作为发送上限：<ul><li>拥塞窗口是发送方使用的流量控制：大小根据接收到的ACK数量指数增加，会与<strong>延迟确认</strong>冲突嘛？</li><li>通告窗口则是接收方使用的流量控制</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP学习-2</title>
    <link href="/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-2/"/>
    <url>/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-2/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP学习（二）"><a href="#TCP学习（二）" class="headerlink" title="TCP学习（二）"></a>TCP学习（二）</h1><h2 id="连接建立-三次握手-沟通双方的初始序列号"><a href="#连接建立-三次握手-沟通双方的初始序列号" class="headerlink" title="连接建立 - 三次握手 - 沟通双方的初始序列号"></a>连接建立 - 三次握手 - 沟通双方的初始序列号</h2><ul><li>请求端发送SYN段，包含<strong>发端初始序号（ISN-C）</strong>，以及服务器端口，MSS</li><li>服务器通过发送SYN进行响应：包含<strong>收端初始序号(ISN-S)<strong>，ACK被设置为1作为对请求端SYN的确认，</strong>确认序号 &#x3D; ISN-C + 1</strong>， MSS</li><li>请求端发送ACK，响应服务器的SYN：ACK被设置为1作为对服务器SYN的确认，<strong>确认序号 &#x3D; ISN-S + 1</strong></li></ul><p>此外，连接建立的过程还会沟通MSS的具体数值，以避免分片的产生；但是只能沟通收发两端，无法避免链路中间节点的分片行为；此时就需要路径上的MTU发现机制</p><h2 id="连接终止-四次挥手"><a href="#连接终止-四次挥手" class="headerlink" title="连接终止 - 四次挥手"></a>连接终止 - 四次挥手</h2><h3 id="全关闭-主动关闭-被动关闭"><a href="#全关闭-主动关闭-被动关闭" class="headerlink" title="全关闭 - 主动关闭 + 被动关闭"></a>全关闭 - 主动关闭 + 被动关闭</h3><p>发送第一个FIN的一方将执行主动关闭，而另一方执行被动关闭</p><ul><li>A首先发送FIN，包含序列号<code>seq-A</code>；</li><li>B收到该FIN后，返回确认：ACK被设置为1，确认序列号为<code>seq-A + 1</code>;    -&gt; 由TCP协议栈内部逻辑处理进行发送<br>一般地，B会向其应用程序递送一个EOF【文件结束符】，接着B的应用程序就关闭该TCP连接，导致</li><li>B主动发一个FIN，序号为<code>seq-B</code>;</li><li>A收到该FIN后，返回确认：ACK被设置为1，确认序列号为<code>seq-B + 1</code>;    -&gt; 由TCP协议栈内部逻辑处理进行发送</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>可以看到，终止的过程和建立的过程在第一次回复时略有不同：<ul><li>连接时，第一次回复带有SYN信息，用于沟通B端的初始序列号</li><li>终止时，第一次回复仅是简单的回复 -&gt; 是否可能将第二次FIN与第一次ACK进行压缩呢？</li></ul></li></ul><h3 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h3><ul><li>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这就是所谓的半关闭；需要注意，TCP是双向连接的，因此可以只关闭单方向的连接，而发送FIN的一端即主动关闭该方-&gt;对方的数据发送通道，但是对方数据发送-本地数据接收还是正常的</li><li><u>为了使用这个特性</u>，必须为用户提供一个编程接口，且该接口表明：我已经完成了数据传送，因此发送一个文件结束(FIN)给另一端，但我还想接收另一端发来的数据，直到它给我发来文件结束(FIN)</li><li>如果应用程序不调用close而调用<code>shutdown</code>，且第2个参数值为1，则插口的API支持半关闭。然而，大多数的应用程序通过调用<code>close</code>终止两个方向的连接</li></ul><h2 id="建立与终止过程中的状态迁移"><a href="#建立与终止过程中的状态迁移" class="headerlink" title="建立与终止过程中的状态迁移"></a>建立与终止过程中的状态迁移</h2><ul><li><p>参考《TCPIP详解：卷1》18.6节</p></li><li><p>关闭时：</p><ul><li>被动关闭：接收到FIN，则进入<code>close_wait</code>状态，等待本地应用程序关闭socket，进而发送FIN进入<code>last_ack</code>状态，等待对端的ACK；接收到ACk后，连接被彻底关闭</li><li>主动关闭：<ul><li>应用进程主动调用<code>close()</code>等关闭连接，首先发送FIN，进入<code>fin_wait_1</code>状态；</li><li>收到对端的ack后，进入<code>fin_wait_2</code>状态；</li><li>之后等待对端发送FIN，进而回复ACK，进入<code>time_wait</code>状态</li><li>2MSL（报文段最大生存时间）后，连接彻底关闭</li></ul></li></ul></li><li><p>2MSL等待状态</p><ul><li>MSL：报文段最大生存时间MSL（Maximum Segment Lifetime）</li><li>该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）</li><li>在连接处于2MSL等待时，任何迟到的报文段将被丢弃</li><li>只有主动关闭连接的一端会进入该状态；而且服务器端，客户端都可以主动关闭连接</li></ul></li><li><p><strong>当有多个连接请求时</strong></p><ul><li>服务器来不及处理这么多连接请求，将会把完成三次握手的连接放到内核中的连接队列中</li><li>如果队列已经满了，则服务器端TCP协议栈将不理会新来的SYN报文，也不会发回RST</li><li>因此后续客户端会重传其SYN，直至与服务器完成连接的建立</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP学习-1</title>
    <link href="/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2024/07/22/TCP%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP学习（一）"><a href="#TCP学习（一）" class="headerlink" title="TCP学习（一）"></a>TCP学习（一）</h1><ul><li><p>TCP只对含有数据的ACK进行确认【发端超时重传】；单独的ACK不会发送不会设置超时定时器</p><ul><li>因此TCP要考虑每个阶段中可能出现的ACK丢失的情况！！！</li></ul></li><li></li></ul><h2 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h2><ul><li><p>通过头部的控制位（6bit）区分不同的报文类型：</p><ul><li>SYN报文：用于建立连接，包含SYN标志    -&gt; <strong>需要占用一个序号</strong>；其中包含<strong>最大报文段长度</strong>信息，且该信息只能出现在SYN中</li><li>ACK报文：用于确认接收到的数据，包含ACK标志    -&gt; 为1时，4Bytes的确认序号字段才有有用；连接一旦建立，该位总是被置为1</li><li>FIN报文：用于结束连接，包含FIN标志    -&gt; <strong>需要占用一个序号</strong>，发端完成发送任务</li><li>RST报文：用于重置连接，包含RST标志</li><li>PSH报文：用于推送数据，包含PSH标志    -&gt; 接收方应尽快把这个报文段交给应用层</li><li>URG报文：用于紧急数据，包含URG标志</li><li>数据报文：包含实际的数据，不包含任何控制位</li></ul></li><li><p>连接建立、终止，超时处理过程中涉及到的报文，大多都是不带数据的报文【控制报文】</p></li><li><p><strong>最大报文段长度（MSS）</strong>信息【首部可选项】，只能出现在SYN中；该信息是沟通双方可以协商确定的；为了不在IP层产生分片，MSS最大为1460（RFC以太网）</p></li></ul><h2 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h2><ul><li>序号：标识从TCP发端向TCP收端发送的数据字节流，它表示在<strong>这个报文段中的的第一个数据字节</strong>。是32bit的无符号数，序号到达2^32-1后又从0开始;<ul><li>那么该条报文数据字段包含的序号范围就是可以计算的了 -&gt; 根据数据负载的长度</li></ul></li></ul><h2 id="分片机制"><a href="#分片机制" class="headerlink" title="分片机制"></a>分片机制</h2><ul><li>注意IP层是有分片机制的<ul><li>IP头部指示总长度的字段占16bits，因此IP报文最大长度为65535Bytes;</li><li>IP<strong>只有针对首部</strong>的校验和</li></ul></li><li>TCP也是有分片机制的：而且一般需要将TCP每帧报文长度控制在IP层MTU范围以内，防止产生IP层分片 -&gt; √<ul><li>TCP报文的长度有限制吗？有长度指示域嘛？ -&gt; 首部没有长度指示位域</li><li>TCP的校验和<strong>覆盖首部和数据</strong>：且收端检测到校验和时，不会确认接收该报文，等待发端触发超时重传</li><li>有IP层分片也可以，只是如果某个IP片丢失后，整个IP报文都会被丢弃，进而导致上层协议重传一整个丢失的报文</li><li>如果使用上层的分片机制，可以将长数据报文分割成多个小的片段；当某一个小的片段丢失后，只需要重传那个丢失的分片报文就可以</li></ul></li></ul><h2 id="IP层路由"><a href="#IP层路由" class="headerlink" title="IP层路由"></a>IP层路由</h2><ul><li>需要注意主机IP地址由网络号，子网号和主机号组成，且主机号不能为0<ul><li>网络号，主要由A，B，C等几类地址而来</li><li>子网号，针对每一个特定的网络号，可以划分为很多子网</li><li>主机号，该子网内的所有真实主机的IP</li></ul></li></ul><h3 id="IP层从某个网络接口接收到报文"><a href="#IP层从某个网络接口接收到报文" class="headerlink" title="IP层从某个网络接口接收到报文"></a>IP层从某个网络接口接收到报文</h3><ul><li>如果该IP报文的目的地址为本机IP地址之一【本机可能有多个IP地址】或者为IP广播地址，则将该IP报文上传给由IP首部协议字段指定的上层协议模块进行处理</li><li>否则，<ul><li>如果机器没有IP路由功能，则将该IP报文丢弃</li><li>如果该机器开启了IP路由功能，则对报文进行转发【类似于本机器发出IP报文】</li></ul></li><li>匹配路由表顺序【IP报文的目的地址与路由表的目的地址字段】：<ul><li>全匹配：</li><li>网段匹配：</li><li>默认条目</li></ul></li><li>如果以上都不能匹配成功，那么数据包就不能被传送：<ul><li>如果该数据报是本机发送的，那么一般IP层会向发送该数据报的上层应用通知：“主机不可达”或者“网络不可达”</li></ul></li></ul><h3 id="路由表内容"><a href="#路由表内容" class="headerlink" title="路由表内容"></a>路由表内容</h3><ul><li>目的IP地址：可以为主机地址，也可以为网络地址【网段地址】</li><li>下一跳路由器【有直接网口相连的主机】的IP地址：</li><li>标志：1. 目的地址是网络地址还是主机地址；2. 下一跳为路由器，还是有直接网口相连的主机</li><li>为数据报的发送指定一个网络接口【卡】，即数据报文将从本机的哪一个网络接口发送出去</li></ul><h2 id="RST报文使用场景"><a href="#RST报文使用场景" class="headerlink" title="RST报文使用场景"></a>RST报文使用场景</h2><ul><li>到不存在端口的连接请求</li><li>异常终止一个连接：可以发送RST而不是FIN来中途释放一个连接</li><li>检测半打开连接</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-Macros</title>
    <link href="/2024/07/22/Linux-Macros/"/>
    <url>/2024/07/22/Linux-Macros/</url>
    
    <content type="html"><![CDATA[<h1 id="常用宏"><a href="#常用宏" class="headerlink" title="常用宏"></a>常用宏</h1><ul><li>WRITE_ONCE &amp;&amp; READ_ONCE<ul><li>从__native_word的定义可以看出，所谓的原子读写并不能保证，只是尽可能地避免</li><li>对一个10字节的数据进行读写，肯定要分成2次以上的内存访问操作</li><li>如果为一个原始类型：char, short, int, long, long long，对其进行读写操作就只产生一次内存访问</li><li>有些需要避免竞态的，需要加锁  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Yes, this permits 64-bit accesses on 32-bit architectures. These will</span><br><span class="hljs-comment">* actually be atomic in some cases (namely Armv7 + LPAE), but for others we</span><br><span class="hljs-comment">* rely on the access being split into 2x32-bit accesses for a 32-bit quantity</span><br><span class="hljs-comment">* (e.g. a virtual address) and a strong prevailing wind.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> compiletime_assert_rwonce_type(t)\</span><br><span class="hljs-meta">    compiletime_assert(__native_word(t) || sizeof(t) == sizeof(long long),\</span><br><span class="hljs-meta">        <span class="hljs-string">&quot;Unsupported access size for &#123;READ,WRITE&#125;_ONCE().&quot;</span>)</span><br><br><span class="hljs-comment">/* Is this type a native word size -- useful for atomic operations */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __native_word(t) \</span><br><span class="hljs-meta">    (sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \</span><br><span class="hljs-meta">    sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Use __READ_ONCE() instead of READ_ONCE() if you do not require any</span><br><span class="hljs-comment">* atomicity. Note that this may result in tears!</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __READ_ONCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __READ_ONCE(x)(*(const volatile __unqual_scalar_typeof(x) *)&amp;(x))</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_ONCE(x)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    compiletime_assert_rwonce_type(x);\</span><br><span class="hljs-meta">    __READ_ONCE(x);\</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __WRITE_ONCE(x, val)\</span><br><span class="hljs-meta">do &#123;\</span><br><span class="hljs-meta">    *(volatile typeof(x) *)&amp;(x) = (val);\</span><br><span class="hljs-meta">&#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITE_ONCE(x, val)\</span><br><span class="hljs-meta">do &#123;\</span><br><span class="hljs-meta">    compiletime_assert_rwonce_type(x);\</span><br><span class="hljs-meta">    __WRITE_ONCE(x, val);\</span><br><span class="hljs-meta">&#125; while (0)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="标量类型（scalar-type）"><a href="#标量类型（scalar-type）" class="headerlink" title="标量类型（scalar type）"></a>标量类型（scalar type）</h1><ul><li>指那些不能被分解成更小的部分的数据类型，如整型（如 int、long、short 等）、浮点型（如 float、double 等）和字符型（如 char）。标量类型与复合类型相对，复合类型是由多个标量类型或其他复合类型组合而成的数据类型，如结构体（struct）、联合体（union）和数组。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving</span><br><span class="hljs-comment">*       non-scalar types unchanged.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Prefer C11 _Generic for better compile-times and simpler code. Note: &#x27;char&#x27;</span><br><span class="hljs-comment">* is not type-compatible with &#x27;signed char&#x27;, and we define a separate case.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __scalar_type_to_expr_cases(type)\</span><br><span class="hljs-meta">        unsigned type:(unsigned type)0,\</span><br><span class="hljs-meta">        signed type:(signed type)0</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __unqual_scalar_typeof(x) typeof(\</span><br><span class="hljs-meta">        _Generic((x),\</span><br><span class="hljs-meta">            char:(char)0,\</span><br><span class="hljs-meta">            __scalar_type_to_expr_cases(char),\</span><br><span class="hljs-meta">            __scalar_type_to_expr_cases(short),\</span><br><span class="hljs-meta">            __scalar_type_to_expr_cases(int),\</span><br><span class="hljs-meta">            __scalar_type_to_expr_cases(long),\</span><br><span class="hljs-meta">            __scalar_type_to_expr_cases(long long),\</span><br><span class="hljs-meta">            default: (x)))</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="sparse-语义检查工具"><a href="#sparse-语义检查工具" class="headerlink" title="sparse 语义检查工具"></a>sparse 语义检查工具</h2><p>这里描述的宏都是在使用sparse工具时才会定义&#x2F;被sparse识别的：</p><ul><li><p><code># define __rcu__attribute__((noderef, address_space(__rcu)))</code></p><ul><li>noderef: 意味着这是一个指针，且后续不能对其直接解引用；否则sparse检查器会报错</li><li>address_space: 这个地址在rcu地址空间中</li></ul></li><li><p><code>#define __safe __attribute__(safe)</code></p><ul><li>不用检查参数是否为控，可以直接取成员</li></ul></li><li><p><code>#define __force __attribute__(force)</code></p><ul><li>表示所定义的变量是可以做强制类型转换的</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>APUE-Learning-高级IO</title>
    <link href="/2024/07/22/APUE-Learning-%E9%AB%98%E7%BA%A7IO/"/>
    <url>/2024/07/22/APUE-Learning-%E9%AB%98%E7%BA%A7IO/</url>
    
    <content type="html"><![CDATA[<h1 id="高级I-O"><a href="#高级I-O" class="headerlink" title="高级I&#x2F;O"></a>高级I&#x2F;O</h1><ul><li>I&#x2F;O多路复用<ul><li>有多个描述符，数据可能在任一个描述符上到达（可用），但是事先无法知道究竟是哪一个描述符</li><li>不能对任意一个描述符进行阻塞读操作，因为数据可能已经在其它描述符上到达<ul><li>使用两个或多个进程&#x2F;线程分别处理一个描述符，但是带来资源开销、同步处理的问题</li><li>不使用阻塞I&#x2F;O：对所有描述符进行轮询处理</li><li>异步I&#x2F;O+信号：信号数量有限，无法与描述符一一对应</li></ul></li><li>I&#x2F;O多路复用：实现准备一张描述符表，内核会在表中任一个描述符准备好时，通知进程并告知哪些文件描述符已经准备好了<ul><li>有三个select，poll，epoll；均会阻塞线程，直到有可用的描述符时才会返回</li><li>描述符集：fd_set</li><li>select: 三组描述符集作为参数（可读、可写、异常条件）</li><li>poll: pollfd数组：包含描述符编号、感兴趣的事件</li></ul></li></ul></li></ul><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><ul><li><p>无名管道</p><ul><li>只能在两个相关的进程间使用；即两个fd通过父进程创建，之后在子进程中使用</li></ul></li><li><p>有名管道（FIFO）</p><ul><li>不相关的进程间也能通信</li><li>它是一种文件类型，它的文件名(路径名)存在于文件系统中</li><li><code>int mkfifo(const char* path, mode_t mode);</code>，返回值为文件描述符</li></ul></li><li><p>三个相似的IPC机制</p><ul><li>使用键（key_t）来标识</li><li><code>key_t ftok(const char* path, int id)</code>，根据一个路径名和ID，创建一个key</li></ul><ul><li>消息队列（1）<ul><li><code>msgget(key_t, int)</code>，【创建或打开已有的】返回非负队列ID，供后续发送、接收、控制使用</li></ul></li><li>信号量（2）<ul><li><code>semget(key_t, int)</code></li><li>删除是立即生效的；会导致其它使用该信号量的程序产生错误</li></ul></li><li>共享内存（3）<ul><li><code>shmget(key_t, int)</code></li></ul></li></ul></li><li><p>POSIX 信号量</p><ul><li>更高性能</li><li>接口更简单</li><li>添加引用计数，删除操作会在最后一次引用结束时删除信号量</li></ul><ul><li><code>sem_t* sem_open(const char* name, int flag, ...)</code>，创建新的或打开一个已有的信号量</li><li><code>sem_close()</code>操作并不会将信号量值减1</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>APUE-Learning-线程</title>
    <link href="/2024/07/22/APUE-Learning-%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/07/22/APUE-Learning-%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul><li><p>每个线程都包含有表示执行环境所必须的信息</p><ul><li>进程中标识线程的线程ID。pthread_t，<strong>所有可移植的操作系统实现不能把它作为整数处理，因此必须提供一个函数来对两个线程ID进行比较</strong></li><li>一组寄存器值</li><li>栈</li><li>调度优先级和调度策略</li><li>信号屏蔽字 -&gt; 继承于创建它的线程</li><li>errno变量</li><li>线程私有数据</li></ul></li><li><p>POSIX线程的功能测试宏是**_POSIX_THREADS**，可以用它在编译时确定是否支持posix线程 </p></li><li><p>线程终止</p><ul><li>影响整个进程<ul><li>如果进程中的任意线程调用了exit, _Exit, _exit，那么整个进程就会终止</li><li>如果信号的默认行为是终止进程，那么发送到线程的信号就会终止整个进程</li></ul></li><li>单个线程退出<ul><li>从线程执行函数中退出</li><li>被同一进程中的其他线程终止：pthread_cancel()，仅提出终止线程的请求，不等待线程终止</li><li>线程调用pthread_exit()</li></ul></li><li>pthread_join() -&gt; 传参时遇到指针一定注意：内存应该处在栈上？还是堆上？所有者是哪个线程？<ul><li>调用线程一直阻塞，直到指定的线程调用pthread_exit()、从执行函数中返回、或者被其他线程取消</li></ul></li></ul></li><li><p>线程的分离状态</p><ul><li>已被分离的线程在终止时，其底层存储资源可以立即被收回</li><li>线程被分离后不能调用pthread_join()等待它终止，会产生未定义行为</li><li>可以调用pthread_detach()分离线程</li><li>在pthread_create时控制传入的线程属性参数，可以直接创建已处于分离状态的线程</li></ul></li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li>程序使用变量的方式也会引起竞争，导致不一致的情况发生。例如，对某个变量+1，然后基于这个值做出某种决定。因为增量操作步骤和这个决定步骤的组合不是原子操作，所以就给不一致情况的出现提供了可能</li></ul><h3 id="互斥量-pthread-mutex-t"><a href="#互斥量-pthread-mutex-t" class="headerlink" title="互斥量 -&gt; pthread_mutex_t"></a>互斥量 -&gt; pthread_mutex_t</h3><ul><li><p>pthread_mutex_lock -&gt; 可能会阻塞</p></li><li><p>pthread_mutex_trylock -&gt; 不会阻塞；不能加锁时返回EBUSY</p></li><li><p>如果有多个线程阻塞在获取锁的状态；当锁被释放时，所有线程都被唤醒？，最终只有一个线程能获取锁，其他线程仍进入阻塞状态?</p><ul><li>这种“惊群现象”会发生嘛？即线程何时被唤醒？</li><li>如果等待的线程数&gt;1，内核可以只唤醒一个线程，避免惊群 &lt;- 这个是futex2（fast user mutex）【Documentation\translations\zh_CN\userspace-api\futex2.rst】<ul><li>翻看pthread_mutex_unlock时，传给futex_wake的参数中nr &#x3D; 1，即只唤醒一个等待的线程</li><li>翻看Linux-futex系统调用的实现，看到其先遍历futex的等待队列，把待唤醒的线程结构加入wake_q【超过nr后，不再添加】，之后调用<code>wake_up_q</code>对wake_q里面的线程进行统一的唤醒：-&gt; 线程使用task_struct结构表示，其中有个成员<code>struct wake_q_nodewake_q;</code>，辅助进行这些步骤</li></ul></li><li>因此mutex不会产生惊群现象</li><li>值得注意的是：futex簇有很多操作：wait，wake等，但都使用同一个系统调用号，最终在<code>do_futex()</code>统一处理，根据传参提取出（cmd）信息，进行细致的处理</li></ul></li><li><p>可以仔细控制相关互斥量的加锁顺序以避免死锁：</p><ul><li>程序1： A -&gt; B；程序2：B -&gt; A；这种情况下可能会出现1获得A，2获得B，之后A阻塞于获取B，而B阻塞与获取A</li><li>如果所有程序都以A -&gt; B的顺序加锁，那么可以避免相关的死锁</li></ul></li><li><p>当锁比较多，不好仔细控制加锁顺序时，可以采用解除已获取锁，并进入等待，稍后再试的方式来避免死锁</p><ul><li>即使用trylock，如果返回EBUSY，则释放之前已获取的锁，并挂起等待</li></ul></li></ul><h3 id="读写锁-pthread-rwlock-t"><a href="#读写锁-pthread-rwlock-t" class="headerlink" title="读写锁 -&gt; pthread_rwlock_t"></a>读写锁 -&gt; pthread_rwlock_t</h3><ul><li>三种状态：适合于读次数远大于写次数的情况<ul><li>读加锁：后续读加锁的线程可以获得访问；而写加锁的线程被阻塞</li><li>写加锁：后续任意形式的加锁都会被阻塞</li><li>不加锁：-&gt;</li></ul></li></ul><h3 id="条件变量-pthread-cond-t"><a href="#条件变量-pthread-cond-t" class="headerlink" title="条件变量 -&gt; pthread_cond_t"></a>条件变量 -&gt; pthread_cond_t</h3><ul><li>需要配合互斥量一起使用，条件本身由互斥量保护，线程在改变条件状态之前必须首先锁住互斥量</li><li>调用pthread_cond_wait时，要把已经锁住的互斥量传递给该函数。一般在while条件循环判断条件是否成立，在while循环体里面调用cond_wiat()</li><li>两个唤醒操作<ul><li>pthread_cond_signal()，唤醒一个特定的线程</li><li>pthread_cond_broadcast()，唤醒所有等待线程</li></ul></li></ul><h3 id="自旋锁-pthread-spinlock-t"><a href="#自旋锁-pthread-spinlock-t" class="headerlink" title="自旋锁 -&gt; pthread_spinlock_t"></a>自旋锁 -&gt; pthread_spinlock_t</h3><ul><li>不通过挂起使进程阻塞，而是循环判断</li><li>适用于锁持有时间短，短至自旋开销远小于线程切换、重新调度的时间开销</li><li>当前只在极少数情况下适合使用</li></ul><h3 id="屏障-pthread-barrier-t"><a href="#屏障-pthread-barrier-t" class="headerlink" title="屏障 -&gt; pthread_barrier_t"></a>屏障 -&gt; pthread_barrier_t</h3><ul><li>允许每个线程等待，知道所有合作的线程都到达某一点，然后从该点继续执行。pthread_join()就是一种屏障</li><li>参数count指定必须到达屏障的线程数目</li><li>线程主动调用pthread_barrier_wait，表明该线程已完成工作，等待其它线程完成</li></ul><h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><ul><li><p>当互斥量&#x2F;读写锁&#x2F;条件变量&#x2F;屏障位于进程共享内存区域，则该互斥量&#x2F;读写锁&#x2F;条件变量&#x2F;屏障可以用于进程间同步</p><ul><li>需要设置属性为进程间共享</li></ul></li><li><p>如果一个函数对多个线程来说是可重入的，就说这个线程是线程安全的</p></li><li><p>同一进程的多个线程如何保持数据的私有性？</p><ul><li>提供了让基于进程的接口适应多线程环境的机制 -&gt; errno<ul><li>一个线程在系统调用中重置errno，也不会影响其它线程对errno的设置</li></ul></li><li>键值与某个地址对应</li></ul></li><li><p>线程取消：pthread_cancel()</p><ul><li>调用pthread_cancel()并不会阻塞等待线程结束</li><li>调用后，目标线程可能还处于运行状态，只有在到达取消点时，它才会检查是否被设置了取消状态  -&gt; <strong>推迟取消模式</strong><ul><li>如果被设置了取消状态，则结束自身的运行</li><li>系统中有很多的cancel point</li></ul></li><li>如果该线程取消属性被设置为：PTHREAD_CANCEL_DISABLE，<ul><li>所有对该线程的取消请求会被保留，但处于挂起状态，即在线程到达取消点时，并不会检查取消状态</li><li>当该线程被再次设置为PTHREAD_CANCEL_ENABLE，在到达取消点时，会检查取消状态【之前设置的取消状态还是有效的】</li></ul></li><li>可以主动调用pthread_testcancel()，由开发人员手动加入取消点</li><li><strong>异步取消模式</strong>：当线程的取消为该种类型时，线程可以在任意时间被取消</li></ul></li><li><p>线程和信号</p><ul><li>每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的</li><li>进程中的信号是递送到单个线程的</li><li>pthread_sigmask()用于设置线程的信号屏蔽字</li><li>sigwait()，线程调用等待一个或多个信号的出现。返回之前，sigwait将从进程中移除处于挂起等待状态的信号</li><li>多个线程在sigwait()调用中因同一个信号而阻塞，那么在信号递送的时候，就只有一个线程可从sigwait()返回</li><li>如果一个信号被设置了sigaction()[即被捕获]，这时由操作系统决定是让sigwait返回，还是激活信号处理程序：只能2选1</li><li>使用pthread_kill()将1个信号发送给线程</li><li>为了避免错误行为，线程在调用sigwait()之前，必须阻塞那些它需要等待的信号。该函数内部会原子地取消即将等待信号集的阻塞状态</li></ul></li><li><p>线程和fork()</p><ul><li>线程调用fork()创建子进程，从父进程继承了每个互斥量、读写锁和条件变量的状态；父进程有多个线程的情况下，子进程中只有一个线程，它是由父进程中调用fork的线程的副本。如果子进程从fork返回以后，不是紧接着调用exec的话，就需要清理锁状态</li><li>但是子进程不知道它占有了哪些锁【这些占有的锁可能是父进程中的其它线程持有的】，因此它无法做细致的清理</li><li>如果fork返回后，紧接着调用exec，就可以避免上述的情况，因为旧的地址空间会被丢弃，所以锁的状态无关紧要</li><li>但如果子进程还要继续进行部分处理工作，就需要重点关注：<ul><li>pthread_atfork，在三个阶段进行辅助清理锁资源<ul><li>父进程调用fork创建子进程之前调用，获取父进程定义的所有锁</li><li>fork创建子进程以后、返回之前在父进程上下文中执行，对前一步获取的所有锁进行解锁</li><li>fork返回之前，在子进程上下文中执行，释放第一步中获取的所有锁</li><li>注意：子进程中的锁和父进程中的锁不是同一把锁？！！！</li></ul></li></ul></li></ul></li><li><p>线程和I&#x2F;O</p><ul><li>pread</li><li>pwrite</li><li>这两个函数对偏移量的设定和数据的读写操作是原子的</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>APUE-Learning-标准IO &amp; 信号</title>
    <link href="/2024/07/22/APUE-Learning-%E6%A0%87%E5%87%86IO-%E4%BF%A1%E5%8F%B7/"/>
    <url>/2024/07/22/APUE-Learning-%E6%A0%87%E5%87%86IO-%E4%BF%A1%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I&#x2F;O"></a>标准I&#x2F;O</h1><h2 id="流与FILE对象"><a href="#流与FILE对象" class="headerlink" title="流与FILE对象"></a>流与FILE对象</h2><ul><li>注意与struct file[打开文件表项]结构的不同</li><li>一个字符可以使用单个(ASCII字符集)或多个(国际字符集)字节表示</li><li>多字节I&#x2F;O函数 (wchar.h)</li><li>标准I&#x2F;O打开文件时，创建了一个流对象，并将其与该文件关联起来</li><li>fopen()打开一个流时，返回一个指向FILE对象的指针</li><li>FILE对象中包含详尽的信息：用于实际I&#x2F;O的文件描述符、指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数、出错标志等</li><li>预定义了三个标准流，使用&lt;stdio.h&gt;中定义的FILE指针，stdin, stdout, stderr</li><li>流和文件的概念是分开的：流即使用FILE表示，文件只能与某个流对应起来</li></ul><h2 id="缓冲类型"><a href="#缓冲类型" class="headerlink" title="缓冲类型"></a>缓冲类型</h2><ul><li><strong>全缓冲</strong>：填满标准I&#x2F;O缓冲区后，才进行实际的I&#x2F;O操作。驻留在磁盘上的文件通常由标准I&#x2F;O实施全缓冲。在一个流上执行第一次I&#x2F;O操作时，相关标准I&#x2F;O函数通常调用malloc函数获得需使用的缓冲区<ul><li>也可调用fflush(file flush)将未填满的缓冲区写到磁盘上</li></ul></li><li><strong>行缓冲</strong>：当在输入&#x2F;输出中遇到换行符时【由于缓冲区长度固定，当缓冲区满时也会执行实际I&#x2F;O操作】，标准I&#x2F;O库执行I&#x2F;O操作。标准输入&#x2F;输出通常为行缓冲</li><li><strong>不带缓冲</strong>：标准错误流通常不带缓冲</li></ul><h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I&#x2F;O"></a>二进制I&#x2F;O</h2><ul><li>指定读写的数据类型长度，及数据个数</li></ul><h1 id="进程流程控制"><a href="#进程流程控制" class="headerlink" title="进程流程控制"></a>进程流程控制</h1><h2 id="setjump-jmp-buf-env"><a href="#setjump-jmp-buf-env" class="headerlink" title="setjump(jmp_buf env)"></a>setjump(jmp_buf env)</h2><ul><li>调用该宏时将当前上下文环境保存再env中，包括栈指针、PC、寄存器等，以便后续longjump使用</li><li>如果该宏直接返回则它的返回值为0</li><li>如果它从后续的longjump()返回，则返回一个非零值</li></ul><h2 id="longjump"><a href="#longjump" class="headerlink" title="longjump()"></a>longjump()</h2><ul><li>使用env中保存的前面某个流程的环境，跳转到该执行流</li></ul><h1 id="信号-异步场景解决方案"><a href="#信号-异步场景解决方案" class="headerlink" title="信号 -&gt; 异步场景解决方案"></a>信号 -&gt; 异步场景解决方案</h1><ul><li>不存在编号为0的信号，kill函数对编号0有特殊的应用</li></ul><h2 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h2><p>初始化时，可以告诉内核在某个信号发生时按下列三种方式之一进行处理：</p><ul><li><strong>忽略</strong>此信号：<strong>SIGKILL</strong>和<strong>SIGSTOP</strong>信号是不能被忽略的。实际应用编程时可以设置忽略吗？ -&gt; 不可以</li><li><strong>捕捉</strong>信号：某种信号发生时，内核调用用户提前注册的回调函数。无法捕捉<strong>SIGKILL</strong>和<strong>SIGSTOP</strong>信号</li><li><strong>默认</strong>动作：大多数信号的默认动作是终止进程</li></ul><h2 id="早期的不可靠信号"><a href="#早期的不可靠信号" class="headerlink" title="早期的不可靠信号"></a>早期的不可靠信号</h2><ul><li>进程每次接收到信号对其进行处理时，随即将该信号动作重置为默认值<ul><li>只得在处理完逻辑后重新设置该信号的信号处理函数</li><li>然而在接收处理到重新设置这段时间内，有可能新的信号产生</li><li>并执行默认动作（有可能是终止程序）</li></ul></li></ul><h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><ul><li>在信号处理函数中调用不可重入函数，其结果是不可预知的</li><li>信号处理函数可以运行在用户态，打断之前执行的用户进程</li></ul><h2 id="可靠信号"><a href="#可靠信号" class="headerlink" title="可靠信号"></a>可靠信号</h2><ul><li><p>信号产生 -&gt;  这段时间内信号是<strong>未决(pending)<strong>的  -&gt;内核在进程结构体中设置标志位（向进程</strong>递送</strong>信号）</p></li><li><p>信号<strong>阻塞</strong>：进程可以设置阻塞某信号，如果该信号的处理方式为默认或者捕获时；当该信号产生时，内核将保持该信号为pending状态，直至进程解除了对该信号的阻塞，或者忽略该信号。于是，进程在信号传递给它之前仍可改变对该信号的动作</p><ul><li>如果解除阻塞之前，该信号产生了多次，如何处理？<ul><li>POSIX允许内核递送该信号一次或多次(排队，且需支持POSIX.1实时扩展)</li><li>此外，内核可能已经有了新的变化</li></ul></li><li>不能阻塞SIGKILL和SIGSTOP信号</li></ul></li><li><p>如果同时有多个待递送的信号，如何处理？</p><ul><li>POSIX.1没有规定递送顺序，但是建议：先递交与进程当前状态有关的信号，如SIGSEGV</li></ul></li><li><p><strong>信号屏蔽字</strong>：每个进程都有一个信号屏蔽字，每一位与一个具体的信号规定。使用数据类型：<code>sigset_t</code></p></li><li><p>信号集：<code>sigset_t</code>，可以表示多个信号</p></li><li><p>sigaction</p><ul><li>sa_mask：在调用通过sigaction()注册的信号处理函数之前，要将sa_mask声明的信号屏蔽字加到进程的信号屏蔽字中；仅当从该信号处理函数返回时再恢复进程的信号屏蔽字</li><li>sa_flags:<ul><li>SA_INTERRUPT：由此信号中断的系统调用不自动重启</li><li>SA_RESTART：此信号中断的系统调用自动重启</li><li>SA_SIGINFO：信号处理函数多了两个形参</li></ul></li></ul></li><li><p>sigsetjump&#x2F;siglongjump -&gt; POSIX规范定义</p><ul><li>在使用sigaction，当执行其注册的信号处理函数时，进程的信号屏蔽字可能已经被修改，如果此时在信号处理函数中使用longjump()改变执行流，那么进程的信号屏蔽字不会恢复</li><li>因此，提供了新的宏用于信号处理的情况下使用</li><li>从这里也可以看出，信号处理函数应该是工作在用户态的，否则不能使用longjump跳转回用户程序</li></ul></li><li><p>信号阻塞与pause</p><ul><li>pasue系统调用会挂起当前进程，直到某个信号产生、被处理并返回，之后该进程被唤醒</li><li>考虑：某信号被阻塞，之后想要等待该信号的发生。因此要先解除阻塞，并且使用pause()</li><li>如果该信号在阻塞期间产生，则其可能在解除阻塞后立即被递送给进程，导致后续的pause()不再被唤醒</li><li>为了解决这个问题，需要原子的修改进程信号屏蔽字并进入等待<ul><li>sigsuspend()函数完成这个原子操作</li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>破除迷雾-重定位</title>
    <link href="/2024/07/22/%E7%A0%B4%E9%99%A4%E8%BF%B7%E9%9B%BE-%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
    <url>/2024/07/22/%E7%A0%B4%E9%99%A4%E8%BF%B7%E9%9B%BE-%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>之前一直不理解重定位表中的条目是如何生成的</li><li>需要为哪些代码，哪些数据创建重定位条目</li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ul><li><p>《深入理解计算机操作系统》7.7节：</p><ul><li>当汇编器生成一个模块时，在遇到对最终位置未知的目标引用时，它就会创建一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用<ul><li>offset:该条目表示的要修改的位置在该节的偏移</li><li>symbol:需要修改引用指向的符号</li><li>type:告知链接器如何对该位置进行修改</li></ul></li></ul></li><li><p>每个重定位条目都表示了一个必须修改的引用处</p></li><li><p>经过这部分描述，可以看出：</p><ul><li>如果当前编译单元引用了外部的函数、变量，那肯定要为其生成一个重定位条目；但是对于当前编译单元中定义的函数、变量呢 ????</li><li>这是因为，后续所有目标文件链接为可执行文件时，需要聚合相同的节为一个段，会改变每个编译单元中代码段、数据段的原本相对位置。如果编译单元中使用相对地址寻址，后续聚合时仍会产生问题！ -&gt; 猜测也需要生成重定位表项</li><li>经过实验发现，在编译某个编译单元时，<strong>也会为当前编译单元中定义的全局变量、函数生成重定位表项</strong>！！！即使最终也是使用相对地址寻址的方式进行！！！</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>程序员的自我修养</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-系统调用-2</title>
    <link href="/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-2/"/>
    <url>/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-2/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux系统调用的处理"><a href="#Linux系统调用的处理" class="headerlink" title="Linux系统调用的处理"></a>Linux系统调用的处理</h2><ul><li>注意本系列以Linux6.9为例</li><li>这里为aarch64</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>dup2() of POSIX interface: defined in glibc</p><ul><li>INLINE_SYSCALL_CALL() -&gt; __INLINE_SYSCALL2() -&gt; INLINE_SYSCALL(): 针对不同的UNIX实现，定义了不同的宏实现<ul><li>for Linux: INLINE_SYSCALL() -&gt; INTERNAL_SYSCALL(): 针对不同的架构，定义了不同的宏实现<ul><li>for aarch64: INTERNAL_SYSCALL_RAW()<ul><li>将系统调用号放在x8寄存器，将调用参数放到x0-x6寄存器中</li><li><code>svc0</code> 触发SVC异常，陷入内核</li></ul></li></ul></li></ul></li></ul></li><li><p>陷入内核后：（SVC异常属于同步异常）</p><ul><li>根据vectors，进入el0，64，sync处理流程<ul><li>执行部分汇编码 -&gt; b(无条件，不返回)跳转到 el0t_64_sync<ul><li>el0t_64_sync (由entry_handler宏定义，汇编标号) -&gt; el0t_64_sync_handler (c函数)<ul><li>el0t_64_sync_handler -&gt; el0_svc -&gt; do_el0_svc<ul><li>do_el0_svc(从x8获取系统调用号) -&gt; el0_svc_common<ul><li>el0_svc_common: 从调用表中拿到Linux定义的系统调用函数__arm64_sym_sys_dup2()<ul><li>进入执行 SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd): in file.c</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="分步梳理"><a href="#分步梳理" class="headerlink" title="分步梳理"></a>分步梳理</h3><ul><li><p>参考《vectors.md》可知，系统调用触发软件中断，为同步异常，因此会进入el0t_64_sync的处理流程</p></li><li><p>必要的汇编 -&gt; el0t_64_sync -&gt; el0t_64_sync_handler</p></li><li><p>el0t_64_sync_handler</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">asmlinkage <span class="hljs-type">void</span> noinstr <span class="hljs-title function_">el0t_64_sync_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esr = read_sysreg(esr_el1);<br><br>    <span class="hljs-keyword">switch</span> (ESR_ELx_EC(esr)) &#123;<br>    <span class="hljs-keyword">case</span> ESR_ELx_EC_SVC64:<br>        el0_svc(regs);          <span class="hljs-comment">// 这里处理 svc 同步异常</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ESR_ELx_EC_DABT_LOW:<br>        el0_da(regs, esr);<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>el0_svc -&gt; do_el0_svc</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> noinstr <span class="hljs-title function_">el0_svc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    enter_from_user_mode(regs);<br>    cortex_a76_erratum_1463225_svc_handler();<br>    fp_user_discard();<br>    local_daif_restore(DAIF_PROCCTX);<br>    do_el0_svc(regs);<br>    exit_to_user_mode(regs);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>do_el0_svc -&gt; el0_svc_common -&gt; invoke_syscall</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_el0_svc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-comment">// 这里从x8中获取调用号; sys_call_table为系统调用表</span><br>    el0_svc_common(regs, regs-&gt;regs[<span class="hljs-number">8</span>], __NR_syscalls, sys_call_table);<br>&#125;<br><br><span class="hljs-comment">// sys_call_table的“创建”, in file: arch\arm64\kernel\sys.c</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Wrappers to pass the pt_regs argument.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __arm64_sys_personality__arm64_sys_arm64_personality</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL(nr, sym)asmlinkage long __arm64_##sym(const struct pt_regs *);</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL(nr, sym)[nr] = __arm64_##sym,</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">syscall_fn_t</span> sys_call_table[__NR_syscalls] = &#123;<br>    [<span class="hljs-number">0</span> ... __NR_syscalls - <span class="hljs-number">1</span>] = __arm64_sys_ni_syscall,<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/unistd.h&gt;</span></span><br>    [<span class="hljs-number">23</span>] = __arm64_sym_sys_dup,     <span class="hljs-comment">// 在《syscall-1.md》的分析中，已经见到了该函数的定义</span><br>    [<span class="hljs-number">24</span>] = __arm64_sym_sys_dup3<br>&#125;;<br><br><span class="hljs-comment">// 上面两个#include &lt;asm/unistd.h&gt;，最终会包含linux\include\uapi\asm-generic\unistd.h 这个重要文件</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_dup 23</span><br>__SYSCALL(__NR_dup, sys_dup)<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_dup3 24</span><br>__SYSCALL(__NR_dup3, sys_dup3)<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR3264_fcntl 25</span><br>__SC_COMP_3264(__NR3264_fcntl, sys_fcntl64, sys_fcntl, compat_sys_fcntl64)<br>...<br></code></pre></td></tr></table></figure></li><li><p>invoke_syscall：从调用表中所引到某个表项，取得syscall_fn_t，调用即可</p><ul><li>对于POSIX标准规范的dup()<ul><li>调用到__arm64_sym_sys_dup()<ul><li>__se_sys_dup()<ul><li>__do_sys_dup()<ul><li>file.c 中 dup 的定义：<code>SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd)</code></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-系统调用-1</title>
    <link href="/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1/"/>
    <url>/2024/07/10/Linux-aarch64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux系统调用定义相关"><a href="#Linux系统调用定义相关" class="headerlink" title="Linux系统调用定义相关"></a>Linux系统调用定义相关</h2><ul><li><p>相关代码： </p><ul><li>for general arch: sys_*name -&gt; aliased to _<em>se_sys</em>*name -&gt; call _<em>do_sys</em>*name to do actual work</li><li>for arm64 arch: _<em>arm64_sys</em>* -&gt; call  _<em>se_sys</em>* -&gt; call _<em>do_sys</em>*name to do actual work</li></ul></li><li><p>因此，实际的系统调用函数为__do_sys_*()</p></li><li><p>asmlinkage：声明函数传参不使用寄存器，而使用栈进行。后续为Linux源码中的系统调用</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">// in file : syscalls.h</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span><br><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span><br><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_METADATA(sname, nb, ...)</span><br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * __MAP - apply a macro to syscall arguments</span><br><span class="hljs-comment">   * __MAP(n, m, t1, a1, t2, a2, ..., tn, an) will expand to</span><br><span class="hljs-comment">   *    m(t1, a1), m(t2, a2), ..., m(tn, an)</span><br><span class="hljs-comment">   * The first argument must be equal to the amount of type/name</span><br><span class="hljs-comment">   * pairs given.  Note that this list of pairs (i.e. the arguments</span><br><span class="hljs-comment">   * of __MAP starting at the third one) is in the same format as</span><br><span class="hljs-comment">   * for SYSCALL_DEFINE&lt;n&gt;/COMPAT_SYSCALL_DEFINE&lt;n&gt;</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP0(m,...)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP1(m,t,a,...) m(t,a)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAP(n,...) __MAP##n(__VA_ARGS__)</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __SC_DECL(t, a)t a</span><br><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)\</span><br><span class="hljs-meta">       SYSCALL_METADATA(sname, x, __VA_ARGS__)\</span><br><span class="hljs-meta">       __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br><br>   <span class="hljs-comment">// in file：arch\arm64\include\asm\syscall_wrapper.h</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)\   <span class="hljs-comment">// arm64定义了自己的__SYSCALL_DEFINEx宏</span></span><br>asmlinkage <span class="hljs-type">long</span> __arm64_sys#<span class="hljs-meta">#name(const struct pt_regs *regs);\</span><br><span class="hljs-meta">ALLOW_ERROR_INJECTION(__arm64_sys##name, ERRNO);\</span><br><span class="hljs-meta">static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\</span><br><span class="hljs-meta">static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span><br><span class="hljs-meta">asmlinkage long __arm64_sys##name(const struct pt_regs *regs)\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">return __se_sys##name(SC_ARM64_REGS_TO_ARGS(x,__VA_ARGS__));\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="hljs-meta">__MAP(x,__SC_TEST,__VA_ARGS__);\</span><br><span class="hljs-meta">__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\</span><br><span class="hljs-meta">return ret;\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       <span class="hljs-comment">// 这一行看着很奇怪，需要结合一个具体的系统调用定义才能看明白</span></span><br><br>   <span class="hljs-comment">// 这里提取x0-x6</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> SC_ARM64_REGS_TO_ARGS(x, ...)\</span><br><span class="hljs-meta">__MAP(x,__SC_ARGS\</span><br><span class="hljs-meta">      ,,regs-&gt;regs[0],,regs-&gt;regs[1],,regs-&gt;regs[2]\</span><br><span class="hljs-meta">      ,,regs-&gt;regs[3],,regs-&gt;regs[4],,regs-&gt;regs[5])</span><br><br>   <span class="hljs-comment">// in file: file.c</span><br>   SYSCALL_DEFINE2(dup2, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, oldfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, newfd)<br>   &#123;<br>       <span class="hljs-keyword">if</span> (unlikely(newfd == oldfd)) &#123; <span class="hljs-comment">/* corner case */</span><br>           <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span> =</span> current-&gt;files;<br>           <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>           <span class="hljs-type">int</span> retval = oldfd;<br><br>           rcu_read_lock();<br>           f = __fget_files_rcu(files, oldfd, <span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">if</span> (!f)<br>               retval = -EBADF;<br>           rcu_read_unlock();<br>           <span class="hljs-keyword">if</span> (f)<br>               fput(f);<br>           <span class="hljs-keyword">return</span> retval;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ksys_dup3(oldfd, newfd, <span class="hljs-number">0</span>);<br>   &#125;<br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * The asmlinkage stub is aliased to a function named __se_sys_*() which</span><br><span class="hljs-comment">   * sign-extends 32-bit ints to longs whenever needed. The actual work is</span><br><span class="hljs-comment">   * done within __do_sys_*().</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __SYSCALL_DEFINEx       <span class="hljs-comment">// 不同架构可能定义了自己的__SYSCALL_DEFINEx宏</span></span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)\</span><br><span class="hljs-meta">       __diag_push();\</span><br><span class="hljs-meta">       __diag_ignore(GCC, 8, <span class="hljs-string">&quot;-Wattribute-alias&quot;</span>,\</span><br><span class="hljs-meta">               <span class="hljs-string">&quot;Type aliasing is used to sanitize syscall arguments&quot;</span>);\</span><br><span class="hljs-meta">       asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\</span><br><span class="hljs-meta">           __attribute__((alias(__stringify(__se_sys##name))));\</span><br><span class="hljs-meta">       ALLOW_ERROR_INJECTION(sys##name, ERRNO);\</span><br><span class="hljs-meta">       static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span><br><span class="hljs-meta">       asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\</span><br><span class="hljs-meta">       asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\</span><br><span class="hljs-meta">       &#123;\</span><br><span class="hljs-meta">           long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="hljs-meta">           __MAP(x,__SC_TEST,__VA_ARGS__);\</span><br><span class="hljs-meta">           __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\</span><br><span class="hljs-meta">           return ret;\</span><br><span class="hljs-meta">       &#125;\</span><br><span class="hljs-meta">       __diag_pop();\</span><br><span class="hljs-meta">       static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __SYSCALL_DEFINEx */</span></span><br></code></pre></td></tr></table></figure></li><li><p>实际使用中会直接调用dup2()，由其触发svc同步异常，最终调用Linux定义的系统调用“服务函数”。其函数原型在相应的头文件[unistd.h]中有声明，但其定义在哪里？</p><ul><li>显然，在Linux中，它直接使用GNU的C库，因此dup2()的定义在GNU的C库源文件中。下载glibc的源码后，可以看到dup2()的定义</li><li>可以看到，对于不同的标准&#x2F;UNIX实现，glibc中也定义了不同的dup2()实现  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: sysdeps/posix/dup2.c</span><br>    <span class="hljs-type">int</span><br>__dup2 (<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> fd2)<br>&#123;<br><span class="hljs-type">int</span> save;<br><br><span class="hljs-keyword">if</span> (fd2 &lt; <span class="hljs-number">0</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPEN_MAX</span><br>    || fd2 &gt;= OPEN_MAX<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>)<br>    &#123;<br>    __set_errno (EBADF);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-comment">/* Check if FD is kosher.  */</span><br><span class="hljs-keyword">if</span> (fcntl (fd, F_GETFL) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">if</span> (fd == fd2)<br>    <span class="hljs-keyword">return</span> fd2;<br><br><span class="hljs-comment">/* This is not atomic.  */</span><br><br>save = errno;<br>(<span class="hljs-type">void</span>) close (fd2);<br>__set_errno (save);<br><br><span class="hljs-keyword">return</span> fcntl (fd, F_DUPFD, fd2);<br>&#125;<br>libc_hidden_def (__dup2)<br>weak_alias (__dup2, dup2)<br><br><span class="hljs-comment">// in file: sysdeps/unix/sysv/linux/dup2.c</span><br><span class="hljs-type">int</span><br>__dup2 (<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> fd2)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NR_dup2</span><br><span class="hljs-keyword">return</span> INLINE_SYSCALL_CALL (dup2, fd, fd2);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-comment">/* For the degenerate case, check if the fd is valid (by trying to</span><br><span class="hljs-comment">    get the file status flags) and return it, or else return EBADF.  */</span><br><span class="hljs-keyword">if</span> (fd == fd2)<br>    <span class="hljs-keyword">return</span> __libc_fcntl (fd, F_GETFL, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : fd;<br><br><span class="hljs-keyword">return</span> INLINE_SYSCALL_CALL (dup3, fd, fd2, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br>libc_hidden_def (__dup2)<br>weak_alias (__dup2, dup2)<br></code></pre></td></tr></table></figure></li><li>INLINE_SYSCALL_CALL 宏展开  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: sysdeps/unix/sysdep.h</span><br><br><span class="hljs-comment">/* Issue a syscall defined by syscall number plus any other argument</span><br><span class="hljs-comment">required.  Any error will be handled using arch defined macros and errno</span><br><span class="hljs-comment">will be set accordingly.</span><br><span class="hljs-comment">It is similar to INLINE_SYSCALL macro, but without the need to pass the</span><br><span class="hljs-comment">expected argument number as second parameter.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INLINE_SYSCALL_CALL(...) \</span><br><span class="hljs-meta">__INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INTERNAL_SYSCALL_DISP(b,...) \</span><br><span class="hljs-meta">__SYSCALL_CONCAT (b,__INTERNAL_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_CONCAT_X(a,b)     a##b</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)</span><br><span class="hljs-comment">// 以上几个宏的作用就是：根据参数个数，展开为宏__INLINE_SYSCALLn()</span><br><br><span class="hljs-comment">// 接着将参数展开，如下所示</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL0(name) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL1(name, a1) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 1, a1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL2(name, a1, a2) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 2, a1, a2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL3(name, a1, a2, a3) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 3, a1, a2, a3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL4(name, a1, a2, a3, a4) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 4, a1, a2, a3, a4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL5(name, a1, a2, a3, a4, a5) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 5, a1, a2, a3, a4, a5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL6(name, a1, a2, a3, a4, a5, a6) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 6, a1, a2, a3, a4, a5, a6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __INLINE_SYSCALL7(name, a1, a2, a3, a4, a5, a6, a7) \</span><br><span class="hljs-meta">INLINE_SYSCALL (name, 7, a1, a2, a3, a4, a5, a6, a7)</span><br><br><span class="hljs-comment">// in file: sysdeps/unix/sysdep.h</span><br><span class="hljs-comment">/* Wrappers around system calls should normally inline the system call code.</span><br><span class="hljs-comment">But sometimes it is not possible or implemented and we use this code.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> INLINE_SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INLINE_SYSCALL(name, nr, args...) __syscall_##name (args)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// in file: sysdeps/unix/sysv/linux/sysdep.h</span><br><span class="hljs-comment">/* Define a macro which expands into the inline wrapper code for a system</span><br><span class="hljs-comment">call.  It sets the errno and returns -1 on a failure, or the syscall</span><br><span class="hljs-comment">return value otherwise.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> INLINE_SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INLINE_SYSCALL(name, nr, args...)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    long int sc_ret = INTERNAL_SYSCALL (name, nr, args);\</span><br><span class="hljs-meta">    __glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (sc_ret))\</span><br><span class="hljs-meta">    ? SYSCALL_ERROR_LABEL (INTERNAL_SYSCALL_ERRNO (sc_ret))\</span><br><span class="hljs-meta">    : sc_ret;\</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-comment">// 宏 INTERNAL_SYSCALL 是专属于**sysv/linux**实现的，而且不同的硬件架构，其具体定义不同</span><br><span class="hljs-comment">// for x86-64, in file: sysdeps/unix/sysv/linux/x86_64/sysdep.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> INTERNAL_SYSCALL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERNAL_SYSCALL(name, nr, args...)\</span><br><span class="hljs-meta">    internal_syscall##nr (SYS_ify (name), args)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> internal_syscall0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> internal_syscall0(number, dummy...)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    unsigned long int resultvar;\</span><br><span class="hljs-meta">    asm volatile (\</span><br><span class="hljs-meta">    <span class="hljs-string">&quot;syscall\n\t&quot;</span>\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;=a&quot;</span> (resultvar)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;0&quot;</span> (number)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;memory&quot;</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="hljs-meta">    (long int) resultvar;\</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-comment">// 这里可以看到，x86_64使用 syscall触发软中断，调用号应该也是放到寄存器中：&quot;0&quot;(number);参数分别放在r9,r8,r10,rdx,rsi,rdi中</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> internal_syscall1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> internal_syscall1(number, arg1)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta">    unsigned long int resultvar;\</span><br><span class="hljs-meta">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="hljs-meta">    register TYPEFY (arg1, _a1) asm (<span class="hljs-string">&quot;rdi&quot;</span>) = __arg1;\</span><br><span class="hljs-meta">    asm volatile (\</span><br><span class="hljs-meta">    <span class="hljs-string">&quot;syscall\n\t&quot;</span>\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;=a&quot;</span> (resultvar)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;0&quot;</span> (number), <span class="hljs-string">&quot;r&quot;</span> (_a1)\</span><br><span class="hljs-meta">    : <span class="hljs-string">&quot;memory&quot;</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="hljs-meta">    (long int) resultvar;\</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-comment">// for aarch64, in file: sysdeps/unix/sysv/linux/aarch64/sysdep.h</span><br><span class="hljs-meta"># <span class="hljs-keyword">undef</span> INTERNAL_SYSCALL</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> INTERNAL_SYSCALL(name, nr, args...)\</span><br><span class="hljs-meta">    INTERNAL_SYSCALL_RAW(SYS_ify(name), nr, args)</span><br><br><span class="hljs-comment">// 这里，SYS_ify将系统调用名，扩展为具体的系统调用号</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> SYS_ify</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_ify(syscall_name)(__NR_##syscall_name)</span><br><br><span class="hljs-comment">// 这里可以看到使用 svc 0 触发软中断，陷入内核，并在x8寄存器中存储系统调用号</span><br><span class="hljs-meta"># <span class="hljs-keyword">undef</span> INTERNAL_SYSCALL_RAW</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> INTERNAL_SYSCALL_RAW(name, nr, args...)\</span><br><span class="hljs-meta">(&#123; long _sys_result;\</span><br><span class="hljs-meta">    &#123;\</span><br><span class="hljs-meta">    LOAD_ARGS_##nr (args)\</span><br><span class="hljs-meta">    register long _x8 asm (<span class="hljs-string">&quot;x8&quot;</span>) = (name);\</span><br><span class="hljs-meta">    asm volatile (<span class="hljs-string">&quot;svc0// syscall &quot;</span> # name     \</span><br><span class="hljs-meta">            : <span class="hljs-string">&quot;=r&quot;</span> (_x0) : <span class="hljs-string">&quot;r&quot;</span>(_x8) ASM_ARGS_##nr : <span class="hljs-string">&quot;memory&quot;</span>);\</span><br><span class="hljs-meta">    _sys_result = _x0;\</span><br><span class="hljs-meta">    &#125;\</span><br><span class="hljs-meta">    _sys_result; &#125;)</span><br><br><span class="hljs-comment">// 可以看到，系统调用使用x0-6这7个寄存器进行参数传递</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> LOAD_ARGS_0()\</span><br><span class="hljs-meta">register long _x0 asm (<span class="hljs-string">&quot;x0&quot;</span>);</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> LOAD_ARGS_1(x0)\</span><br><span class="hljs-meta">long _x0tmp = (long) (x0);\</span><br><span class="hljs-meta">LOAD_ARGS_0 ()\</span><br><span class="hljs-meta">_x0 = _x0tmp;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-中断处理流程</title>
    <link href="/2024/07/10/Linux-aarch64-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/07/10/Linux-aarch64-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="中断处理流程"><a href="#中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>*<br>    *<br>        * </p><h3 id="aarch64"><a href="#aarch64" class="headerlink" title="aarch64"></a>aarch64</h3><ul><li><p>参考《vectors.md》可知，中断响应时，执行部分汇编码[kernel_ventry宏]后，进入<code>el0t_64_irq</code>[in file entry.S，用entry_handler宏定义]，紧接着调用<br><code>el0t_64_irq_handler</code>[in file: entry-common.c]，进行后续的处理</p></li><li><p>el0t_64_irq_handler -&gt; __el0_irq_handler_common -&gt; el0_interrupt(regs, handle_arch_irq);</p><ul><li><p>这里要注意：<code>handle_arch_irq</code>是一个全局的变量，定义在&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;irq.c文件中</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*handle_arch_irq)(<span class="hljs-keyword">struct</span> pt_regs *) __ro_after_init = default_handle_irq;     <span class="hljs-comment">// __ro_after_init 是编译器提供的属性</span><br><span class="hljs-type">void</span> (*handle_arch_fiq)(<span class="hljs-keyword">struct</span> pt_regs *) __ro_after_init = default_handle_fiq;<br><br><span class="hljs-type">int</span> __init <span class="hljs-title function_">set_handle_irq</span><span class="hljs-params">(<span class="hljs-type">void</span> (*handle_irq)(<span class="hljs-keyword">struct</span> pt_regs *))</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (handle_arch_irq != default_handle_irq)<br>        <span class="hljs-keyword">return</span> -EBUSY;<br><br>    handle_arch_irq = handle_irq;<br>    pr_info(<span class="hljs-string">&quot;Root IRQ handler: %ps\n&quot;</span>, handle_irq);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结合<code>__init set_handle_irq</code>可知，在系统启动阶段，irqchip的驱动会调用set_handle_irq，根据使用的中断控制器，将handle_arch_irq设置为对应的处理函数</p></li><li><p>对应的中断处理函数有：gic_handel_irq -&gt; GIC控制器</p></li></ul></li><li><p>gic_handle_irq</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: drivers/irqchip/irq-gic-v3.c</span><br><span class="hljs-type">static</span> asmlinkage <span class="hljs-type">void</span> __exception_irq_entry <span class="hljs-title function_">gic_handle_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (unlikely(gic_supports_nmi() &amp;&amp; !interrupts_enabled(regs)))<br>        __gic_handle_irq_from_irqsoff(regs);<br>    <span class="hljs-keyword">else</span><br>        __gic_handle_irq_from_irqson(regs);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>如果不是NMI中断，则__gic_handle_irq_from_irqson -&gt; __gic_handle_irq -&gt; generic_handle_domain_irq. 注意这里的irqnr为从相应寄存器[iar]读出的硬件中断号</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __gic_handle_irq(u32 irqnr, <span class="hljs-keyword">struct</span> pt_regs *regs)<br>&#123;<br>    <span class="hljs-keyword">if</span> (gic_irqnr_is_special(irqnr))<br>        <span class="hljs-keyword">return</span>;<br><br>    gic_complete_ack(irqnr);<br><br>    <span class="hljs-keyword">if</span> (generic_handle_domain_irq(gic_data.domain, irqnr)) &#123;<br>        WARN_ONCE(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;Unexpected interrupt (irqnr %u)\n&quot;</span>, irqnr);<br>        gic_deactivate_unhandled(irqnr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>generic_handle_domain_irq : irqdomain 管理hwirq 到 Linux irqnr的映射，有四种映射类型[Documentation\translations\zh_CN\core-api\irq\irq-domain.rst]</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in file: /kernel/irq/irqdesc.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">generic_handle_domain_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_domain *domain, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hwirq)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> handle_irq_desc(irq_resolve_mapping(domain, hwirq));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>handle_irq_desc</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">handle_irq_desc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_desc *desc)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_data</span> *<span class="hljs-title">data</span>;</span><br><br>    <span class="hljs-keyword">if</span> (!desc)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    data = irq_desc_get_irq_data(desc);<br>    <span class="hljs-keyword">if</span> (WARN_ON_ONCE(!in_hardirq() &amp;&amp; handle_enforce_irqctx(data)))<br>        <span class="hljs-keyword">return</span> -EPERM;<br><br>    generic_handle_irq_desc(desc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>generic_handle_irq_desc：根据描述符中的内容，执行相应的回调</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">generic_handle_irq_desc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> irq_desc *desc)</span><br>&#123;<br>    desc-&gt;handle_irq(desc);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux-aarch64-向量表</title>
    <link href="/2024/07/10/Linux-aarch64-%E5%90%91%E9%87%8F%E8%A1%A8/"/>
    <url>/2024/07/10/Linux-aarch64-%E5%90%91%E9%87%8F%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="arm64-aarch64-的中断入口"><a href="#arm64-aarch64-的中断入口" class="headerlink" title="arm64(aarch64)的中断入口"></a>arm64(aarch64)的中断入口</h1><ul><li><p>总结</p><ul><li>部分汇编码，由宏kernel_ventry定义</li><li>el0t_64_irq</li><li>el0t_64_irq_handler</li><li>ret_to_user&#x2F;kernel</li></ul></li><li><p>相关两个宏定义：下面 \el，对宏参数展开</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs asm">    .macro entry_handler el:req, ht:req, regsize:req, label:req<br>SYM_CODE_START_LOCAL(el\el\ht\()_\regsize\()_\label)<br>    kernel_entry \el, \regsize<br>    movx0, sp<br>    blel\el\ht\()_\regsize\()_\label\()_handler      // 这里先调用el0t_64_irq_handler[在entry-common.c中定义]，bl是带返回的跳转[lr存储返回地址]<br>    .if \el == 0<br>    bret_to_user                                    // 返回用户空间<br>    .else<br>    bret_to_kernel                                  // 返回内核空间<br>    .endif<br>SYM_CODE_END(el\el\ht\()_\regsize\()_\label)<br>    .endm<br><br>// 这里使用上面的宏，定义了不同等级的异常入口：例如，el0t_64_irq， el0t_32_sync<br>/*<br>* Early exception handlers<br>*/<br>    entry_handler1, t, 64, sync<br>    entry_handler1, t, 64, irq<br>    entry_handler1, t, 64, fiq<br>    entry_handler1, t, 64, error<br><br>    entry_handler1, h, 64, sync<br>    entry_handler1, h, 64, irq<br>    entry_handler1, h, 64, fiq<br>    entry_handler1, h, 64, error<br><br>    entry_handler0, t, 64, sync<br>    entry_handler0, t, 64, irq<br>    entry_handler0, t, 64, fiq<br>    entry_handler0, t, 64, error<br><br>    entry_handler0, t, 32, sync<br>    entry_handler0, t, 32, irq<br>    entry_handler0, t, 32, fiq<br>    entry_handler0, t, 32, error<br><br>// 下面的宏使用，定义了向量表<br><br>/*<br>* Exception vectors.<br>*/<br>    .pushsection &quot;.entry.text&quot;, &quot;ax&quot;<br><br>    .align11<br>SYM_CODE_START(vectors)<br>    kernel_ventry1, t, 64, sync// Synchronous EL1t<br>    kernel_ventry1, t, 64, irq// IRQ EL1t<br>    kernel_ventry1, t, 64, fiq// FIQ EL1t<br>    kernel_ventry1, t, 64, error// Error EL1t<br><br>    kernel_ventry1, h, 64, sync// Synchronous EL1h<br>    kernel_ventry1, h, 64, irq// IRQ EL1h<br>    kernel_ventry1, h, 64, fiq// FIQ EL1h<br>    kernel_ventry1, h, 64, error// Error EL1h<br><br>    kernel_ventry0, t, 64, sync// Synchronous 64-bit EL0<br>    kernel_ventry0, t, 64, irq// IRQ 64-bit EL0<br>    kernel_ventry0, t, 64, fiq// FIQ 64-bit EL0<br>    kernel_ventry0, t, 64, error// Error 64-bit EL0<br><br>    kernel_ventry0, t, 32, sync// Synchronous 32-bit EL0<br>    kernel_ventry0, t, 32, irq// IRQ 32-bit EL0<br>    kernel_ventry0, t, 32, fiq// FIQ 32-bit EL0<br>    kernel_ventry0, t, 32, error// Error 32-bit EL0<br>SYM_CODE_END(vectors)<br><br>    .macro kernel_ventry, el:req, ht:req, regsize:req, label:req<br>    .align 7<br>.Lventry_start\@:<br>    .if\el == 0<br>    /*<br>    * This must be the first instruction of the EL0 vector entries. It is<br>    * skipped by the trampoline vectors, to trigger the cleanup.<br>    */<br>    b.Lskip_tramp_vectors_cleanup\@<br>    .if\regsize == 64<br>    mrsx30, tpidrro_el0<br>    msrtpidrro_el0, xzr<br>    .else<br>    movx30, xzr<br>    .endif<br>.Lskip_tramp_vectors_cleanup\@:<br>    .endif<br><br>    subsp, sp, #PT_REGS_SIZE<br>#ifdef CONFIG_VMAP_STACK<br>    /*<br>    * Test whether the SP has overflowed, without corrupting a GPR.<br>    * Task and IRQ stacks are aligned so that SP &amp; (1 &lt;&lt; THREAD_SHIFT)<br>    * should always be zero.<br>    */<br>    addsp, sp, x0// sp&#x27; = sp + x0<br>    subx0, sp, x0// x0&#x27; = sp&#x27; - x0 = (sp + x0) - x0 = sp<br>    tbnzx0, #THREAD_SHIFT, 0f<br>    subx0, sp, x0// x0&#x27;&#x27; = sp&#x27; - x0&#x27; = (sp + x0) - sp = x0<br>    subsp, sp, x0// sp&#x27;&#x27; = sp&#x27; - x0 = (sp + x0) - x0 = sp<br>    bel\el\ht\()_\regsize\()_\label                                  // 前面如果成功的话，会跳转到相应的前面定义的elnt_size_name：el0t_64_irq<br><br>0:<br>    ......<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>APUE-Learning-1</title>
    <link href="/2024/07/10/APUE-Learning-1/"/>
    <url>/2024/07/10/APUE-Learning-1/</url>
    
    <content type="html"><![CDATA[<h1 id="UNIX基础知识"><a href="#UNIX基础知识" class="headerlink" title="UNIX基础知识"></a>UNIX基础知识</h1><p>主要介绍了基础的UNIX知识，帮助初学者在UNIX环境下“存活下来”</p><ul><li><p>标准系统函数的返回值，一般来解释如下</p><ul><li><code>&gt;= 0</code> -&gt; 表示程序正常执行</li><li><code>&lt; 0</code> -&gt; 表示程序出错，返回的负数可以表征具体的错误码</li></ul></li><li><p>三个标准“文件描述符”</p><ul><li><code>STDIN_FILENO = 0</code></li><li><code>STDOUT_FILENO = 1</code></li><li><code>STDERR_FILENO = 2</code></li></ul></li><li><p>&lt;unistd.h&gt; : unix std -&gt; 标准头文件，包含了很多UNIX系统服务的函数原型</p><ul><li>有很多<code>unistd.h</code>头文件，用户开发应该使用&lt;unistd.h&gt;，其具体指<code>/usr/inlcude/unistd.h</code></li></ul></li><li><p>不带缓冲的I&#x2F;O <code>VS</code> 标准I&#x2F;O (带缓冲)</p><ul><li>&lt;unistd.h&gt; -&gt; 提供不带缓冲I&#x2F;O的函数原型: read, write, lseek。使用时需要提供<code>缓冲区大小</code>参数</li><li>&lt;stdio.h&gt; -&gt; 提供标准I&#x2F;O的函数原型: scanf, printf。使用时无需担心最优缓冲区大小，因为开发人员无需提供缓冲区大小参数。此外，还定义了标准常量<code>stdin</code>，<code>stdout</code></li></ul></li><li><p>用于进程控制的三个主要函数</p><ul><li>fork：返回值为0，表示处于子进程中；返回值大于0，表示处于父进程中，且返回值为子进程的PID；返回值小于0，fork出错</li><li>exec：有7个变体，统称exec函数</li><li>waitpid：</li><li>fork -&gt; exec函数，创建新进程，执行新的程序</li></ul></li><li><p>头文件组织</p><ul><li>&#x2F;usr&#x2F;include&#x2F;linux, &#x2F;usr&#x2F;inlcude&#x2F;asm* 下的头文件是与Linux内核一起分发的</li><li>&#x2F;usr&#x2F;include&#x2F;sys&#x2F;*.h, &#x2F;usr&#x2F;include&#x2F;bits&#x2F;*.h 下的头文件是与C库一起分发的</li><li><code>LC_ALL=C gcc -v -xc -E /dev/null 2&gt;&amp;1 | sed -ne &#39;/search starts here/,/End of search list/p&#39;</code>用于输出gcc的头文件搜索路径</li></ul></li><li><p>时间相关</p><ul><li><strong>日历时间</strong>：UNIX系统的基本时间服务计算自世界协调时间[1970年1月1日00:00:00]以来经过的秒数，以<code>time_t</code>类型表示，可使用<code>time()</code>获取</li><li><strong>进程时间</strong>[CPU时间]：用以度量进程使用的中央处理器资源，以时钟滴答计算，每秒钟多少个滴答是一种系统配置，使用<code>clock_t</code>类型表示</li></ul><p>  UNIX系统为一个进程维护了3个时间值【进程时间】：</p><ul><li><p>时钟时间[real][墙上时间]，进程运行的时间总量，与系统中同时运行的进程数有关</p></li><li><p>用户CPU时间[user]：执行用户指令所用的时间总量</p></li><li><p>系统CPU时间[sys]：程序执行内核服务的时间总量</p></li><li><p>POSIX扩展规范增加了对多个<strong>系统</strong>时钟的支持，通过<code>clockid_t</code>类型标识不同的POSIX系统时钟</p><ul><li>CLOCK_REALTIME：类型于UNIX系统提供的[real]，但是在系统支持高精度时间值的情况下，可以获得更高精度的时间值</li><li>CLOCK_MONOTONIC：不带负跳数的CLOCK_REALTIME</li><li>CLOCK_PROCESS_CPUTIME_ID：调用函数获取该时间的进程的CPU时间<br>  使用<code>clock_gettime(clockid_t id, struct timespec *tsp)</code>获取不同的系统时钟时间，其中<code> struct timespec</code>采用秒+纳秒的方式来表示时间值</li></ul></li></ul></li></ul><h1 id="UNIX标准及实现"><a href="#UNIX标准及实现" class="headerlink" title="UNIX标准及实现"></a>UNIX标准及实现</h1><ul><li>相关的两个标准<ul><li>ISO C</li><li>IEEE POSIX -&gt; 不区分接口是系统调用还是库函数，统称为函数</li><li>这些标准规范了符号标准的UNIX操作系统必须提供的接口。当然，操作系统要发挥作用，还要有其一般的通用功能。因此可以说，<u>标准定义了任一实际系统的子集</u>。</li><li>有些属于UNIX系统必须，但在符合POSIX标准的系统中是可选的功能</li></ul></li><li>限制<ul><li>幻数、常量的值，在不同系统下的值究竟为多少？具体分为如下两种类型：<ul><li>编译时限制（例如，短整型的最大值是多少？）可在头文件中定义</li><li>运行时限制（例如，文件名最多能有多少个字符？），要求进程调用一个相关的函数获取具体的限制值</li><li>然而有些限制在一个给定的UNIX实现中可能是固定的，而在另一个UNIX实现中则可能是变动的</li></ul></li><li>为了解决这类问题，提供了以下三种限制：<ul><li>编译时限制（头文件）</li><li>与文件或目录无关的运行时限制（<code>sysconf</code>函数）</li><li>与文件或目录有关的运行时限制（<code>pathconf</code>和<code>fpathconf</code>函数）</li><li>如果一个运行时限制在一个给定的UNIX实现上并不改变，则可将其静态地定义在一个头文件中。如果没有将其定义在头文件中，应用程序就必须调用上述的三个<code>conf</code>函数之一以确定其运行时值</li></ul></li><li>ISO C 标准的所有限制都在&lt;limits.h&gt;文件中</li></ul></li></ul><h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><ul><li><p>Unbuffered I&#x2F;O: “不带缓冲”指每个read&#x2F;write都调用内核中的一个系统调用[实际还是会使用内核的缓冲区的]。它们不是ISO C标准，而是POSIX.I的组成部分</p><ul><li>open(), 除非指定<code>O_APPEND</code>flag，否则打开文件时的偏移量都为0，返回值为文件描述符</li><li>lseek(), 显式地为一个已经打开的文件设置偏移量。返回值为添加之后新的文件偏移量。它仅将当前的文件偏移量记录在内核，不会引起任何I&#x2F;O操作<ul><li>相对文件开始的偏移量，只能为+</li><li>相对当前值的偏移量，+-均可</li><li>相对文件结尾的偏移量，+-均可</li></ul></li><li>read(), 返回读到的字节数</li><li>write(), 返回实际写入的字节数</li></ul></li><li><p>多个进程间如何共享文件？【涉及到多进程间资源共享】</p><ul><li>文件描述符表，独属于某个进程，每个描述符表项，包含一个指向某文件表项的指针</li><li>打开文件表，由<strong>内核</strong>维护。每个文件表项包含: 文件状态，<strong>当前文件偏移量</strong>，指向i节点的指针。</li><li>文件系统的i节点表，由<strong>内核</strong>维护。每个打开文件都唯一对应一个i-node节点</li><li>如果有两个进程打开同一个文件：则该文件会有两个文件表项分别对应每个进程；该文件在这两个进程中分别有一个文件描述符；但是该文件只有一个i-node</li></ul></li><li><p>原子操作</p><ul><li>write() 是原子操作的吗？两个进程对该文件同时进行写，如果不加互斥，会出问题吗？</li><li>pwrite() 应该是原子的？</li></ul></li><li><p>文件高级操作</p><ul><li>dup(int fd), dup2(int fd, int fd2)<ul><li>dup() 返回的新描述符一定是当前可用描述符中最小的</li><li>dup2() 可由用户指定fd2为新的描述符；如果fd2已经打开，则先关闭fd2</li><li>这两个函数返回的新描述符与原描述符共享打开文件表项</li></ul></li><li>sync(), fsync(), fdatasync()<ul><li>UNIX系统内核中设有缓冲区，大多数磁盘I&#x2F;O都通过缓冲区进行。例如，当写文件时，内核通常先将数据复制到缓冲区，然后排入队列，晚些时候再写入磁盘，<br>  这种方式称为“延迟写”。</li><li>提供了上述3个函数以保证磁盘上实际文件内容与缓冲区中内容一致</li><li>sync()，将修改过的块缓冲区排入队列，返回。不等待磁盘写操作</li><li>fsync(int fd)，只对由fd指定的文件起作用，且等待实际磁盘I&#x2F;O操作完成</li><li>fdatasync(int fd)，与fsync类型，但是只影响文件数据部分</li></ul></li><li>fcntl(int fd, int cmd, &#x2F;* int arg *&#x2F;)<ul><li>根据cmd的不同，可以提供5大类的功能</li></ul></li><li>ioctl()</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言再学习</title>
    <link href="/2024/07/10/C%E8%AF%AD%E8%A8%80%E5%86%8D%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/10/C%E8%AF%AD%E8%A8%80%E5%86%8D%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="C语言再学习"><a href="#C语言再学习" class="headerlink" title="C语言再学习"></a>C语言再学习</h2><ul><li><p>#incude &lt;&gt; &#x2F; #include “”的区别</p><ul><li>有三个路径需要区分：<ul><li>系统库路径 -&gt; <strong>无需配置</strong>，这个路径已经<u>硬</u>写入了编译器的配置中</li><li>工程定义头文件搜索目录 -&gt; 需要使用编译器提供的参数选项进行配置，例如<code>gcc -I &lt;search_path&gt;</code></li><li>当前目录 -&gt; 无需配置，但是只有使用<code>#include &quot;xxx.h&quot;</code>格式的才会在当前路径下查找</li></ul></li><li>前两种路径都可以使用<code>#inlcude &lt;&gt;</code>进行包含</li></ul></li><li><p>数组与指针变量的区别</p><ul><li>char str[20]; char *ptr_s &#x3D; “abcdefg”;   -&gt; 索引操作：str[5] 与 pstr_s[5]</li><li>str[5]，[汇编层面理解：str表示数组所在的地址]，因此只需要将这个地址加上索引*size，再对新得到的地址进行取值操作即可</li><li>pstr_s[5]，[pstr_s是一个变量，要先取值得到地址值]，之后的操作同上</li><li><strong>作为函数形参</strong>：char *ptr 与 char ptr[]是一样的。这是由于出于性能的考虑，一般把数组传递给函数时，只会传递数组首元素的地址。因此，这两种形参，在函数内部都是得到一个指针。</li></ul></li><li><p>gcc相关编译参数</p><ul><li>-L ：链接时库搜索路径</li><li>-R ：运行时库搜索路径。这个信息会被写入到最终的可执行文件中，并被动态加载其解析使用</li><li>-l : 指定需要参与链接的库</li></ul></li><li><p>little trick -&gt; 静态链接</p><ul><li>gcc -c main.c -lmath -o main  -&gt; 这里源文件出现在库之前</li><li>gcc -lmath -c main.c -o main  -&gt; 库出现在main之前，此时还没有未定义的符号，因此不从库中提取任何符号；因此在链接时可能会报“符号未定义”的错误</li></ul></li><li><p>局部变量及初始化</p><ul><li>不会出现在最终的可执行文件中，运行时在栈上创建</li><li>有明确的代码进行栈空间的开辟，且<strong>初始值会作为指令的操作数</strong>出现在代码段中</li></ul></li><li><p>常见错误：</p><ul><li>总线错误：一般都是由于未对齐的读或写引起</li><li>段错误：通常是由于解引用一个未初始化或非法的地址值引起</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计规范</title>
    <link href="/2024/07/10/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <url>/2024/07/10/%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a><a href="http://10.1.14.75/team/compass/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">设计规范</a></h2><ul><li><p>使用指定长度的数据类型，需编译器提供&lt;stdint.h&gt;头文件，或者已知硬件芯片字长的情况下自定义</p></li><li><p>在结构体中，人为添加pad以实现结构体内成员的<strong>自然对齐</strong>，不要依赖编译器进行</p></li><li><p>CPU间通信的数据结构中，不能包含enum类型的变量</p></li><li><p>静态数据表应使用const进行修饰</p><ul><li>一方面，const修饰的通常保存在flash中，节省RAM空间</li><li>其次，防止数据被篡改</li></ul></li><li><p>指针对齐考虑 【这个问题之前还真没有考虑过！！！】</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> buf[<span class="hljs-number">4</span>];             <span class="hljs-comment">// -&gt; 这里buf是1字节对齐的，即buf的值可能为0xc0080001</span><br><span class="hljs-type">uint32_t</span>* ptr_a = buf;      <span class="hljs-comment">// -&gt; 这里ptr_a指向变量类型为4字节对齐，因此ptr_a要求是4字节对齐的。因此，这样赋值可能会出现问题</span><br><br></code></pre></td></tr></table></figure><ul><li>当指针指向的内存地址不能满足指针数据类型的对齐要求时，一般情况下，指针会<strong>向下</strong>做对齐操作。例如指针要求4字节对齐，而指向的地址为0x80000002，指针会自动向下做对齐指向0x80000000地址。</li><li>因此，遇到将小数据类型的地址赋值给大数据类型的指针变量时，要意识到可能会有这种问题的存在</li><li>尤其在回调接口中，为了通用性，一般使用<code>uint8_t*</code>类型的指针，针对用户提供的该指针，后续进行类型强转时，需要先判断其是否符合类型指针对齐的要求，再进行强转操作</li></ul></li><li><p>函数调用时提供函数原型很重要，尤其对于函数返回值；某些情况下，函数形参也很重要，因为涉及到参数入栈</p></li><li><p>独立组件模块：为了提高组件的可移植性，不允许直接使用外部变量，调用外部函数；而是通过回调函数的形式 -&gt; 初始化时，需要向组件注册回调函数，当组件检测到相应场景时，调用相应之前注册的回调函数</p></li><li><p>分层设计：组件与硬件、操作系统等资源相关；将与 <strong>硬件</strong> 、 <strong>操作系统</strong> 等平台相关的代码独立出来，定义成<strong>驱动层</strong>，而与平台无关的代码定义成<strong>核心层</strong>。核心层与驱动层定义一套接口，__接口由核心层定义，驱动来实现__。通过上层应用将驱动层与核心层关联起来，一般采用 <strong>函数指针</strong> 的方式将驱动层与核心关联起来。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CI/CD相关基础</title>
    <link href="/2024/07/10/CI-CD%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/07/10/CI-CD%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="CI-CD相关"><a href="#CI-CD相关" class="headerlink" title="CI&#x2F;CD相关"></a>CI&#x2F;CD相关</h2><ul><li>CI -&gt; 自动化测试<strong>持续集成</strong>， <a href="https://wiki.hikvision.com.cn/pages/viewpage.action?pageId=100687349">参考</a></li><li>**持续集成(CI)**：借助工具对软件项目进行持续的自动化的编译、打包、构建、测试、发布，来检查软件交付质量的一种行为</li><li>**持续部署(CD)**：基于__持续交付__的优势自动将经过测试的代码推入生产环境的过程</li></ul><h3 id="CI各阶段"><a href="#CI各阶段" class="headerlink" title="CI各阶段"></a>CI各阶段</h3><ul><li><em><strong>代码提交阶段</strong></em>：会用到“版本控制工具”进行源代码的版本控制</li><li><em><strong>静态代码检查阶段</strong></em>：只能检查代码语法错误等问题；代码运行时错误需要在后续的流程中进行测试、检查</li><li><em><strong>构建阶段</strong></em>：即 __编译应用程序__；一般包含 __构建验证测试__（检查所有模块是否正确集成？关键功能是否正常？）、__单元测试__（验证开发人员编写的单个元件、组件是否按预期执行）；还要将经过前期验证的 <strong>构建产物存储</strong> 起来</li><li><em><strong>测试阶段</strong></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SVN简单学习</title>
    <link href="/2024/07/10/SVN%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/10/SVN%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="SVN-command"><a href="#SVN-command" class="headerlink" title="SVN command"></a>SVN command</h2><ul><li><p>“改名”操作需要使用SVN进行，不要使用Windows下面的重命名，因为这个操作不受 SVN 控制，SVN 会将其理解为删除原文件、增加一个新文件，从而导致文件改名后不能跟踪到改名前的状态</p></li><li><p>“受SVN控制”是个挺重要的概念，在本地新建文件后，需要使用<code>add</code>操作将该新建文件纳入SVN的控制中；因此<strong>所有的操作最好都使用SVN进行</strong>，包括</p><ul><li>创建新文件&#x2F;夹，创建后要使用<code>add</code>操作</li><li>移动文件&#x2F;夹</li><li>修改文件&#x2F;夹的名字</li><li>删除文件&#x2F;夹</li><li>尽量不要使用Windows&#x2F;Linux提供的文件&#x2F;夹修改功能</li></ul></li><li><p>“更新至版本（U）” -&gt; 用于取回某个历史版本到本地 【类似git里面的checkout？】</p></li><li><p>“还原（V）” -&gt; 只能在“提交”到远程服务器之前进行，用于放弃本地的某些操作【可选的】</p></li><li><p>“复原（显示日志，选择某个要还原的版本）”，在某历史版本上进行后续的操作，提交后此版本将作为远程版本库的最新版本</p></li><li><p>“branch” -&gt; 先在远程创建分支，<strong>再更新</strong>到本地 【与git操作不同】，分支的基点可以选择三种不同的方式：</p><ul><li>“最新版本”，以最先版本作为基点</li><li>“指定版本”</li><li>“工作副本”，以本地工作副本作为基点？【这个内容需要进一步确认】【这个代表什么意思？】【已确认：就是本地工作空间】</li></ul></li><li><p>“合并分支操作” -&gt; </p><ul><li>先将自己工作的分支cyokeo-r1，提交到远程服务器</li><li>拉取要合并到的<code>分支</code>到本地，在该分支的文件夹上点击进行<code>合并</code>操作</li><li>感觉SVN的合并，一般是<code>Leader</code>干的活？</li><li>合并，并解决完冲突后，进行提交操作</li></ul></li><li><p>“切分支”</p><ul><li>优先使用CI进行SVN路径切分支操作，方便CI进行代码目录的继承关系管理。【CI是？】</li><li>CI无法满足要求时，使用SVN客户端切分支，要使用SVN工具的branch&#x2F;tag功能，而不要先下载下来再人为上传到新的目录。如果采用SVN的branch&#x2F;tag功能，只是创建了一个”副本”，方便版本追溯</li></ul></li><li><p>提交颗粒度尽量小，以减小他人合并的难度</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>距离相关</title>
    <link href="/2024/07/09/%E8%B7%9D%E7%A6%BB%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/07/09/%E8%B7%9D%E7%A6%BB%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://oi-wiki.org/geometry/distance/">距离</a></li></ul><h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><ul><li>D(A, B) &#x3D; abs(x1 - x2) + abs(y1 - y2)</li><li>(x, y) -&gt; (x+y, y-x)后，新坐标系下的切比雪夫距离为原坐标系下的曼哈顿距离</li><li><a href="https://leetcode.cn/problems/minimize-manhattan-distances/description/">3102. 最小化曼哈顿距离</a></li><li></li></ul><h2 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h2><ul><li>D(A, B) &#x3D; max(|x1 - x2|, |y1 - y2|)</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动规题单</title>
    <link href="/2024/07/07/%E5%8A%A8%E8%A7%84%E9%A2%98%E5%8D%95/"/>
    <url>/2024/07/07/%E5%8A%A8%E8%A7%84%E9%A2%98%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="我的动态规划题单"><a href="#我的动态规划题单" class="headerlink" title="我的动态规划题单"></a>我的动态规划题单</h2><p>动态规划有两个难点：</p><ul><li>不知道是否应该使用动态规划</li><li>动态规划的递推推导不出来</li></ul><h2 id="递推关系不太难想的，一般都很难想到使用动态规划的方法"><a href="#递推关系不太难想的，一般都很难想到使用动态规划的方法" class="headerlink" title="递推关系不太难想的，一般都很难想到使用动态规划的方法"></a>递推关系不太难想的，一般都很难想到使用<u>动态规划</u>的方法</h2><ul><li><a href="https://leetcode.cn/problems/wildcard-matching/description/">44. 通配符匹配</a><ul><li>这个题目有个点：’*“是万能的，连续的‘*’和一个‘*’是一样的</li></ul></li><li>[10. 正则表达式匹配]</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c/cpp小技巧</title>
    <link href="/2024/07/06/c-cpp%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/07/06/c-cpp%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="如何计算负数的补码"><a href="#如何计算负数的补码" class="headerlink" title="如何计算负数的补码"></a>如何计算负数的补码</h2><ul><li>负数一般以补码的形式存储</li><li>如果位数为(8), 则负数a的补码为<code>pow(2,n) - abs(a)</code></li><li>另外，负数a的补码也可根据：abs(a)的反码 + 1 得到</li></ul><h2 id="lambda把自身作为形参"><a href="#lambda把自身作为形参" class="headerlink" title="lambda把自身作为形参"></a>lambda把自身作为形参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// bool u_compare(string&amp; l, string* r)</span><br><span class="hljs-comment">// &#123;</span><br><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">accountsMerge</span>(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) &#123;<br>        unordered_map&lt;string, vector&lt;<span class="hljs-type">int</span>&gt;&gt; mp;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; accounts.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; accounts[i].<span class="hljs-built_in">size</span>(); j++)<br>            &#123;<br>                mp[accounts[i][j]].<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(accounts.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        unordered_set&lt;string&gt; mails;<br>        <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span>&amp;&amp; dfs, <span class="hljs-type">int</span> idx) -&gt; <span class="hljs-type">void</span> &#123;<br>            <span class="hljs-keyword">if</span> (vis[idx] == <span class="hljs-literal">false</span>)<br>            &#123;<br>                vis[idx] = <span class="hljs-literal">true</span>;<br>               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; accounts[idx].<span class="hljs-built_in">size</span>(); i++)<br>               &#123;<br>                    mails.<span class="hljs-built_in">insert</span>(accounts[idx][i]);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : mp[accounts[idx][i]])<br>                    &#123;<br>                        <span class="hljs-built_in">dfs</span>(dfs, it);<br>                    &#125;<br>               &#125; <br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vis.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!vis[i])<br>            &#123;<br>                mails.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-built_in">dfs</span>(dfs, i);<br>                vector&lt;string&gt; tmp&#123;accounts[i][<span class="hljs-number">0</span>]&#125;;<br>                tmp.<span class="hljs-built_in">insert</span>(tmp.<span class="hljs-built_in">end</span>(), mails.<span class="hljs-built_in">begin</span>(), mails.<span class="hljs-built_in">end</span>());<br>                <span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, tmp.<span class="hljs-built_in">end</span>());<br>                ans.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2024/07/06/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/06/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/575568/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86">leetcode 宫水三叶</a></li><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/2600821/kan-bu-dong-ni-da-wo-kmp-suan-fa-chao-qi-z1y0">从next数组的求解解读KMP算法</a></li><li><a href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF">还是carl的好理解一些</a></li></ul><h2 id="解决场景"><a href="#解决场景" class="headerlink" title="解决场景"></a>解决场景</h2><ul><li>如何快速在「原字符串」中找到「匹配字符串」</li><li>时间复杂度：O(m + n)，其中m，n分别为原字符串，待匹配字符串的长度</li><li>其能在「非完全匹配」的过程中提取到有效信息进行复用，以减少「重复匹配」的消耗。</li></ul><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ul><li>next数组是模式串的相同最长前后缀长度表</li><li>next[j]表示模式串中，字串[0, j-1]的相同最长前后缀的长度</li><li>“a”，“”，“abc”的最长前后缀长度均为0；“aabcaa”的最长相同前后缀的长度为2</li><li>当主串的第i个位置和模式串的第j个位置不相同时，模式串的匹配只需<strong>回退</strong>到 j’ &#x3D; next[j]的下一个位置。因为可以保证：<code>模式串的前j&#39;个字符[0, j&#39;]与主串第i个位置前的j&#39;个字符是相同的</code></li></ul><h2 id="如何求模式串的next数组"><a href="#如何求模式串的next数组" class="headerlink" title="如何求模式串的next数组"></a>如何求模式串的next数组</h2><ul><li><p>“abcabd”</p></li><li><p>“abacabad”：</p>  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="language-ruby">&gt; <span class="hljs-symbol">b:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> 所在的位置与b不同；由于<span class="hljs-keyword">next</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>，所以<span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">2</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">c:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span> 所在的位置与c不同；<span class="hljs-keyword">next</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span> 所在的位置与c不同；因此<span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">1</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">b:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span> 所在的位置与b相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">4</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">a:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] = <span class="hljs-number">2</span> 所在的位置与a相同，因此<span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>] = <span class="hljs-keyword">next</span>[<span class="hljs-number">5</span>] + <span class="hljs-number">1</span> = <span class="hljs-number">3</span>;</span><br>-<span class="language-ruby">&gt; <span class="hljs-symbol">d:</span> <span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>] = <span class="hljs-number">3</span> 所在的位置与d不同；<span class="hljs-keyword">next</span>[<span class="hljs-keyword">next</span>[<span class="hljs-number">6</span>]] = <span class="hljs-keyword">next</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>；因此<span class="hljs-keyword">next</span>[<span class="hljs-number">7</span>] = <span class="hljs-number">0</span>;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="字符串哈希（https-leetcode-cn-problems-shortest-palindrome-solutions-1396220-by-flix-be4y"><a href="#字符串哈希（https-leetcode-cn-problems-shortest-palindrome-solutions-1396220-by-flix-be4y" class="headerlink" title="字符串哈希（https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y)"></a>字符串哈希（<a href="https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y">https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y</a>)</h2><ul><li>构造next数组的算法：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = tmp.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-type">int</span> k = i<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; tmp[next[k]] != tmp[i]) &#123;k = next[k]<span class="hljs-number">-1</span>;&#125;<br>    <span class="hljs-keyword">if</span> (k &gt;= <span class="hljs-number">0</span>) next[i] = next[k] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> next[i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h2><ul><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></li><li><a href="https://leetcode.cn/problems/shortest-palindrome/solutions/392561/zui-duan-hui-wen-chuan-by-leetcode-solution/">214. 最短回文串</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题目复习</title>
    <link href="/2024/07/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/07/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li><p>904.水果成篮，结合<a href="https://leetcode.cn/problems/fruit-into-baskets/solutions/1437444/shen-du-jie-xi-zhe-dao-ti-he-by-linzeyin-6crr">题解</a>，深入理解：</p><ul><li>最大滑动窗口 - 模版  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(nums):<br>    // 判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> 不满足条件：<br>        i += <span class="hljs-number">1</span> //（最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）<br>    // 不断更新结果（注意在<span class="hljs-keyword">while</span>外更新！）<br>    j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>最小滑动窗口 - 模版  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(nums):<br>    // 判断[i, j]是否满足条件<br>    <span class="hljs-keyword">while</span> 满足条件：<br>        // 不断更新结果(注意在<span class="hljs-keyword">while</span>内更新！)<br>        i += <span class="hljs-number">1</span> //（最大程度的压缩i，使得滑窗尽可能的小）<br>    j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>确实，有了模版后，遇到滑窗问题，思路更加<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/submissions/544105543/">清晰了</a></li></ul></li><li><p>字符串哈希：使用hash映射，减小索引的存储消耗！！！<a href="https://leetcode.cn/problems/repeated-dna-sequences/solutions/1035568/zhong-fu-de-dnaxu-lie-by-leetcode-soluti-z8zn">参考</a></p><ul><li>选取一个大于字符集大小的质数作为base</li><li>将字符映射为小于base的数：map()</li><li>‘abccd’ -&gt; map(a)*base^0 + map(b)*base^1 + map(c)*base^2 + map(c)*base^3 + map(d)*base^4</li><li><a href="https://leetcode.cn/problems/shortest-palindrome/solutions/1396220/by-flix-be4y">参考</a></li></ul></li><li><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solutions/2551432/liang-chong-fang-fa-ni-xiang-si-wei-zhen-e3gb">最大&#x2F;小子序和</a></p><ul><li>通过取相反数，将最小子序和转化为最大字序和问题</li><li>前缀和 法</li><li>贪心 + dp 法  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cardPoints)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> maxSubArray = [](vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>            <span class="hljs-comment">//实现1：前缀和</span><br>            <span class="hljs-comment">// int res = INT_MIN, pre_sum = 0, min_pre_sum = 0;</span><br>            <span class="hljs-comment">// for (auto&amp; x : nums) &#123;</span><br>            <span class="hljs-comment">//     pre_sum += x;</span><br>            <span class="hljs-comment">//     res = max(res, pre_sum - min_pre_sum);</span><br>            <span class="hljs-comment">//     min_pre_sum = min(min_pre_sum, pre_sum);</span><br>            <span class="hljs-comment">// &#125;</span><br>            <span class="hljs-comment">// return res;</span><br><br>            <span class="hljs-comment">//实现2：贪心 + dp</span><br>            <span class="hljs-comment">//s = 0考虑了k = 0时的情况</span><br>            <span class="hljs-type">int</span> res = INT_MIN, s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : nums) &#123;<br>                <span class="hljs-keyword">if</span> (s &lt;= <span class="hljs-number">0</span>) s = <span class="hljs-number">0</span>;<br>                s += x;<br>                res = <span class="hljs-built_in">max</span>(res, s);<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-comment">//累加总和为s</span><br>        <span class="hljs-type">int</span> s = <span class="hljs-built_in">accumulate</span>(cardPoints.<span class="hljs-built_in">begin</span>(), cardPoints.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//将数组的每个元素乘以-1, 用来求连续子数组的最大和</span><br>        <span class="hljs-built_in">transform</span>(cardPoints.<span class="hljs-built_in">begin</span>(), cardPoints.<span class="hljs-built_in">end</span>(), cardPoints.<span class="hljs-built_in">begin</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> -x; &#125;);<br>        <span class="hljs-comment">//答案 = 总和 - 连续子数组的最小和</span><br>        <span class="hljs-keyword">return</span> s - (-<span class="hljs-built_in">maxSubArray</span>(cardPoints));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/submissions/546160358/">1838.最高频元素的频数</a></p><ul><li>需要动脑思考一下，察觉为使用滑动窗口</li></ul></li></ul><h2 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h2><ul><li><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文字串</a><ul><li>加深理解：如果字串长度为奇数，则只能为<code>aba</code>类型；但是当字串长度为偶数是，可以为<code>aa</code>，也可以为<code>abaaba</code></li><li>自己想到了使用dp数组，记忆化遍历，以减小重复遍历。但是时间表现还是很差❗️❗️</li><li>注意到回文串的中间部分一定是由连续且相同的字符串组成，因此可以定位到中间字符，再左右扩展查询，<a href="https://leetcode.cn/problems/longest-palindromic-substring/description/comments/59461">参考</a>❗️  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><span class="hljs-comment">//         保存起始位置，测试了用数组似乎能比全局变量稍快一点</span><br>        <span class="hljs-type">int</span>[] range = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">char</span>[] str = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><span class="hljs-comment">//             把回文看成中间的部分全是同一字符，左右部分相对称</span><br><span class="hljs-comment">//             找到下一个与当前字符不同的字符</span><br>            i = findLongest(str, i, range);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(range[<span class="hljs-number">0</span>], range[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLongest</span><span class="hljs-params">(<span class="hljs-type">char</span>[] str, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span>[] range)</span> &#123;<br><span class="hljs-comment">//         查找中间部分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">while</span> (high &lt; str.length - <span class="hljs-number">1</span> &amp;&amp; str[high + <span class="hljs-number">1</span>] == str[low]) &#123;<br>            high++;<br>        &#125;<br><span class="hljs-comment">//         定位中间部分的最后一个字符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> high;<br><span class="hljs-comment">//         从中间向左右扩散</span><br>        <span class="hljs-keyword">while</span> (low &gt; <span class="hljs-number">0</span> &amp;&amp; high &lt; str.length - <span class="hljs-number">1</span> &amp;&amp; str[low - <span class="hljs-number">1</span>] == str[high + <span class="hljs-number">1</span>]) &#123;<br>            low--;<br>            high++;<br>        &#125;<br><span class="hljs-comment">//         记录最大长度</span><br>        <span class="hljs-keyword">if</span> (high - low &gt; range[<span class="hljs-number">1</span>] - range[<span class="hljs-number">0</span>]) &#123;<br>            range[<span class="hljs-number">0</span>] = low;<br>            range[<span class="hljs-number">1</span>] = high;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><p><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a></p><ul><li>double, long long等数据类型的区别</li></ul></li><li><p><a href="">1186. 删除一次得到子数组最大和</a></p><ul><li>需要动态规划，但是没有想起来</li><li>计算递推时要严谨一些，好好看看下面对递归的步步推导与解释❗️</li><li><a href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/solutions/2321829/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-hzz6">解题参考</a></li><li>动态规划有「选或不选」和「枚举选哪个」这两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考</li></ul></li><li><p><a href="">3098. 求出所有子序列的能量和</a></p><ul><li>这个困难题对于动归非常典型</li><li>它的递推公式真的很难想到</li><li>典型的先想到递归&#x2F;回溯做法，再反推出动规的做法</li><li><a href="https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/solutions/2854316/yi-ti-san-jie-pai-xu-ji-yi-hua-sou-suo-y-bj6a">题解</a>：这个题解是比较清楚的</li></ul></li></ul><h2 id="匹配-全排列"><a href="#匹配-全排列" class="headerlink" title="匹配 + 全排列"></a>匹配 + 全排列</h2><p>具有明显的匹配意味，使用<code>next_permutation()</code>对其中一个求取全排列，并与另一个进行组合，记录最值</p><ul><li><p><a href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/description/">2850. 将石头分散到网格图的最少移动次数</a></p><ul><li>这题想到这一点还是需要一些思考的：主要注意到均值为1，为0的格子和不为0的格子-1后的和是一致的</li></ul></li><li><p><a href="https://leetcode.cn/problems/maximum-compatibility-score-sum/description/">1947. 最大兼容性评分和</a></p></li></ul><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><ul><li><a href="https://leetcode.cn/problems/remove-k-digits/submissions/549759198/">402. 移掉 K 位数字</a><ul><li><a href="https://leetcode.cn/problems/remove-k-digits/solutions/290203/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5">题解</a></li><li>使用vector模拟栈</li></ul></li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><p><a href="https://leetcode.cn/problems/task-scheduler/submissions/546146727/">621. 任务调度器</a></p><ul><li>需要动脑袋思考一下</li></ul></li><li><p><a href="https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-ii/description/">2972. 统计移除递增子数组的数目</a></p></li><li><p><a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/">1574. 删除最短的子数组使剩余数组有序</a></p><ul><li>与2972的思路一样</li></ul></li><li><p><a href="https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/description/">1712. 将数组分成三个子数组的方案数</a></p><ul><li>前缀和，需要动笔简单算一下</li></ul></li><li><p><a href="https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/description/">2106. 摘水果</a></p><ul><li>需要思考想到为前缀和</li><li>简单计算区间公式</li></ul></li><li><p><a href="https://leetcode.cn/problems/number-of-provinces/solutions/550179/dfs-bfs-bing-cha-ji-3-chong-fang-fa-ji-s-edkl/">547. 省份数量</a></p><ul><li>使用并查集</li></ul></li><li><p><a href="">721. 账户合并</a></p><ul><li>并查集</li></ul></li></ul><h2 id="对一个数组求子序列的两种回溯方法差异"><a href="#对一个数组求子序列的两种回溯方法差异" class="headerlink" title="对一个数组求子序列的两种回溯方法差异"></a>对一个数组求子序列的两种回溯方法差异</h2><ul><li><p><a href="">3098. 求出所有子序列的能量和</a></p></li><li><p>不使用for</p></li><li><p>使用for</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> m_min, <span class="hljs-type">int</span> last)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &lt;= <span class="hljs-number">0</span>) &#123;result += m_min; result %= (<span class="hljs-number">1000000000</span> + <span class="hljs-number">7</span>); <span class="hljs-keyword">return</span>;&#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i + left &gt; nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">int</span> n_min = m_min;<br>            <span class="hljs-keyword">if</span> (last &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                n_min = <span class="hljs-built_in">min</span>(m_min, nums[i] - nums[last]);<br>            &#125;<br>            <span class="hljs-comment">// 注意这里每一次递归都表示选当前元素</span><br>            <span class="hljs-built_in">traversal</span>(nums, i+<span class="hljs-number">1</span>, left<span class="hljs-number">-1</span>, n_min, i);<br>            <span class="hljs-comment">// 针对每个i，到这里都表示不选当前元素</span><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfPowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">traversal</span>(nums, <span class="hljs-number">0</span>, k, INT32_MAX, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>提问记录</title>
    <link href="/2024/06/28/%E6%8F%90%E9%97%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/28/%E6%8F%90%E9%97%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="24-06-27"><a href="#24-06-27" class="headerlink" title="24-06-27"></a>24-06-27</h2><ol><li><p>DDS可靠性相关 -&gt; 如何保证可靠性？接收端来不及处理时，如何保证？</p><ul><li>DDS可以理解为是一种传输协议，它的可靠性可以保证：发端发送一条消息后，可以到达接收端的DDS协议栈中，并驻留在接收端的History中。如果接收端的应用层来不及处理新收到的消息，那就不立即处理，后续可以使用read接口从协议栈中获取之前接收到的数据。</li><li>上述可能会出现接收端缓存满，而尚有消息未处理的情况：此时，就需要扩大History的消息缓存数目。这里就是History QoS 与 Resource QoS这两种不同服务质量要求之间的trade了。</li></ul></li><li><p>MCU上做开发与Linux用户态开发有什么不同？分别有哪些需要注意的内容？</p><ul><li>MCU上直接看到真实物理内存，Linux用户态多了一层虚拟地址转换。因此在MCU上做开发时，更要注意对指针的使用。</li><li>MCU上有时Linker，链接脚本，程序、变量存放位置；Linux用户态不用考虑这些问题。</li><li>调试时，MCU上遇到TRAP等问题，要去翻具体的芯片架构手册进行排查；Linux用户态有一套标准的exception机制。</li><li>MCU上做开发更类似于Linux内核态驱动开发。</li><li>MCU上有时需要考虑boot的问题，Linux用户态不用考虑。</li><li>MCU上开发一般只会用到静态库，而Linux上还会有动态库。</li></ul></li><li><p>(之前软硬件结合提到了对指针的“恍然大悟”)那你现在是如何理解指针的？</p><ul><li>指针就是一个普通的变量，对它进行加减乘除，函数参数，就像普通变量那样使用</li><li>重点在于如何使用指针变量，如何解释指针 -&gt; 这里就得说一下指针类型转换</li><li>使用时，相比于普通变量，要多考虑一层：它指向了某块内存区域！内存区域的大小与指针指向的对象类型有关</li><li>指针使用：大部分都会取成员 -&gt; 指针指向的对象类型是什么？这个问题也要时刻注意</li><li>c++中，class C 继承于 class B , class A。<code>C v_c; B* p_b = &amp;v_c; A* p_a = &amp;v_c</code>，这三行语句，p_b的值与p_a的值是不一样的！</li><li>在c语言中，常把指针和数组进行比较。</li></ul></li><li><p>用一个词形容操作系统</p><ul><li>管理者</li><li>根据管理的内容不同，OS又可以分为宏内核&#x2F;微内核</li><li>MCU上的OS一般只有CPU管理的功能</li><li>SoC上使用基于Linux的操作系统，还会有内存管理，进程通信，文件系统等功能</li></ul></li></ol><h2 id="24-07-04"><a href="#24-07-04" class="headerlink" title="24-07-04"></a>24-07-04</h2><ol><li><p>如何在不使用额外变量的情况下，交换两个整形变量的值</p><ul><li>方法一：采用数学运算 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = x + y<span class="hljs-comment">;  // -&gt; 虽然这里可能会有溢出的情况，但**由于**负数采用补码的方式表示，后续运算后，也能实现交换的目的</span><br><span class="hljs-attr">y</span> = x - y<span class="hljs-comment">;</span><br><span class="hljs-attr">x</span> = x - y<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>方法二： 采用异或运算 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = x ^ y<span class="hljs-comment">;</span><br><span class="hljs-attr">y</span> = x ^ y<span class="hljs-comment">;</span><br><span class="hljs-attr">x</span> = x ^ y<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>叠砖块问题</p><ul><li>要保证第二块及以上所有砖的“重心和”落在第一块砖内<br> 这题要分情况讨论：</li><li>如果每块砖伸出的长度可以自由调整， <a href="https://max.book118.com/html/2018/0103/147107237.shtm">参考</a>，可以证明：以1&#x2F;2n的规律无限延伸</li><li>如果每块砖伸出的长度为固定大小，可以证明：最远可伸出1&#x2F;2n</li></ul></li><li><p>“叠砖块问题”的启发</p><ul><li>面试时要大胆的说出自己的直觉，并且额外补充说明：需要进一步的分析与证明</li></ul></li><li><p>有符号数溢出问题</p><ul><li>要注意负数以补码的形式存储：绝对值的反码+1</li><li>unsigned char 和 signed char表示的数据范围是不一样的</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aarch64-linux-内存管理（二）</title>
    <link href="/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul><li><a href="https://blog.csdn.net/yhb1047818384/article/details/109169979">Linux内存管理(四)：paging_init分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>aarch64-linux-内存管理（一）</title>
    <link href="/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/06/26/aarch64-linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ol><li><a href="https://blog.csdn.net/yhb1047818384/category_10345494.html">Linux内存管理-专栏</a></li><li><a href="http://www.wowotech.net/memory_management/memory_model.html">Linux内存模型</a></li><li><a href="https://www.cnblogs.com/liuhailong0112/p/14465697.html">arm64架构linux内核地址转换__pa(x)与__va(x)分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3Mjg2NDQ0NA==&mid=2247485533&idx=1&sn=bf4dc798fc2cbbe0b55dcd0f5360d933&chksm=cee9878ef99e0e98628bd41f0a733f47d955e470d26840d0f07cc5aa7c9f789e746133c39c82&scene=178&cur_album_id=2707075920913924097#rd">底层开发必知的三个内存结构概念</a></li></ol><h2 id="内存硬件结构"><a href="#内存硬件结构" class="headerlink" title="内存硬件结构"></a>内存硬件结构</h2><p>Linux 把物理内存划分为三个层次来管理: 存储节点(Node)、内存管理区(Zone)和页面(Page)</p><ul><li>Node -&gt; struct pglist_data，包含的重要信息有<ul><li>该 Node 包含的Zone数目</li><li>该node中内存的起始页帧号</li><li>该node地址范围内的实际管理的页面数量</li><li>该node地址范围内的所有页面数量，包括空洞的页面</li><li>ZONE_PADDING宏：让前后的成员分布在不同的cache line中, 以空间换取时间</li></ul></li><li>Zone -&gt; struct Zone<ul><li>将node拆分成zone主要还是出于Linux为了兼容各种架构和平台，对不同区域的内存需要采用不同的管理方式和映射方式；32位系统中，内核和用户地址空间按1:3划分，内核地址空间只有1GB，所以不能把1GB以上的内存直接映射到内核地址空间，因此就把不能直接映射的内存划分到了高端内存区</li><li>ZONE_DMA: 只适用于Intel x86架构，ARM架构没有这个区域，用于ISA设备的DMA操作，物理地址范围为0-16MB</li><li>ZONE_DMA32: 在64位的系统上使用32位地址寻址的适合DMA操作的内存区。例如在AMD64系统上，该区域为低4GB的空间。在32位系统上，本区域通常是空的</li><li>ZONE_NORMAL: 指的是<u>可以直接映射到内核空间的内存</u>。也常称为“普通区域”“直接映射区域”“线性映射区域”。所谓线性映射就是物理地址和映射后的虚拟地址存在一种简单的关系，即虚拟地址&#x3D;物理地址+固定偏移。在32位系统上，内核空间和用户空间按1:3划分，那么这个固定偏移就是：<code>0xC0000000</code> - 物理内存起始地址。因此可以看到：在32位系统中，将物理内存地址的低1G[物理内存起始地址(start): start+1G]映射到内核空间[0xc0000000:0xffffffff]</li><li>ZONE_HIGHMEM: 高端内存区，32位时代的产物。在32位系统上，指的是高于<code>896M</code>的物理内存。32位系统中，内核和用户地址空间按1:3划分，内核地址空间只有1GB，所以不能把1GB以上的内存直接映射到内核地址空间，因此就把不能直接映射的内存划分到了高端内存区。要将高于896MB的物理内存映射在内核空间的话，需要通过单独的映射来完成，并且这类映射不能保证物理地址和虚拟地址之间存在固定的对应关系（例如ZONE_NORMAL的固定偏移）<blockquote><p>64位系统中没有这个区域，即没有高端内存。因为64系统的内核虚拟地址空间非常大，不再需要高端内存区域</p></blockquote></li><li>指向所属的Node节点</li><li>空闲内存链表，用于实现伙伴系统</li></ul></li><li>Page -&gt; struct page<ul><li>Linux内核使用page结构体来描述一个物理页面，每一个page frame有一个一一对应的page数据结构，系统中定义了page_to_pfn和pfn_to_page的宏用来在page frame number和page数据结构之间进行转换，具体如何转换是和<a href="http://www.wowotech.net/memory_management/memory_model.html">memory modle</a>相关</li><li>PFN是page frame number的缩写，所谓page frame，就是针对物理内存而言的，把物理内存分成一个个的page size的区域，并且给每一个page 编号，这个号码就是PFN。假设物理内存从0地址开始，那么PFN等于0的那个页帧就是0地址（物理地址）开始的那个page。假设物理内存从x地址开始，那么第一个页帧号码就是（x&gt;&gt;PAGE_SHIFT）</li></ul></li><li>区分系统物理地址空间 VS 内存占据的物理地址空间<ul><li>整个系统的物理地址空间并不是都用于内存，有些也属于I&#x2F;O空间（当然，有些cpu arch有自己独立的io address space）。因此，内存所占据的物理地址空间应该是一个有限的区间，不可能覆盖整个物理地址空间</li></ul></li></ul><ol><li>UMA 与 NUMA<ul><li>UMA: Uniform Memory Access，统一内存访问，每个CPU共享相同的内存地址空间</li><li>NUMA: Non-Uniform Memory Access，非统一内存访问。系统中会有很多的内存节点和多个CPU簇， 所有节点中的CPU可以访问全部的物理内存，但是CPU访问本地的节点速度远快于访问远端的内存节点的速度</li></ul></li></ol><h2 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h2><p>主要问题有：</p><ol><li><p>内核如何知道系统的物理内存信息？</p><ul><li>DTB 方式，物理内存信息会写到DTB image中，内核在启动初期对DTB进行解析，得到物理内存信息</li><li>ACPI 方式，会在BIOS中写入物理内存信息</li></ul></li><li><p>内核启动初期有一部分汇编编写的位置无关码，它们主要做了什么事情？</p><ul><li>内核绝大部分的代码都不是位置无关码，且其运行时地址基本为虚拟地址，因此在执行到内核主体部分代码时，需要开启MMU，启动虚拟化。开启虚拟化就需要提供页表</li><li>因此，在进入start_kernel()之前的初始阶段汇编代码会进行两个页表映射：<ul><li><code>identity mapping</code>：VA和PA相等的一段映射，主要目的就是为了打开MMU。<u>在打开mmu之前，cpu访问的都是物理地址，打开mmu访问的就是虚拟地址</u>，其实真正打开mmu的操作就是往某个system register的某个bit写1， 如果在开启mmu之前已经下发了某一个数据的操作指令，本来它是想访问物理地址的，结果mmu打开导致访问了虚拟地址，这样会造成混乱。 所以为了解决这一个情况，引入了identity mapping。VA &#x3D; PA， 打开mmu前后，无论访问物理地址还是虚拟地址，都是对应同一段物理内存</li><li><code>kernel image mapping</code>：内核镜像映射，主要目的是为了执行内核代码。打开了MMU后，内核需要运行起来，就需要将kernel运行需要的地址（kernel txt、rodata、data、bss等等）进行映射。映射到的虚拟地址为：内核编译时指定（计算出）的虚拟地址（<em><strong>存疑❓</strong></em>）</li></ul></li></ul></li></ol><p><code>idmap_pg_dir</code>是identity mapping用到的页表，<code>init_pg_dir</code>是kernel_image_mapping用到的页表。这两个页表定义在arch&#x2F;arm64&#x2F;kernel&#x2F;vmlinux.lds.S中，同样定义在该文件中的还有另外三个页表<code>reserved_ttbr0</code>，<code>tramp_pg_dir</code>， <code>swapper_pg_dir</code>。</p><ul><li>reserved_ttbr0：是内核访问用户空间需要用的页表。</li><li>tramp_pg_dir：适用于映射kaslr的内核区域</li><li><u>swapper_pg_dir</u>：在内核启动期间进行常规映射后，用作内核页表。（在4.20的内核之前其实是没有init_pg_dir这个概念的，arm64&#x2F;mm: Separate boot-time page tables from swapper_pg_dir添加了启动时pgd的init_pg_dir）这几个页表的位置、大小在内核链接文件中都有定义。</li><li>使用init_pg_dir，是因为处理FDT的内核代码，后续的内核代码比较大；但是物理内存还没有扫描完成，进行不了最终swapper页表的建立</li></ul><ol start="3"><li><p>初期的kernel image mapping （init_pg_dir）是如何进行（初始化这个页表）的？</p><ul><li>Linux代码如下 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Map the kernel image (starting with PHYS_OFFSET).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x0</span>, init_pg_dir<br><span class="hljs-symbol">mov_q</span>   <span class="hljs-built_in">x5</span>, KIMAGE_VADDR + TEXT_OFFSET   <span class="hljs-comment">// compile time __va(_text)</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x23</span>           <span class="hljs-comment">// add KASLR displacement</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">x4</span>, PTRS_PER_PGD<br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x6</span>, _<span class="hljs-meta">end</span>           <span class="hljs-comment">// runtime __pa(_end)</span><br><span class="hljs-keyword">adrp</span>    <span class="hljs-built_in">x3</span>, _text          <span class="hljs-comment">// runtime __pa(_text)</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x3</span>            <span class="hljs-comment">// _end - _text</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x5</span>            <span class="hljs-comment">// runtime __va(_end)</span><br> <br><span class="hljs-symbol">map_memory</span> <span class="hljs-built_in">x0</span>, <span class="hljs-built_in">x1</span>, <span class="hljs-built_in">x5</span>, <span class="hljs-built_in">x6</span>, <span class="hljs-built_in">x7</span>, <span class="hljs-built_in">x3</span>, <span class="hljs-built_in">x4</span>, <span class="hljs-built_in">x10</span>, <span class="hljs-built_in">x11</span>, <span class="hljs-built_in">x12</span>, <span class="hljs-built_in">x13</span>, <span class="hljs-built_in">x14</span><br></code></pre></td></tr></table></figure> ❗️ KIMAGE_VARDDR 即为内核映像的虚拟空间开始地址。这个值也是在编译时指定的【或者可以计算出的】<br> ❗️ TEXT_OFFSET 即为内核代码段相对于内核虚拟地址起始位置的偏移<br> ❗️ <font color=#DC143C>adrp 指令用于获取标号的运行时物理地址【借助运行当前指令时的PC值】</font></li><li><a href="https://stackoverflow.com/questions/51763634/why-physical-address-of-aarch64-kernel-image-is-nonnegative">TEXT_OFFSET</a> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-keyword">in</span> file <span class="hljs-regexp">/arch/</span>arm64<span class="hljs-regexp">/kernel/</span>vmlinux.lds.S<br>. = KIMAGE_VADDR + TEXT_OFFSET; <br>.head.text : &#123;                          <br>_text = .;<br>HEAD_TEXT<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p> 这里，TEXT_OFFSET是一个随机值，因此每次编译时，内核代码的偏移都不是固定的（出于安全的考虑）。最新Linux代码中已经不使用TEXT_OFFSET了。虚拟地址随机化完全依赖于kaslr_offset。init_pg_dir页表的初始化过程也稍有变化：__primary_switch -&gt; __pi_early_map_kernel()[这个函数似乎就是：early_map_kerne()]<br> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs armasm">   . = KIMAGE_VADDR<span class="hljs-comment">;</span><br><br><span class="hljs-symbol">.head.text</span> : &#123;<br>_text = .<span class="hljs-comment">;</span><br>HEAD_TEXT<br>&#125;<br><span class="hljs-symbol">.text</span> : <span class="hljs-meta">ALIGN</span>(SEGMENT_ALIGN) &#123;<span class="hljs-comment">/* Real text segment*/</span><br>_stext = .<span class="hljs-comment">;  </span><br>       ......<br>   &#125;<br>   <br>   <span class="hljs-comment">// in /arch/arm64/kernel/head.S  </span><br><br>   SYM_FUNC_START_LOCAL(__primary_switch)<br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x1</span>, reserved_pg_dir<br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x2</span>, init_idmap_pg_dir<br><span class="hljs-keyword">bl</span>__enable_mmu<br><br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x1</span>, early_init_stack<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">sp</span>, <span class="hljs-built_in">x1</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x29</span>, xzr<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x0</span>, <span class="hljs-built_in">x20</span><span class="hljs-comment">// pass the full boot status</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">x1</span>, <span class="hljs-built_in">x21</span><span class="hljs-comment">// pass the FDT</span><br><span class="hljs-keyword">bl</span>__pi_early_map_kernel<span class="hljs-comment">// Map and relocate the kernel</span><br><br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">x8</span>, <span class="hljs-symbol">=__primary_switched</span><br><span class="hljs-keyword">adrp</span><span class="hljs-built_in">x0</span>, KERNEL_START<span class="hljs-comment">// __pa(KERNEL_START)</span><br><span class="hljs-keyword">br</span><span class="hljs-built_in">x8</span><br>   SYM_FUNC_END(__primary_switch)<br></code></pre></td></tr></table></figure></p><p> 可以看到，在初始化init_pg_dir时，mmu已经开启了。需要注意：</p><ul><li>❗️<code>bl __pi_early_map_kernel</code>: BL: Branch with Link branches to a PC-relative offset</li><li>❗️<code>br x8</code>: “Adding an L to the B or BR instructions turns them into a branch with link. This means that a<br> return address is written into LR (X30) as part of the branch.” 可以看出B，BR是两个不同的指令。</li><li>❗️ 因此，<code>br x8</code>将__primary_switched标号的虚拟地址赋给PC，从前面的链接文件可以看到，其虚拟地址处于KIMAGE_VADDR开始之后的位置。因此，之后Linux内核将运行于高地址的虚拟内存空间。</li></ul><blockquote><p>[from 《Armv8-A Instruction Set Architecture》]： The unconditional branch instruction B <label> performs a direct, PC-relative, branch to <label>. The offset from the current PC to the destination is encoded within the instruction. The range is limited by the space available within the instruction to record the offset and is +&#x2F;- 128MB. When you use BR <Xn>, BR performs an indirect, or absolute, branch to the address specified in Xn.</p></blockquote> <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// in file /arch/arm64/kernel/pi/map_kernel.c<br><br>asmlinkage void __init early_map_kernel(u64 boot_status, void *fdt)<br>&#123;<br>    u64 v<span class="hljs-built_in">a_base</span>, p<span class="hljs-built_in">a_base</span> = (u64)&amp;_text<span class="hljs-comment">;</span><br>    u64 kaslr_offset = p<span class="hljs-built_in">a_base</span> % MIN_KIMG_ALIGN<span class="hljs-comment">;</span><br><br>    map_fdt((u64)fdt)<span class="hljs-comment">;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * The virtual KASLR displacement modulo 2MiB is decided by the</span><br><span class="hljs-comment">    * physical placement of the image, as otherwise, we might not be able</span><br><span class="hljs-comment">    * to create the early kernel mapping using 2 MiB block descriptors. So</span><br><span class="hljs-comment">    * take the low bits of the KASLR offset from the physical address, and</span><br><span class="hljs-comment">    * fill in the high bits from the seed.</span><br><span class="hljs-comment">    */</span><br>    if (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) &#123;<br>        u64 kaslr_seed = kaslr_early_init(fdt, chosen)<span class="hljs-comment">;</span><br><br>        if (kaslr_seed &amp;&amp; kaslr_requires_kpti())<br>            arm64_use_ng_mappings = <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br><br>        kaslr_offset |= kaslr_seed &amp; ~(MIN_KIMG_ALIGN - <span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>    &#125;<br><br>    if (IS_ENABLED(CONFIG_ARM64_LPA2) &amp;&amp; v<span class="hljs-built_in">a_bits</span> &gt; V<span class="hljs-built_in">A_BITS</span>_MIN)<br>        remap_idmap_for_lpa2()<span class="hljs-comment">;</span><br><br>    v<span class="hljs-built_in">a_base</span> = KIMAGE_VADDR + kaslr_offset<span class="hljs-comment">;</span><br>    map_kernel(kaslr_offset, v<span class="hljs-built_in">a_base</span> - p<span class="hljs-built_in">a_base</span>, root_level)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>kaslr_offset:<br> 这里相当于给内核运行时虚拟地址加了一个随机的偏移，因此后续在map_kernel中需要对内核进行重定位。<u>物理地址随机化比较好处理，虚拟地址随机化之后，内核大部分代码都需要重定位</u>。</li></ul></li><li><p>内核如何去解析这些配置信息？</p><ul><li>现在虽然MMU已经打开，kernel image的页表已经建立，但是内核还没有为DTB这段内存创建映射，现在内核还不知道内存的布局，所以内存管理模块还没能初始化。这个时候就需要用到fixmap。即将DTB的物理地址映射到Fixed map中的区域，然后访问该区域中的虚拟地址即可。</li><li>解析DTB获取系统的物理内存信息，并保存到 <em><strong>memblock</strong></em> 结构中，这是一个全局的变量，用于管理内核早期启动阶段过程中的所有物理内存。</li></ul></li></ol><h2 id="顺序记录"><a href="#顺序记录" class="headerlink" title="顺序记录"></a>顺序记录</h2><h3 id="aarch64-内核内存布局"><a href="#aarch64-内核内存布局" class="headerlink" title="aarch64-内核内存布局"></a>aarch64-内核内存布局</h3><ul><li>0-256T -&gt; 用户空间；256-512T -&gt; 内核空间</li></ul><h4 id="fixed-mappings-4124KB"><a href="#fixed-mappings-4124KB" class="headerlink" title="fixed mappings[4124KB]"></a><a href="https://www.cnblogs.com/alantu2018/p/8447570.html">fixed mappings[4124KB]</a></h4><p>固定映射区，这部分的虚拟地址在编译阶段就已经确定。 在内核的启动过程中，有些模块需要使用虚拟内存并mapping到指定的物理地址上。而且，这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，linux kernel固定分配了一些fixmap的虚拟地址，这些地址有固定的用途。使用该地址的模块在初始化的时候，将这些固定分配的地址mapping到指定的物理地址上去，进而可以通过虚拟化访问到需要访问的特定物理内存。<a href="https://www.cnblogs.com/alantu2018/p/8447570.html">参考</a></p><p><em><strong>个人理解</strong></em>：例如在处理DTB时，内核初始部分代码将启动参数给出的DTB物理地址映射到fixed mappings虚拟空间区域，进而在开启虚拟化之后，实现对DTB的解析</p><p><em><strong>fixed address</strong></em>的具体位置，对于aarch64架构，当前内核中这部分对应的虚拟地址范围为<code>[fffffdfffe5f9000, fffffdfffe9fffff]</code>，总共4124KB大小</p><p><em><strong>fixed address</strong></em>又分为两大类：永久映射 &amp; 临时映射</p><ol><li>永久映射：用于具体的某个内核模块，使用关系是永久的。涉及到的模块主要有：</li></ol><ul><li>DTB解析模块：</li><li>early Console 模块：kernel启动阶段初期可以使用的consol，可以用于输出各种调试信息</li><li>动态打补丁的模块：使用fixed address映射具有RW属性的代码段，进而动态修改这部分代码段的部分内容</li></ul><ol start="2"><li>临时映射：各个内核模块都可以使用，用完之后就释放。主要用于early ioremap模块</li></ol><h3 id="aarch64虚拟地址-物理地址"><a href="#aarch64虚拟地址-物理地址" class="headerlink" title="aarch64虚拟地址-&gt;物理地址"></a>aarch64虚拟地址-&gt;物理地址</h3><p>aarch64有两个页表基地址寄存器：</p><ul><li>ttbr0：用户空间页表基地址。启动初期，idmap_pg_dir填入ttbr0。这里将内核代码映射到低虚拟地址空间。</li><li>ttbr1：内核空间页表基地址。启动初期，init_pg_dir填入ttbr1。这个页表将内核代码映射到高虚拟地址空间。</li></ul><p>64bit的虚拟地址并不是所有bit都被用上的。目前有效的VA_BITS的配置是：36, 39, 42, 47。假设我现在使用64K的页和42bit的虚拟地址空间， 使用三级页表。地址转换过程<a href="https://blog.csdn.net/yhb1047818384/article/details/108210044">举例</a>：</p><ol><li>如果VA[63：42] &#x3D; 1, 那么就会使用ttbr1的地址作为一级页表的基地址；如果VA[63:42] &#x3D; 0, 那么就会使用ttbr0的地址作为一级页表的基地址，那么就会使用ttbr0的地址作为一级页表的基地址；</li><li>VA[41:29]放置Level 1页表中的索引，从而找到对应的描述符地址并获取描述符内容，<u>根据描述符中的内容获取Level 2页表基地址</u></li><li>VA[28:16]放置Level 2页表中的索引，从而找到对应的描述符地址并获取描述符内容，根据描述符中的内容获取<u>物理地址的高36位</u>，以4K地址对齐</li><li>VA[15: 0]放置的是物理地址的偏移，结合获取的物理地址高位，最终得到物理地址</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux相关</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态库vs静态库</title>
    <link href="/2024/06/26/%E5%8A%A8%E6%80%81%E5%BA%93vs%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/2024/06/26/%E5%8A%A8%E6%80%81%E5%BA%93vs%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加减乘除与mod</title>
    <link href="/2024/06/25/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%B8%8Emod/"/>
    <url>/2024/06/25/%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%B8%8Emod/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://leetcode.cn/circle/discuss/mDfnkW/">力扣</a></li></ul><h2 id="记录要点"><a href="#记录要点" class="headerlink" title="记录要点"></a>记录要点</h2><h3 id="两个恒等式"><a href="#两个恒等式" class="headerlink" title="两个恒等式"></a>两个恒等式</h3><ul><li><code>(a + b) mod m = [(a mod m) + (b mod m)] mod m</code></li><li><code>(a b) mod m = [(a mod m) (b mod m)] mod m</code></li></ul><h3 id="幂运算与mod"><a href="#幂运算与mod" class="headerlink" title="幂运算与mod"></a>幂运算与mod</h3><ul><li><font color=DC143C>指数不能随便取余</font>，如果指数在 64 位整数的范围内，可以使用<a href="https://leetcode.cn/problems/powx-n/description/">快速幂</a>计算方法<blockquote><p>注：如果指数超出 64 位整数的范围，需要用「欧拉降幂」处理。</p></blockquote></li></ul><h3 id="负数与mod"><a href="#负数与mod" class="headerlink" title="负数与mod"></a>负数与mod</h3><ul><li>如果<code>x</code>是负数，要采用<code>(x mod m + m) mod m</code>的形式，这样不用判断<code>x</code>是否为负数</li></ul><h3 id="除法与mod"><a href="#除法与mod" class="headerlink" title="除法与mod"></a>除法与mod</h3><ul><li>参考上述链接</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码实现时，上面的加减乘除通常这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MOD = <span class="hljs-number">1</span>_000_000_007<br><br><span class="hljs-comment">// 加</span><br>(a + b) % MOD<br><br><span class="hljs-comment">// 减</span><br>(a - b + MOD) % MOD<br><br><span class="hljs-comment">// 取模到 [0,MOD-1] 中，无论正负</span><br>(a % MOD + MOD) % MOD<br><br><span class="hljs-comment">// 乘</span><br>a * b % MOD<br><br><span class="hljs-comment">// 多个数相乘，要步步取模，防止溢出</span><br>a * b % MOD * c % MOD<br><br><span class="hljs-comment">// 除（MOD 是质数且 b 不是 MOD 的倍数）</span><br>a * <span class="hljs-built_in">qpow</span>(b, MOD - <span class="hljs-number">2</span>, MOD) % MOD<br></code></pre></td></tr></table></figure><p>其中 <code>qpow</code> 为快速幂函数。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子数组相关</title>
    <link href="/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/06/25/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">209. 长度最小的子数组</a></p></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></p></li></ul><h2 id="对应解答及注意事项"><a href="#对应解答及注意事项" class="headerlink" title="对应解答及注意事项"></a>对应解答及注意事项</h2><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">长度最小的子数组</a></h3><blockquote><ul><li>这个题是滑动窗口的最佳实践！窗口有左右两个边界索引，有点类似于<em><strong>双指针</strong></em>的方法</li><li>官方题解有一个前缀和的做法：<strong>提前算出[0, i]的和，并保存到一个额外的数组中</strong>，接着将题目转化为：<strong>找到两个前缀和，[0, i)，[0, j)<strong>使得这两个前缀和的差 <strong>&gt;&#x3D;</strong> target，记录此时的子数组长度为：</strong>j-i+1</strong>。后续的操作全都转化为了对<em><strong>前缀和数组</strong></em>的查询操作。</li><li></li></ul></blockquote><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h3><blockquote><ul><li>这题可以用<strong>动态规划</strong>的方法</li><li>评论区有提到<strong>前缀和数组</strong>的方法：也是提前算出前缀和，<strong>子数组的和可以转化为两个前缀和的差</strong>。对于前缀和数组来说，题目转化为了<strong>股票购买&#x2F;卖出最佳时机（可以多次持有股票，但手上最多只能有一支股票）</strong></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题心得</title>
    <link href="/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    <url>/2024/06/24/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="读题关键字"><a href="#读题关键字" class="headerlink" title="读题关键字"></a>读题关键字</h2><ul><li>注意总结解题模版！！！</li><li>满足条件的最<em><strong>小</strong></em>整数</li><li>涉及到存储长度类似的：[如果最小的不是32位整数，也返回-1]</li></ul><h2 id="常用编程技巧"><a href="#常用编程技巧" class="headerlink" title="常用编程技巧"></a>常用编程技巧</h2><ul><li><p>(long long)(m-1) * (m-2) -&gt; 强制类型转换的优先级高于加减乘除</p></li><li><p>使用程序块为变量赋值，要注意函数块需要使用<font color=#DC143C>()</font>包裹起来：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> sum = (&#123;<br>        <span class="hljs-type">double</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) tmp += nums[j];<br>        tmp;<br>    &#125;);<br></code></pre></td></tr></table></figure></li><li><p>代码行压缩时，如果有多条语句，必须用{}包围起来，如果只有一条语句不用</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;y = <span class="hljs-number">10</span>; z = <span class="hljs-number">100</span>;&#125;<br><span class="hljs-keyword">while</span> (s[i] != <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; i &lt; m) &#123;s[i] -= <span class="hljs-number">1</span>; flag = <span class="hljs-literal">true</span>; i++;&#125;<br><span class="hljs-keyword">while</span>(s[i] == <span class="hljs-string">&#x27;a&#x27;</span>) s[i] -= <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure></li><li><p>在<code>while</code>循环里写额外的for&#x2F;while循环时，一定要记得在内层循环判断越界问题</p></li><li><p>两字符串字典序比较时要注意：循环判断，相等的才会继续，小于或者大于时都会结束判断！！！复习一下这个<a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf">题目</a>，注意提交错误的几个。<strong>可以直接使用string类的&lt;&#x2F;&gt;&#x2F;&gt;&#x3D;运算符，或者compare成员函数进行字典序号的比较</strong></p></li><li><p>体会如何写二叉树的递归：先转化为局部问题，考虑局部root, root-&gt;left, root-&gt;right的递归问题；先不用纠结于前&#x2F;中&#x2F;后的递归顺序，结合这个题目[114.二叉树展开为链表]。</p></li><li><p>判断一个数是否为质数</p><ul><li>daiding</li></ul></li><li><p>计算整数各个位上数字之和：可以先从个位数加起：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfTheDigitsOfHarshadNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = x; v; v /= <span class="hljs-number">10</span>) &#123;<br>        s += v % <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>double, long, int, long long等类型表示的数据范围</p><ul><li>double是双精度浮点型，可以表示小数，在64位系统上占8Bytes。采用的数据表示方法和另外几种数据类型不同，能表示的数据范围是最大的。此外还有float[单精度浮点型], long double[精确度更高]</li><li>其余都是整数类型</li><li>浮点型，牺牲了表示精度，但是增大了数据表示范围</li><li>参考题目：<a href="https://leetcode.cn/problems/maximum-product-subarray/description/">152. 乘积最大子数组</a></li></ul></li></ul><h2 id="个别题目复习"><a href="#个别题目复习" class="headerlink" title="个别题目复习"></a>个别题目复习</h2><ul><li><p>数的前&#x2F;中&#x2F;后遍历的迭代方法要熟悉</p></li><li><p>找数字规律的题目，先找到“主干规律”，再找次要规律，结合题目[6. Z字型变换]</p></li><li><p><em><strong>二叉树层序遍历</strong></em>不一定非得用queue，也可以用vector实现一些重复遍历的操作，结合[2641.]</p></li></ul><h2 id="常用数据结构及其方法"><a href="#常用数据结构及其方法" class="headerlink" title="常用数据结构及其方法"></a>常用数据结构及其方法</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul><li>erase()</li><li>rbegin() -&gt; 最右侧的那个节点</li><li>pop_back()</li><li>push_back() -&gt; 可以用来模拟栈</li><li>rend() -&gt; 第一个节点前面，不在vector中</li><li>insert(pos, start, end)，从pos处插入[start, end)，注意这样的话target[pos] &#x3D; src[start]</li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>&lt;string&gt;</li><li>insert(pos, char *, size)</li><li>size_t find(string&amp; str, size_t pos &#x3D; 0) &#x2F; find(const char *str s, size_t pos (&#x3D;0), size_t n) &#x2F; find(char c, pos &#x3D; 0)<ul><li>delimiter划分  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// for string delimiter</span><br><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">split</span><span class="hljs-params">(std::string s, std::string delimiter)</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> pos_start = <span class="hljs-number">0</span>, pos_end, delim_len = delimiter.<span class="hljs-built_in">length</span>();<br>    std::string token;<br>    std::vector&lt;std::string&gt; res;<br><br>    <span class="hljs-keyword">while</span> ((pos_end = s.<span class="hljs-built_in">find</span>(delimiter, pos_start)) != std::string::npos) &#123;<br>        token = s.<span class="hljs-built_in">substr</span> (pos_start, pos_end - pos_start);<br>        pos_start = pos_end + delim_len;<br>        res.<span class="hljs-built_in">push_back</span> (token);<br>    &#125;<br><br>    res.<span class="hljs-built_in">push_back</span> (s.<span class="hljs-built_in">substr</span> (pos_start));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>find_first_of() -&gt; 类似于find()，但是匹配str中的任一个字符</li><li>substr(start, len) ❗️ 注意这个方法的第二个参数为<u>长度</u></li><li>operator &gt; &#x2F; &lt;   -&gt;  string 类重载了这两个运算符，可以直接用于字典序的比较</li><li>compare(const string&amp; str)，返回值如下：<ul><li>0, equal</li><li>-1, lf &lt; rf</li><li>1, lf &gt; rf</li></ul></li><li>erase(start_idx, len)   -&gt; 利用索引和长度删除指定范围的字符</li><li>erase(iterator start, iterator end)  -&gt; 利用迭代器删除指定范围内的字符，[start, end)</li><li>delimeter划分<ul><li>借助getline(<string>) 和 istringstrem(sstream)对字符串进行  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string str=<span class="hljs-string">&quot;She is a girl.&quot;</span>; <span class="hljs-comment">// istringstream 默认以空格进行划分</span><br><span class="hljs-function">istringstream <span class="hljs-title">is</span><span class="hljs-params">(str)</span></span>;<br>string buf;<br><span class="hljs-keyword">while</span>(is&gt;&gt;buf)<br>&#123;<br>    cout&lt;&lt;buf&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">// 借助geline -&gt; 缺点是只能delimeter只能为单个字符</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">getline</span> <span class="hljs-params">( istream &amp;is , string &amp;str , <span class="hljs-type">char</span> delim )</span></span>;<br><span class="hljs-type">char</span> del=<span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(is,buf,del))<br>&#123;<br>    <span class="hljs-keyword">if</span>(buf.<span class="hljs-built_in">size</span>()) cout&lt;&lt;buf;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><ul><li>&lt;stcak&gt;</li><li>push()</li><li>pop() -&gt; 注意返回值为 void，因此取元素只能用top()方法 ❗️</li><li>top()</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><ul><li>&lt;queue&gt;</li><li>push()</li><li>pop() ❗️ -&gt; 注意返回值为 void，因此取元素只能用front()方法</li><li>top() ❌ -&gt; 没有这个方法，要使用front()</li><li>front() -&gt; 查看队列头部的元素[先插入的]</li><li>back() -&gt; 查看队列尾部的元素[后插入的]</li><li>empty()</li><li>begin() ❌ -&gt; 没有这个方法</li><li>size()</li><li>swap() -&gt; <a href="https://cplusplus.com/reference/stack/stack/swap/">交换两个栈的内容</a></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul><li>erase() ❗️ multiset在使用这个方法删除某个key时，会把所有相同的key删除；如果想要删除一个，需要先使用find返回迭代器，并将迭代器作为该方法的参数</li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li>&lt;mao&gt;</li><li>erase() -&gt; 参数可以为 <strong>iterator</strong>，<strong>key</strong>；也可以为范围参数’[first it, last it)’</li><li>大 -&gt; 小排列 <code>map&lt;int, multiset&lt;int&gt;, std::greater&lt;int&gt;&gt;</code></li><li>定义map型对象时，如何自定义key比较函数：注意只能定义key的比较函数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp_key</span><br>&#123;<br>    <span class="hljs-comment">// 注意，函数的参数需要于map的key的参数类型相同</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">key_t</span> &amp;k1, <span class="hljs-type">const</span> <span class="hljs-type">key_t</span> &amp;k2)</span><span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(k1.dwBussID != k2.dwBussID)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwBussID &lt; k2.dwBussID;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(k1.dwVersion != k2.dwVersion)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwVersion &lt; k2.dwVersion;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k1.dwHashUrl != k2.dwHashUrl)<br>        &#123;<br>            <span class="hljs-keyword">return</span> k1.dwHashUrl &lt; k2.dwHashUrl;<br>        &#125;<br>　　　　　　　　  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用库函数运算"><a href="#常用库函数运算" class="headerlink" title="常用库函数运算"></a>常用库函数运算</h2><h3 id="lower-bound-iterator-start-iterator-end-value"><a href="#lower-bound-iterator-start-iterator-end-value" class="headerlink" title="lower_bound(iterator_start, iterator_end, value) -&gt;"></a>lower_bound(iterator_start, iterator_end, value) -&gt;</h3><ul><li>返回第一个迭代器it，其值<strong>不满足</strong> <code>(*it) &lt; value</code></li><li>即找到第一个迭代器，其值<strong>满足</strong> <code>value &lt;= (*it)</code></li><li>参数可以为&amp;arr[i]，返回值也为该类型，<a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/submissions/545900287/">参考</a></li></ul><h3 id="upper-bound-start-end-value"><a href="#upper-bound-start-end-value" class="headerlink" title="upper_bound(start, end, value) -&gt;"></a>upper_bound(start, end, value) -&gt;</h3><ul><li>返回第一个迭代器，其值<strong>满足</strong> <code>value &lt; (*it)</code></li></ul><h3 id="atan2-double"><a href="#atan2-double" class="headerlink" title="atan2() -&gt; double"></a>atan2() -&gt; double</h3><ul><li>求坐标(x, y)到x轴的极角，范围为[-pi, pi]。这里要注意坐标上的点在-x轴上时，其极角可能为-pi，也可能为pi，但只能为一个值<ul><li><a href="https://leetcode.cn/problems/maximum-number-of-visible-points/description/">1610. 可见点的最大数目</a></li></ul></li></ul><h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h3><ul><li>返回数组的全排列</li><li>使用前需要对数组进行小-&gt;大的排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2024/06/24/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/monotonous-stack/">单调栈</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>弹出时只能从栈顶[st.top()]弹出</li><li>从栈顶到栈底，元素大小呈某种单调趋势</li><li>当欲压入栈的元素不满足这个单调性时，就要把不满足单调性的所有[栈顶]元素弹出 -&gt; 这个性质用到的比较多</li><li>配合数组使用时，栈内可以存储对应元素的下标，而不是元素值</li></ul><h2 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h2><ul><li>使用时要注意考虑单调顺序：1️⃣递增，2️⃣递减</li><li>要搞清楚单调栈中记录元素的意义：例如题—[503]，单调栈中记录的是还没有找到下一个更大值的<em><strong>下标</strong></em>, 只要遍历到比栈顶元素值更大的数，就意味着栈顶元素找到了答案，记录答案，然后从栈顶弹出</li><li>一定要注意单调栈里存储的是<em><strong>索引</strong></em>还是<em><strong>元素值</strong></em></li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503.下一个更大元素2</a></li><li><a href="https://leetcode.cn/problems/next-greater-element-iii/description/">556.下一个更大元素3</a>: 变形题，比较有意思！！！</li></ul><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><ul><li>[556] 一定要注意题目的条件 -&gt; <ul><li>满足条件的最小整数</li><li>如果最小的不是32位整数，也返回-1</li></ul></li></ul><h2 id="扩展-循环数组"><a href="#扩展-循环数组" class="headerlink" title="扩展-循环数组"></a>扩展-循环数组</h2><ul><li>处理方式1：将[0:n-1]个个数顺序拷贝到第n个数后面，构成一个普通数组</li><li>处理方式2：遍历[0:2n-1)次，取元素时对下标取模</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="优质参考博客"><a href="#优质参考博客" class="headerlink" title="优质参考博客"></a>优质参考博客</h2><ul><li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li><li><a href="https://writings.sh/post/union-find">并查集简记</a></li></ul><h2 id="Leetcode-题目"><a href="#Leetcode-题目" class="headerlink" title="Leetcode 题目"></a>Leetcode 题目</h2><ul><li><a href="https://leetcode.cn/problems/smallest-string-with-swaps/description/">1202.交换字符串中的元素</a></li></ul><h2 id="对应题解"><a href="#对应题解" class="headerlink" title="对应题解"></a>对应题解</h2><ul><li>1202 [from Andy at Leetcode]<blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> father[<span class="hljs-number">100010</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//并查集find</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x==father[x]?x:(father[x] = <span class="hljs-built_in">find</span>(father[x]));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><span class="hljs-comment">//并查集merge</span></span><br><span class="hljs-function">    </span>&#123;<br>        father[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">smallestStringWithSwaps</span><span class="hljs-params">(string s, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        string areastr[<span class="hljs-number">100010</span>]; <span class="hljs-comment">//areastr[x]含义为并查集里所有father==x的结点集合</span><br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">100010</span>] =&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//cnt[x]含义为areastr[x]内的第一个未分配元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) father[i] = i;<span class="hljs-comment">//初始化并查集</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i: pairs) <span class="hljs-built_in">merge</span>(i[<span class="hljs-number">1</span>], i[<span class="hljs-number">0</span>]);<span class="hljs-comment">//merge连通结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            areastr[<span class="hljs-built_in">find</span>(i)]+=s[i];<span class="hljs-comment">//将s[i]添加到连通结点集合内</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            <span class="hljs-built_in">sort</span>(areastr[i].<span class="hljs-built_in">begin</span>(),areastr[i].<span class="hljs-built_in">end</span>());<span class="hljs-comment">//对每个连通图内容排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>            s[i] = areastr[father[i]][cnt[<span class="hljs-built_in">find</span>(i)]++];<span class="hljs-comment">//根据连通图内排序后结果还原字符串</span><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>刷题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDS回环-吞吐量测试记录</title>
    <link href="/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/06/22/DDS%E5%9B%9E%E7%8E%AF-%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LW-DDS"><a href="#LW-DDS" class="headerlink" title="LW DDS"></a>LW DDS</h2><ul><li>240607-可以用于毕业小实验数据采集</li><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="Cyclone-DDS"><a href="#Cyclone-DDS" class="headerlink" title="Cyclone DDS"></a>Cyclone DDS</h2><ul><li>240624-用于项目中期考察时的补充实验：回环&#x2F;吞吐量</li></ul><h2 id="RTI-DDS"><a href="#RTI-DDS" class="headerlink" title="RTI DDS"></a>RTI DDS</h2><p>- </p><h2 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h2><ul><li>Cyclone 和 Fast[2.12.0]都定义了0x8007这个PID，但是含义不一样，因此Fast在接收到Cyclone的data(p)报文，进行处理时出错，不会创建参与者代理，因此匹配不了</li><li>FastDDS调试时常用的断点：<ul><li>on_new_cache_change_added() [“Ignore announcement from own RTPSParticipant”] at file: PDPListener.cpp -&gt; 用于处理data(p)报文</li><li>EDPSimplePUBListener::on_new_cache_change_added() at file: EDPSimpleListeners.cpp -&gt; 用于处理data(w)报文</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回文串性质</title>
    <link href="/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/"/>
    <url>/2024/06/22/%E5%9B%9E%E6%96%87%E4%B8%B2%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="参考题目"><a href="#参考题目" class="headerlink" title="参考题目"></a>参考题目</h2><ul><li><a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/">2663. 字典序最小的美丽字符串</a></li><li><a href="https://leetcode.cn/problems/find-palindrome-with-fixed-length/description/">2217. 找到指定长度的回文数</a></li></ul><h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><ul><li>aa，aba，很明显，最小模式的回文串只有这两种模式</li><li>对于长度为 m (m &gt; 3) 的回文串，其必包含长度为 m-2 的回文串</li><li>因此，“不包含任何长度为2或更长的回文串” &lt;&#x3D;&#x3D;&gt; “不包含长度为2或3的回文串”</li><li>当用[0-9]的数字来组成回文串，则其长度为n的回文串按大小排序时，有明显的规律</li><li>要注意：回文串是有<em><strong>对称性</strong></em>的，因此长度为n的回文串（由数字组成时），可以由其前(n+1)&#x2F;2个整数部分唯一确定，因为后续的数字与前面的数字成镜像对称</li><li>回文串的<strong>中间部分</strong>一定是由连续且相同的字符串组成：<code>aba</code>, <code>abccba</code>, <code>tartattatrat</code></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>如果题目中“不包含任何长度为2或更长” 改为-&gt; “不包含任何长度为3&#x2F;4&#x2F;5&#x2F;m或更长”，该怎么做？</li></ul><h2 id="基础：回文串的判别"><a href="#基础：回文串的判别" class="headerlink" title="基础：回文串的判别"></a>基础：回文串的判别</h2><ul><li>可以根据对称性进行回文串的判断<ol><li>区分长度的奇偶性，找到双指针i，j</li><li>i–，j++分别判断s[i] &#x3D;&#x3D; s[j]是否成立</li><li>要注意：如果字串长度为奇数，则只能为<code>aba</code>类型；但是当字串长度为偶数是，可以为<code>aa</code>，也可以为<code>abaaba</code></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/22/hello-world/"/>
    <url>/2024/06/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
